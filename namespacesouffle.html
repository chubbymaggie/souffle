<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>souffle: souffle Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">1.2.0-360-gecb9d25</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">souffle Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1gzfstream"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1gzfstream.html">gzfstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1macro"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1macro.html">macro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1ram"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1ram.html">ram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1scheduler"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1scheduler.html">scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adorned_clause.html">AdornedClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adorned_predicate.html">AdornedPredicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adornment.html">Adornment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_assignment.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment maps a list of variables to values of their respective property space.  <a href="classsouffle_1_1_assignment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast__visitor__tag.html">ast_visitor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type required for the is_ast_visitor type trait to identify AstVisitors.  <a href="structsouffle_1_1ast__visitor__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_aggregator.html">AstAggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument aggregating a value from a sub-query.  <a href="classsouffle_1_1_ast_aggregator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_analysis.html">AstAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a AST Analysis.  <a href="classsouffle_1_1_ast_analysis.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of an argument.  <a href="classsouffle_1_1_ast_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents the use of a relation either in the head or in the body of a Clause, e.g., parent(x,y).  <a href="classsouffle_1_1_ast_atom.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_attribute.html">AstAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of an attribute which stores the name and the type of an attribute.  <a href="classsouffle_1_1_ast_attribute.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_binary_functor.html">AstBinaryFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a binary function.  <a href="classsouffle_1_1_ast_binary_functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of a datalog clause.  <a href="classsouffle_1_1_ast_clause.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component.html">AstComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A AST node describing a component within the input program.  <a href="classsouffle_1_1_ast_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_checker.html">AstComponentChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_init.html">AstComponentInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node type representing expressions utilized to initialize components by binding them to a name.  <a href="classsouffle_1_1_ast_component_init.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_type.html">AstComponentType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component type is the class utilized to represent a construct of the form.  <a href="classsouffle_1_1_ast_component_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_constant.html">AstConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a datalog constant value.  <a href="classsouffle_1_1_ast_constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents a binary constraint e.g., x = y.  <a href="classsouffle_1_1_ast_constraint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_counter.html">AstCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a counter (for projections only)  <a href="classsouffle_1_1_ast_counter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_order.html">AstExecutionOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An execution order for atoms within a clause.  <a href="classsouffle_1_1_ast_execution_order.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_plan.html">AstExecutionPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class utilized to model user-defined execution plans for various versions of clauses.  <a href="classsouffle_1_1_ast_execution_plan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_plan_checker.html">AstExecutionPlanChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_functor.html">AstFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common base class for AST functors.  <a href="classsouffle_1_1_ast_functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_i_o_directive.html">AstIODirective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of an argument of a Literal (e.g., a variable or a constant)  <a href="classsouffle_1_1_ast_i_o_directive.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of atoms, binary relations, and negated atoms in the body and head of a clause.  <a href="classsouffle_1_1_ast_literal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_negation.html">AstNegation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents a negated atom, * e.g., !parent(x,y).  <a href="classsouffle_1_1_ast_negation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for syntactic elements in a Datalog program.  <a href="classsouffle_1_1_ast_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_node_mapper.html">AstNodeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for manipulating AST Nodes by substitution.  <a href="classsouffle_1_1_ast_node_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_null_constant.html">AstNullConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="classsouffle_1_1_ast_constant.html" title="Subclass of Argument that represents a datalog constant value. ">AstConstant</a> that represents a null-constant (no record)  <a href="classsouffle_1_1_ast_null_constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_number_constant.html">AstNumberConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a datalog constant value.  <a href="classsouffle_1_1_ast_number_constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_pragma.html">AstPragma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a global option.  <a href="classsouffle_1_1_ast_pragma.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_pragma_checker.html">AstPragmaChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_primitive_type.html">AstPrimitiveType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A primitive type is named type that can either be a sub-type of the build-in number or symbol type.  <a href="classsouffle_1_1_ast_primitive_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of a datalog program that consists of relations, clauses and types.  <a href="classsouffle_1_1_ast_program.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_record_init.html">AstRecordInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument that takes a list of values and combines them into a new record.  <a href="classsouffle_1_1_ast_record_init.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_record_type.html">AstRecordType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record type aggregates a list of fields into a new type.  <a href="classsouffle_1_1_ast_record_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of identifier utilized for referencing relations.  <a href="classsouffle_1_1_ast_relation_identifier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_semantic_checker.html">AstSemanticChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class describing a range in an input file.  <a href="classsouffle_1_1_ast_src_location.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_string_constant.html">AstStringConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a datalog constant value.  <a href="classsouffle_1_1_ast_string_constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_subroutine_argument.html">AstSubroutineArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument taking its value from an argument of a RAM subroutine.  <a href="classsouffle_1_1_ast_subroutine_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_ternary_functor.html">AstTernaryFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_transformer.html">AstTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ast_translation_unit.html" title="AstTranslationUnit class. ">AstTranslationUnit</a> class.  <a href="classsouffle_1_1_ast_translation_unit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_translator.html">AstTranslator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class capable of conducting the conversion between AST and RAM structures.  <a href="classsouffle_1_1_ast_translator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_type.html">AstType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_type_cast.html">AstTypeCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument capable of casting a value of one type into another.  <a href="classsouffle_1_1_ast_type_cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_type_identifier.html">AstTypeIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of identifier utilized for referencing types.  <a href="classsouffle_1_1_ast_type_identifier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_unary_functor.html">AstUnaryFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a unary function.  <a href="classsouffle_1_1_ast_unary_functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_union_type.html">AstUnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union type combines multiple types into a new super type.  <a href="classsouffle_1_1_ast_union_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_unnamed_variable.html">AstUnnamedVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents an unnamed variable.  <a href="classsouffle_1_1_ast_unnamed_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Argument that represents a named variable.  <a href="classsouffle_1_1_ast_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic base type of all AstVisitors realizing the dispatching of visitor calls.  <a href="structsouffle_1_1_ast_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_auto_index.html">AutoIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_auto_schedule_transformer.html">AutoScheduleTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass which tunes the given program by re-ordering the atoms in the included rules to improve performance.  <a href="classsouffle_1_1_auto_schedule_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_base_table.html">BaseTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_binary_relation.html">BinaryRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_block_list.html">BlockList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that is designed to mimic std::list, but with better destructor speed It achieves this by allocating comparatively large chunks of memory as it needs This is not thread safe, except, when there is guarantee of at most one writer AND the TBB data structure is in use.  <a href="classsouffle_1_1_block_list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1btree__multiset.html">btree_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A b-tree based multi-set implementation.  <a href="classsouffle_1_1btree__multiset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1btree__set.html">btree_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A b-tree based set implementation.  <a href="classsouffle_1_1btree__set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cache_access_counter.html">CacheAccessCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to keep track of cache hits/misses.  <a href="classsouffle_1_1_cache_access_counter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cmd_options.html">CmdOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for parsing command line arguments within generated query programs.  <a href="classsouffle_1_1_cmd_options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1comp__deref.html">comp_deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor class supporting the values pointers are pointing to.  <a href="structsouffle_1_1comp__deref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_component_instantiation_transformer.html">ComponentInstantiationTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_component_lookup.html">ComponentLookup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1concurrent__list.html">concurrent_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concurrent list data structure, which is implemented through a chunked linked-list.  <a href="classsouffle_1_1concurrent__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic base class for constraints on variables.  <a href="classsouffle_1_1_constraint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_c_p_p_identifier_map.html">CPPIdentifierMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singleton which provides a mapping from strings to unique valid CPP identifiers.  <a href="classsouffle_1_1_c_p_p_identifier_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_report.html">DebugReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a HTML report, consisting of a list of sections.  <a href="classsouffle_1_1_debug_report.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_reporter.html">DebugReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass which wraps another transformation pass and generates a debug report section for the stage after applying the wrapped transformer, and adds it to the translation unit's debug report.  <a href="classsouffle_1_1_debug_reporter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_report_section.html">DebugReportSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a section of a HTML report.  <a href="classsouffle_1_1_debug_report_section.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref.html">deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor dereferencing a given type.  <a href="structsouffle_1_1deref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref__less.html">deref_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor comparing the dereferenced value of a pointer type utilizing a given comparator.  <a href="structsouffle_1_1deref__less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_diagnostic.html">Diagnostic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_diagnostic_message.html">DiagnosticMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_disjoint_set.html">DisjointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that emulates a Disjoint Set, i.e.  <a href="classsouffle_1_1_disjoint_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_eval_context.html">EvalContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_execution_summary.html">ExecutionSummary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The summary to be returned from a statement.  <a href="structsouffle_1_1_execution_summary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain.html">Explain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain_provenance.html">ExplainProvenance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain_provenance_s_l_d.html">ExplainProvenanceSLD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_extract_disconnected_literals_transformer.html">ExtractDisconnectedLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to move literals out of a clause and into new relations if they are independent of head arguments.  <a href="classsouffle_1_1_extract_disconnected_literals_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_global.html">Global</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple graph structure for graph-based operations.  <a href="classsouffle_1_1_graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1id.html">id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor representing the identity function for a generic type T.  <a href="structsouffle_1_1id.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_inline_relations_transformer.html">InlineRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to inline marked relations.  <a href="classsouffle_1_1_inline_relations_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_inner_node.html">InnerNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter.html">Interpreter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM interpreter.  <a href="classsouffle_1_1_interpreter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_environment.html">InterpreterEnvironment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An environment encapsulates all the context information required for processing a RAM program.  <a href="classsouffle_1_1_interpreter_environment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_eq_relation.html">InterpreterEqRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_interpreter.html" title="A RAM interpreter. ">Interpreter</a> Equivalence <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a>.  <a href="classsouffle_1_1_interpreter_eq_relation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_index_order.html">InterpreterIndexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class describing the sorting order of tuples within an index.  <a href="classsouffle_1_1_interpreter_index_order.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_prog_interface.html">InterpreterProgInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classsouffle_1_1_souffle_program.html" title="Abstract base class for generated Datalog programs. ">SouffleProgram</a> interface for an interpreter instance.  <a href="classsouffle_1_1_interpreter_prog_interface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_relation.html">InterpreterRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_interpreter.html" title="A RAM interpreter. ">Interpreter</a> <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a>.  <a href="classsouffle_1_1_interpreter_relation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_rel_interface.html">InterpreterRelInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for interpreter relations.  <a href="classsouffle_1_1_interpreter_rel_interface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_i_o_directives.html">IODirectives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_i_o_system.html">IOSystem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for an iterator obtaining pointers of a certain type, dereferencing values before forwarding them to the consumer.  <a href="structsouffle_1_1_iter_deref_wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1lambda__traits.html">lambda_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait enabling the deduction of type properties of lambdas.  <a href="structsouffle_1_1lambda__traits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_leaf_node.html">LeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_lock.html">Lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small utility class for implementing simple locks.  <a href="structsouffle_1_1_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class utilized to times for the souffle profiling tool.  <a href="classsouffle_1_1_logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_magic_set_transformer.html">MagicSetTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic Set Transformation.  <a href="classsouffle_1_1_magic_set_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_main_config.html">MainConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_main_option.html">MainOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom.  <a href="classsouffle_1_1_materialize_aggregation_queries_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_max_matching.html">MaxMatching</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1member__fun.html">member_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct wrapping a object and an associated member function pointer into a callable object.  <a href="structsouffle_1_1member__fun.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_normalise_constraints_transformer.html">NormaliseConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to normalise constraints.  <a href="classsouffle_1_1_normalise_constraints_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_null_stream.html">NullStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream ignoring everything written to it.  <a href="classsouffle_1_1_null_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_optimistic_read_write_lock.html">OptimisticReadWriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'sequential' non-locking implementation for an optimistic r/w lock.  <a href="classsouffle_1_1_optimistic_read_write_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_order.html">Order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing the order of predicates in the body of a rule.  <a href="classsouffle_1_1_order.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_parser_driver.html">ParserDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_precedence_graph.html">PrecedenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing the precedence graph of the relations of the datalog progam.  <a href="classsouffle_1_1_precedence_graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_predefined_type.html">PredefinedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special, internal type for the predefined symbolic and numeric types.  <a href="structsouffle_1_1_predefined_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_primitive_type.html">PrimitiveType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A primitive type.  <a href="classsouffle_1_1_primitive_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1print__deref.html">print_deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor printing elements after dereferencing it.  <a href="structsouffle_1_1print__deref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_problem.html">Problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A problem is a list of constraints for which a solution is desired.  <a href="classsouffle_1_1_problem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_program_factory.html">ProgramFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract program factory class.  <a href="classsouffle_1_1_program_factory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1property__space.html">property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A MPL type for defining a property space.  <a href="structsouffle_1_1property__space.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_provenance_transformer.html">ProvenanceTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add provenance information via guided SLD.  <a href="classsouffle_1_1_provenance_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ram__visitor__tag.html">ram_visitor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type required for the is_ram_visitor type trait to identify RamVisitors.  <a href="structsouffle_1_1ram__visitor__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_aggregate.html">RamAggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregation.  <a href="classsouffle_1_1_ram_aggregate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_analysis.html">RamAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a RAM Analysis.  <a href="classsouffle_1_1_ram_analysis.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_and.html">RamAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjunction.  <a href="classsouffle_1_1_ram_and.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_argument.html">RamArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access argument of a subroutine.  <a href="classsouffle_1_1_ram_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_auto_increment.html">RamAutoIncrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter.  <a href="classsouffle_1_1_ram_auto_increment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_binary_operator.html">RamBinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary function.  <a href="classsouffle_1_1_ram_binary_operator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_binary_relation.html">RamBinaryRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary constraint.  <a href="classsouffle_1_1_ram_binary_relation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_clear.html">RamClear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete tuples of a relation.  <a href="classsouffle_1_1_ram_clear.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Class for RAM condition.  <a href="classsouffle_1_1_ram_condition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_create.html">RamCreate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new RAM relation.  <a href="classsouffle_1_1_ram_create.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_debug_info.html">RamDebugInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug statement.  <a href="classsouffle_1_1_ram_debug_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_drop.html">RamDrop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop relation, i.e., delete it from memory.  <a href="classsouffle_1_1_ram_drop.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_element_access.html">RamElementAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element from the current tuple in a tuple environment.  <a href="classsouffle_1_1_ram_element_access.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_empty.html">RamEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check for a relation.  <a href="classsouffle_1_1_ram_empty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_exit.html">RamExit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit statement for a loop.  <a href="classsouffle_1_1_ram_exit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_fact.html">RamFact</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a fact into a relation.  <a href="classsouffle_1_1_ram_fact.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_insert.html">RamInsert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A relational algebra query TODO (#541): Rename RAM statement: it is used for projection and sub-routines.  <a href="classsouffle_1_1_ram_insert.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_load.html">RamLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load data into a relation.  <a href="classsouffle_1_1_ram_load.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_log_size.html">RamLogSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log relation size and a logging message.  <a href="classsouffle_1_1_ram_log_size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_log_timer.html">RamLogTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution time logger for a statement.  <a href="classsouffle_1_1_ram_log_timer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_lookup.html">RamLookup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record lookup.  <a href="classsouffle_1_1_ram_lookup.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_loop.html">RamLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement loop.  <a href="classsouffle_1_1_ram_loop.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_merge.html">RamMerge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge tuples from a source into target relation.  <a href="classsouffle_1_1_ram_merge.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_node.html" title="RamNode is a superclass for all RAM IR classes. ">RamNode</a> is a superclass for all RAM IR classes.  <a href="classsouffle_1_1_ram_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_node_mapper.html">RamNodeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for manipulating RAM Nodes by substitution.  <a href="classsouffle_1_1_ram_node_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_not_exists.html">RamNotExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not existence check for a relation.  <a href="classsouffle_1_1_ram_not_exists.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_number.html">RamNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number Constant.  <a href="classsouffle_1_1_ram_number.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_operation.html">RamOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a relational algebra operation.  <a href="classsouffle_1_1_ram_operation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_pack.html">RamPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record pack operation.  <a href="classsouffle_1_1_ram_pack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel.html">RamParallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel block.  <a href="classsouffle_1_1_ram_parallel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_print_size.html">RamPrintSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print relation size and a print message.  <a href="classsouffle_1_1_ram_print_size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_program.html">RamProgram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_project.html">RamProject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection.  <a href="classsouffle_1_1_ram_project.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation.html">RamRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> in the RAM intermediate representation.  <a href="classsouffle_1_1_ram_relation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation_ref.html">RamRelationRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> in the RAM intermediate representation.  <a href="classsouffle_1_1_ram_relation_ref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation_statement.html">RamRelationStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM Statements with a single relation.  <a href="classsouffle_1_1_ram_relation_statement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_return.html">RamReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement for returning from a ram subroutine.  <a href="classsouffle_1_1_ram_return.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_scan.html">RamScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> Scan.  <a href="classsouffle_1_1_ram_scan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_search.html">RamSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for relation scans and lookups.  <a href="classsouffle_1_1_ram_search.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_semantic_checker.html">RamSemanticChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic checker for RAM programs.  <a href="classsouffle_1_1_ram_semantic_checker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_sequence.html">RamSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of RAM statements.  <a href="classsouffle_1_1_ram_sequence.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for RAM statements.  <a href="classsouffle_1_1_ram_statement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_store.html">RamStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data of a relation.  <a href="classsouffle_1_1_ram_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_swap.html">RamSwap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation two relations.  <a href="classsouffle_1_1_ram_swap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_ternary_operator.html">RamTernaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary Function.  <a href="classsouffle_1_1_ram_ternary_operator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_transformer.html">RamTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Transformer Class for RAM.  <a href="classsouffle_1_1_ram_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_translation_unit.html">RamTranslationUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for <a class="el" href="classsouffle_1_1_ram_translation_unit.html" title="Class for RamTranslationUnit. ">RamTranslationUnit</a>.  <a href="classsouffle_1_1_ram_translation_unit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_unary_operator.html">RamUnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary function.  <a href="classsouffle_1_1_ram_unary_operator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_value.html">RamValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for describing scalar values in RAM.  <a href="classsouffle_1_1_ram_value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic base type of all RamVisitors realizing the dispatching of visitor calls.  <a href="structsouffle_1_1_ram_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class enabling representation of ranges by pairing two iterator instances marking lower and upper boundaries.  <a href="structsouffle_1_1range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_cin_c_s_v_factory.html">ReadCinCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_file_c_s_v.html">ReadFileCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_file_c_s_v_factory.html">ReadFileCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_s_q_lite_factory.html">ReadSQLiteFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream.html">ReadStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_c_s_v.html">ReadStreamCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_factory.html">ReadStreamFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_s_q_lite.html">ReadStreamSQLite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_write_lock.html">ReadWriteLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_record_type.html">RecordType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record type combining a list of fields into a new, aggregated type.  <a href="structsouffle_1_1_record_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_recursive_clauses.html">RecursiveClauses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass identifying clauses which are recursive.  <a href="classsouffle_1_1_recursive_clauses.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_reduce_existentials_transformer.html">ReduceExistentialsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reduce unnecessary computation for relations that only appear in the form A(_,...,_).  <a href="classsouffle_1_1_reduce_existentials_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_redundant_relations.html">RedundantRelations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass identifying relations which do not contribute to the computation of the output relations.  <a href="classsouffle_1_1_redundant_relations.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation.html">Relation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object-oriented wrapper class for Souffle's templatized relations.  <a href="classsouffle_1_1_relation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_schedule.html">RelationSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing a schedule for computing relations.  <a href="classsouffle_1_1_relation_schedule.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_schedule_step.html">RelationScheduleStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in a relation schedule, consisting of the relations computed in the step and the relations that are no longer required at that step.  <a href="classsouffle_1_1_relation_schedule_step.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_stats.html">RelationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A summary of statistical properties of a ram relation.  <a href="classsouffle_1_1_relation_stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_wrapper.html">RelationWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> wrapper used internally in the generated Datalog program.  <a href="classsouffle_1_1_relation_wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_empty_relations_transformer.html">RemoveEmptyRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove all empty relations and rules that use empty relations.  <a href="classsouffle_1_1_remove_empty_relations_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_redundant_relations_transformer.html">RemoveRedundantRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove relations which are redundant (do not contribute to output).  <a href="classsouffle_1_1_remove_redundant_relations_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_relation_copies_transformer.html">RemoveRelationCopiesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replaces copy of relations by their origin.  <a href="classsouffle_1_1_remove_relation_copies_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_resolve_aliases_transformer.html">ResolveAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to eliminate grounded aliases.  <a href="classsouffle_1_1_resolve_aliases_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_rule_body.html">RuleBody</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1scanner__data.html">scanner_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_s_c_c_graph.html">SCCGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing the strongly connected component (SCC) graph for the datalog program.  <a href="classsouffle_1_1_s_c_c_graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_screen_buffer.html">ScreenBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1set__property__space.html">set_property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property space for set-based properties based on sub-set lattices.  <a href="structsouffle_1_1set__property__space.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1shared__mutex.html">shared_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_signal_handler.html">SignalHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classsouffle_1_1_signal_handler.html" title="Class SignalHandler captures signals and reports the context where the signal occurs. ">SignalHandler</a> captures signals and reports the context where the signal occurs.  <a href="classsouffle_1_1_signal_handler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_single_value_iterator.html">SingleValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to be utilized if there is only a single element to iterate over.  <a href="classsouffle_1_1_single_value_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_souffle_program.html">SouffleProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for generated Datalog programs.  <a href="classsouffle_1_1_souffle_program.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_array.html">SparseArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse array simulates an array associating to every element of uint32_t an element of a generic type T.  <a href="classsouffle_1_1_sparse_array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_bit_map.html">SparseBitMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse bit-map is a bit map virtually assigning a bit value to every value if the uint32_t domain.  <a href="classsouffle_1_1_sparse_bit_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_disjoint_set.html">SparseDisjointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_spin_lock.html">SpinLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'sequential' non-locking implementation for a spin lock.  <a href="classsouffle_1_1_spin_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_split_stream.html">SplitStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream copying its input to multiple output streams.  <a href="classsouffle_1_1_split_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_string_pool.html">StringPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_symbol_mask.html">SymbolMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_symbol_table.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_global.html">Global</a> pool of re-usable strings.  <a href="classsouffle_1_1_symbol_table.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser.html">Synthesiser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM synthesiser: synthesises a C++ program from a RAM program.  <a href="classsouffle_1_1_synthesiser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_table.html">Table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_topologically_sorted_s_c_c_graph.html">TopologicallySortedSCCGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing a topologically sorted strongly connected component (SCC) graph.  <a href="classsouffle_1_1_topologically_sorted_s_c_c_graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_tree_node.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_trie.html">Trie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most generic implementation of a <a class="el" href="classsouffle_1_1_trie.html" title="The most generic implementation of a Trie forming the top-level of any Trie storing tuples of arity &gt;...">Trie</a> forming the top-level of any <a class="el" href="classsouffle_1_1_trie.html" title="The most generic implementation of a Trie forming the top-level of any Trie storing tuples of arity &gt;...">Trie</a> storing tuples of arity &gt; 1.  <a href="classsouffle_1_1_trie.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_trie_3_010u_01_4.html">Trie&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for the 0-ary try.  <a href="classsouffle_1_1_trie_3_010u_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_trie_3_011u_01_4.html">Trie&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for tries containing tuples exhibiting a single element.  <a href="classsouffle_1_1_trie_3_011u_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a tuple for the OO interface such that relations with varying columns can be accessed.  <a href="classsouffle_1_1tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for types to be covered within a type environment.  <a href="classsouffle_1_1_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_analysis.html">TypeAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_binding.html">TypeBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that encapsulates std::map of types binding that comes from .init c = Comp&lt;MyType&gt; <a class="el" href="classsouffle_1_1_type.html" title="An abstract base class for types to be covered within a type environment. ">Type</a> binding in this example would be T-&gt;MyType if the component code is .comp Comp&lt;T&gt; ...  <a href="classsouffle_1_1_type_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_environment.html">TypeEnvironment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type environment is a set of types.  <a href="classsouffle_1_1_type_environment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_environment_analysis.html">TypeEnvironmentAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection to represent sets of types.  <a href="structsouffle_1_1_type_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_union_type.html">UnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union type combining a list of types into a new, aggregated type.  <a href="classsouffle_1_1_union_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_unique_aggregation_variables_transformer.html">UniqueAggregationVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to rename aggregation variables to make them unique.  <a href="classsouffle_1_1_unique_aggregation_variables_transformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_unsupported_construct_exception.html">UnsupportedConstructException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of exception to be raised if an error in the conversion to a bddbddb input program has been encountered.  <a href="classsouffle_1_1_unsupported_construct_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable to be utilized within constraints to be handled by the constraint solver.  <a href="structsouffle_1_1_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_c_s_v.html">WriteCoutCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_c_s_v_factory.html">WriteCoutCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_file_c_s_v.html">WriteFileCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_file_c_s_v_factory.html">WriteFileCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_s_q_lite_factory.html">WriteSQLiteFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream.html">WriteStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_c_s_v.html">WriteStreamCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_factory.html">WriteStreamFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_s_q_lite.html">WriteStreamSQLite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a27e7ae3870a1911c9541de344a1f9f56"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a27e7ae3870a1911c9541de344a1f9f56">AstDomain</a></td></tr>
<tr class="memdesc:a27e7ae3870a1911c9541de344a1f9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">ast domain that contains ram domain  <a href="#a27e7ae3870a1911c9541de344a1f9f56">More...</a><br/></td></tr>
<tr class="separator:a27e7ae3870a1911c9541de344a1f9f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606048097fb760a78f4d0aad940468b0"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; const <br class="typebreak"/>
<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> <br class="typebreak"/>
*, <a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">AstRelationSet</a></td></tr>
<tr class="separator:a606048097fb760a78f4d0aad940468b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f91401943febd1544ad82fd99bcb04"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac0f91401943febd1544ad82fd99bcb04">block_t</a></td></tr>
<tr class="separator:ac0f91401943febd1544ad82fd99bcb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4b8e0036a730296e27f748f63f67b"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4cd4b8e0036a730296e27f748f63f67b">Column</a></td></tr>
<tr class="memdesc:a4cd4b8e0036a730296e27f748f63f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type to reference indices.  <a href="#a4cd4b8e0036a730296e27f748f63f67b">More...</a><br/></td></tr>
<tr class="separator:a4cd4b8e0036a730296e27f748f63f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae042659e2cf9240dc085d2d4da94a5f8"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae042659e2cf9240dc085d2d4da94a5f8">parent_t</a></td></tr>
<tr class="separator:ae042659e2cf9240dc085d2d4da94a5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b2899eb6927d9ee92a3628e0c5f4fc"><td class="memItemLeft" align="right" valign="top">typedef std::function<br class="typebreak"/>
&lt; <a class="el" href="structsouffle_1_1_execution_summary.html">ExecutionSummary</a>(const <br class="typebreak"/>
<a class="el" href="classsouffle_1_1_ram_insert.html">RamInsert</a> <br class="typebreak"/>
&amp;, <a class="el" href="classsouffle_1_1_interpreter_environment.html">InterpreterEnvironment</a> &amp;env, <br class="typebreak"/>
std::ostream *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">QueryExecutionStrategy</a></td></tr>
<tr class="memdesc:ad9b2899eb6927d9ee92a3628e0c5f4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of execution strategies for interpreter.  <a href="#ad9b2899eb6927d9ee92a3628e0c5f4fc">More...</a><br/></td></tr>
<tr class="separator:ad9b2899eb6927d9ee92a3628e0c5f4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54e5c2cf102680c9fec848f5ac6460c"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a></td></tr>
<tr class="separator:aa54e5c2cf102680c9fec848f5ac6460c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c63236e23ffee74b1ec5b83cd735710"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c63236e23ffee74b1ec5b83cd735710">rank_t</a></td></tr>
<tr class="separator:a3c63236e23ffee74b1ec5b83cd735710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f11646bb70dcb25008f6ee0686731b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac5f11646bb70dcb25008f6ee0686731b">SearchColumns</a></td></tr>
<tr class="memdesc:ac5f11646bb70dcb25008f6ee0686731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of an index key; each bit represents a column of a table  <a href="#ac5f11646bb70dcb25008f6ee0686731b">More...</a><br/></td></tr>
<tr class="separator:ac5f11646bb70dcb25008f6ee0686731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ede47ca253693a0980e580612116d6a"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a></td></tr>
<tr class="separator:a5ede47ca253693a0980e580612116d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8cc1c1de7899ad2b9e82ddd25b4607"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2d8cc1c1de7899ad2b9e82ddd25b4607">yyscan_t</a></td></tr>
<tr class="separator:a2d8cc1c1de7899ad2b9e82ddd25b4607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> { <br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">BinaryConstraintOp::__UNDEFINED__</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">BinaryConstraintOp::EQ</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">BinaryConstraintOp::NE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">BinaryConstraintOp::LT</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">BinaryConstraintOp::LE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">BinaryConstraintOp::GT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">BinaryConstraintOp::GE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">BinaryConstraintOp::MATCH</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">BinaryConstraintOp::CONTAINS</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">BinaryConstraintOp::NOT_MATCH</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">BinaryConstraintOp::NOT_CONTAINS</a>
<br/>
 }</td></tr>
<tr class="memdesc:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Constraint Operators.  <a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">More...</a><br/></td></tr>
<tr class="separator:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d062f6daca1d15c9ce9def0a2dffa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> { <br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8635afa1dc3f77400843ddfb2efa0065">BinaryOp::__UNDEFINED__</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">BinaryOp::ADD</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">BinaryOp::SUB</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">BinaryOp::MUL</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">BinaryOp::DIV</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">BinaryOp::EXP</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">BinaryOp::MOD</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BinaryOp::BAND</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BinaryOp::BOR</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BinaryOp::BXOR</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">BinaryOp::LAND</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">BinaryOp::LOR</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">BinaryOp::MAX</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">BinaryOp::MIN</a>, 
<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">BinaryOp::CAT</a>
<br/>
 }</td></tr>
<tr class="memdesc:ab85d062f6daca1d15c9ce9def0a2dffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Functor Operators.  <a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">More...</a><br/></td></tr>
<tr class="separator:ab85d062f6daca1d15c9ce9def0a2dffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fb351bed657eebdba6e217946f77cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cd">RamNodeType</a> { <br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda0778d130de0aaec61561e2bfd82e14a3">RN_Relation</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7676f5ee911e97eaa58e1dcf84c32c5c">RN_RelationRef</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda957b65c7967f8dadb2f1e100070d02df">RN_ElementAccess</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdafeebf712c92e98e255744083fc88df1b">RN_Number</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda389ad978a1adc590ed3a7443f3826ac9">RN_UnaryOperator</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda34ac87bf1212175637e427b827b85ca5">RN_BinaryOperator</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdaa3fc7b52063ef1026b3c795a7787ef11">RN_TernaryOperator</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae6c22967ac47af42e79bf8cf8a5d2ef9">RN_AutoIncrement</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2667a69690625f643f4ad6c428f4c4be">RN_Pack</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda289f746e4098127d9dc2a3d49b315761">RN_Argument</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda55f5f8caee82045f03ca2ce043ae93f5">RN_NotExists</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfbf34fd69ecd7dc79b40e5aa69058f5">RN_Empty</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda20544bc39b1abd7bfe3180a2d8c887ac">RN_And</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda9668393eb539061dfcb6b301f3b1e7d4">RN_BinaryRelation</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda352127eb5131d323d3bb3d549157edb4">RN_Project</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda33b8d825c4720f99fd4c4d1938be4e20">RN_Lookup</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda4f31ad94e70abc330cee3f5ecb4d0008">RN_Scan</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda39013c5953058360c2fffb8b70197291">RN_Aggregate</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda266d49c1ca2ce074aa65de75e544cba8">RN_Create</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3dfc8fce163f3e0262385800965f3081">RN_Fact</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdabd1e6f0c2341158b454ac9e197b46dbf">RN_Load</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac4d422e3f522ddf50d903bc9d86d2bd6">RN_Store</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda044cfc265a30e76bb4401ea8c2092735">RN_Insert</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda45b6499758cdff1b1cd641e6f6b05da4">RN_Clear</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2016c7cf3de1cbccef18849129e96e5f">RN_Drop</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda86ca15b0aa6e7e2ab4504f7154e32942">RN_PrintSize</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3ec2ab230c49b984f71f0723ccbd3cf4">RN_LogSize</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae1c7a265641a15d2af771d6e08ad1cb5">RN_Return</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac39e5c82dab9188688ad7393a0e44019">RN_Merge</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3cb4d51d4e612e8edfa924a0dc88fa29">RN_Swap</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7e273b6a1a729f8823655cde47774b16">RN_Program</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda64eaad858fb336c50b53522c1f9b2b46">RN_Sequence</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96d010733e134d66f42cfa8ec2cb504d">RN_Loop</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac0f9284e34690db294d6347caf550da3">RN_Parallel</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda689310ca05901bcb0ad45a4eaf09a022">RN_Exit</a>, 
<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfec87714070f1d244aaab8b106816e4">RN_LogTimer</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96502ff75b085775222f85976474aa55">RN_DebugInfo</a>
<br/>
 }</td></tr>
<tr class="separator:a98fb351bed657eebdba6e217946f77cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b421b00c7c5768cfaba47f3885e1c44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> { <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a8635afa1dc3f77400843ddfb2efa0065">TernaryOp::__UNDEFINED__</a>, 
<a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">TernaryOp::SUBSTR</a>
 }</td></tr>
<tr class="memdesc:a5b421b00c7c5768cfaba47f3885e1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary Functor Operators.  <a href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">More...</a><br/></td></tr>
<tr class="separator:a5b421b00c7c5768cfaba47f3885e1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c9e8fd9648e0022b397a57191e4f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> { <br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8635afa1dc3f77400843ddfb2efa0065">UnaryOp::__UNDEFINED__</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">UnaryOp::ORD</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">UnaryOp::STRLEN</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">UnaryOp::NEG</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">UnaryOp::BNOT</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">UnaryOp::LNOT</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">UnaryOp::SIN</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">UnaryOp::COS</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">UnaryOp::TAN</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">UnaryOp::ASIN</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">UnaryOp::ACOS</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">UnaryOp::ATAN</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">UnaryOp::SINH</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">UnaryOp::COSH</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">UnaryOp::TANH</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">UnaryOp::ASINH</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">UnaryOp::ACOSH</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">UnaryOp::ATANH</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">UnaryOp::LOG</a>, 
<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8c670f8c37b95e1ed14a0ce414b049c7">UnaryOp::EXP</a>
<br/>
 }</td></tr>
<tr class="memdesc:a717c9e8fd9648e0022b397a57191e4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary Operators for functors and constraints.  <a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">More...</a><br/></td></tr>
<tr class="separator:a717c9e8fd9648e0022b397a57191e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">absPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style realpath.  <a href="#a8a2c294e3ff514cd4ca29b466ff3cab3">More...</a><br/></td></tr>
<tr class="separator:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bcd21bf483197875a4221a669ba676"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a03bcd21bf483197875a4221a669ba676">addAggregators</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; ignoredNames)</td></tr>
<tr class="separator:a03bcd21bf483197875a4221a669ba676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad864a641b2c6a407647cd6c60ef196"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196">addBackwardDependencies</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; <a class="el" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:a0ad864a641b2c6a407647cd6c60ef196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb26477b4d38c4b4e56f65b124eef3c"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abfb26477b4d38c4b4e56f65b124eef3c">addForwardDependencies</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; <a class="el" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:abfb26477b4d38c4b4e56f65b124eef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20da927281260d0ab8c38d2148108538"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a20da927281260d0ab8c38d2148108538">addIgnoredRelations</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; <a class="el" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:a20da927281260d0ab8c38d2148108538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="memdesc:a14b5f9eb9ec09c40e558b242e75de872"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="#a14b5f9eb9ec09c40e558b242e75de872">More...</a><br/></td></tr>
<tr class="separator:a14b5f9eb9ec09c40e558b242e75de872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="memdesc:a34f8eecb81c090fca9e58d3357b63ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether any elements within a container satisfy a certain predicate.  <a href="#a34f8eecb81c090fca9e58d3357b63ed9">More...</a><br/></td></tr>
<tr class="separator:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532e17c4416fc5873367482f2e0623d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a> (std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt; &amp;stmtList, std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt; stmt)</td></tr>
<tr class="separator:a532e17c4416fc5873367482f2e0623d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac810dd526309dc398254f53e18edf50a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac810dd526309dc398254f53e18edf50a">areSubtypesOf</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;b)</td></tr>
<tr class="memdesc:ac810dd526309dc398254f53e18edf50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all types in s are subtypes of type b.  <a href="#ac810dd526309dc398254f53e18edf50a">More...</a><br/></td></tr>
<tr class="separator:ac810dd526309dc398254f53e18edf50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6202e50cad5266ddb9a18f3788df4625"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6202e50cad5266ddb9a18f3788df4625">binaryOpAcceptsNumbers</a> (int arg, const <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> op)</td></tr>
<tr class="memdesc:a6202e50cad5266ddb9a18f3788df4625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an argument has a number value.  <a href="#a6202e50cad5266ddb9a18f3788df4625">More...</a><br/></td></tr>
<tr class="separator:a6202e50cad5266ddb9a18f3788df4625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29028449b83efcd97fc86857d35572c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a29028449b83efcd97fc86857d35572c0">binaryOpAcceptsSymbols</a> (int arg, const <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> op)</td></tr>
<tr class="memdesc:a29028449b83efcd97fc86857d35572c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an argument has a symbolic value.  <a href="#a29028449b83efcd97fc86857d35572c0">More...</a><br/></td></tr>
<tr class="separator:a29028449b83efcd97fc86857d35572c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc6d2beab208ecbf25ddabd458256e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
std::set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a90cc6d2beab208ecbf25ddabd458256e">bindArguments</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *currAtom, std::set&lt; std::string &gt; boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a90cc6d2beab208ecbf25ddabd458256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6308ee8b92e79229e01daec1d68d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5c6308ee8b92e79229e01daec1d68d6a">bindComposites</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a5c6308ee8b92e79229e01daec1d68d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd6c596547a92b9afdb621eb8a89c91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_aggregator.html">AstAggregator</a> * &gt; aggrs, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> fun)</td></tr>
<tr class="separator:a7bd6c596547a92b9afdb621eb8a89c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190c528007c7083a21c340006061986d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a190c528007c7083a21c340006061986d">combineNegatedLiterals</a> (std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt;&gt; litGroups)</td></tr>
<tr class="memdesc:a190c528007c7083a21c340006061986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negated version of a disjunction of conjunctions.  <a href="#a190c528007c7083a21c340006061986d">More...</a><br/></td></tr>
<tr class="separator:a190c528007c7083a21c340006061986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d640155c037c468924198354aae2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">compileToBinary</a> (std::string compileCmd, const std::string &amp;sourceFilename)</td></tr>
<tr class="memdesc:a97d640155c037c468924198354aae2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles the given source file to a binary file.  <a href="#a97d640155c037c468924198354aae2ea">More...</a><br/></td></tr>
<tr class="separator:a97d640155c037c468924198354aae2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f53082a60ed5593022bde81dc619ac9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f53082a60ed5593022bde81dc619ac9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9">contains</a> (std::set&lt; T &gt; set, T element)</td></tr>
<tr class="separator:a6f53082a60ed5593022bde81dc619ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b30ea606023779f6ede16f65cc52db3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a> (std::set&lt; <a class="el" href="classsouffle_1_1_adorned_predicate.html">AdornedPredicate</a> &gt; adornedPredicates, <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> atomName, std::string atomAdornment)</td></tr>
<tr class="separator:a9b30ea606023779f6ede16f65cc52db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">contains</a> (const C &amp;container, const typename C::value_type &amp;element)</td></tr>
<tr class="memdesc:af3295dd83a588d612cf777e600beac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to check generically whether a given element is contained in a given container.  <a href="#af3295dd83a588d612cf777e600beac4a">More...</a><br/></td></tr>
<tr class="separator:af3295dd83a588d612cf777e600beac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb4465d8c07d802fb161440e0399ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeeb4465d8c07d802fb161440e0399ee1">containsAggregators</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause)</td></tr>
<tr class="separator:aeeb4465d8c07d802fb161440e0399ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d6e1a779132e5412105fc9cfb85ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af48d6e1a779132e5412105fc9cfb85ed">containsInlinedAtom</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:af48d6e1a779132e5412105fc9cfb85ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given clause contains an atom that should be inlined.  <a href="#af48d6e1a779132e5412105fc9cfb85ed">More...</a><br/></td></tr>
<tr class="separator:af48d6e1a779132e5412105fc9cfb85ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cc9786123f78bb67d7fc13d80b9639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a96cc9786123f78bb67d7fc13d80b9639">convertTupleToNums</a> (const <a class="el" href="classsouffle_1_1tuple.html">tuple</a> &amp;t)</td></tr>
<tr class="memdesc:a96cc9786123f78bb67d7fc13d80b9639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert a tuple to a RamDomain pointer.  <a href="#a96cc9786123f78bb67d7fc13d80b9639">More...</a><br/></td></tr>
<tr class="separator:a96cc9786123f78bb67d7fc13d80b9639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc675200d6e76f86c35bd33e1db6712c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afc675200d6e76f86c35bd33e1db6712c">createAdornedIdentifier</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> relationName, std::string adornment)</td></tr>
<tr class="separator:afc675200d6e76f86c35bd33e1db6712c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e37c3eb8d2931dbe421083736b6098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae9e37c3eb8d2931dbe421083736b6098">createAndLoad</a> (std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt; &amp;current, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *rel, const <a class="el" href="classsouffle_1_1_type_environment.html">TypeEnvironment</a> &amp;typeEnv, const bool isComputed, const bool isRecursive, const bool loadInputOnly)</td></tr>
<tr class="separator:ae9e37c3eb8d2931dbe421083736b6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c175d45710ac3262253fd971d4a2932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c175d45710ac3262253fd971d4a2932">createMagicIdentifier</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> relationName, size_t outputNumber)</td></tr>
<tr class="separator:a1c175d45710ac3262253fd971d4a2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328018b78e55eac5ab9bd242d6f35eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a328018b78e55eac5ab9bd242d6f35eac">createMagicRelation</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *original, <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> magicPredName)</td></tr>
<tr class="separator:a328018b78e55eac5ab9bd242d6f35eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ec79864680ea50d418a241b05b4a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a395ec79864680ea50d418a241b05b4a0">createNewRelation</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *original, <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> newName)</td></tr>
<tr class="separator:a395ec79864680ea50d418a241b05b4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e9f31e2107493d66acbbd3f3f94460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a39e9f31e2107493d66acbbd3f3f94460">createSubIdentifier</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> relationName, size_t start, size_t length)</td></tr>
<tr class="separator:a39e9f31e2107493d66acbbd3f3f94460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5">derefIter</a> (const Iter &amp;iter)</td></tr>
<tr class="memdesc:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function enabling the construction of a dereferencing iterator utilizing the automated deduction of template parameters.  <a href="#aeb411c7585f438a75ef3de5b6ae2abc5">More...</a><br/></td></tr>
<tr class="separator:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e10d44624c80609e5c09b131ecf3fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a72e10d44624c80609e5c09b131ecf3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style dirname.  <a href="#a72e10d44624c80609e5c09b131ecf3fb">More...</a><br/></td></tr>
<tr class="separator:a72e10d44624c80609e5c09b131ecf3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a93424fa42c59893383c23ecf475766"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5a93424fa42c59893383c23ecf475766">duration_in_ms</a> (const <a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a> &amp;start, const <a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a> &amp;end)</td></tr>
<tr class="separator:a5a93424fa42c59893383c23ecf475766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ba27d2caf5a777268d89eaf5cbfed2a">duration_in_ns</a> (const <a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a> &amp;start, const <a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a> &amp;end)</td></tr>
<tr class="separator:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84ddff3bc168499fa141d3a3998494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">endsWith</a> (const std::string &amp;value, const std::string &amp;ending)</td></tr>
<tr class="memdesc:a6e84ddff3bc168499fa141d3a3998494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value string ends with the given end string.  <a href="#a6e84ddff3bc168499fa141d3a3998494">More...</a><br/></td></tr>
<tr class="separator:a6e84ddff3bc168499fa141d3a3998494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1">equal</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</td></tr>
<tr class="memdesc:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vectors are equal (same vector of elements).  <a href="#ab0083e5ad86e88ff726ea4e3c7ef23c1">More...</a><br/></td></tr>
<tr class="separator:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</td></tr>
<tr class="memdesc:a71900d5ac92d70a4132fff4e280dd1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two sets are equal (same set of elements).  <a href="#a71900d5ac92d70a4132fff4e280dd1cd">More...</a><br/></td></tr>
<tr class="separator:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">equal_ptr</a> (const T *a, const T *b)</td></tr>
<tr class="memdesc:ab097fb451e787a08a185a449bacde2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="#ab097fb451e787a08a185a449bacde2db">More...</a><br/></td></tr>
<tr class="separator:ab097fb451e787a08a185a449bacde2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">equal_ptr</a> (const std::unique_ptr&lt; T &gt; &amp;a, const std::unique_ptr&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="#a9b13dfdf28e89958f7adeaa43abbe34f">More...</a><br/></td></tr>
<tr class="separator:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a961b0d79be71a35f0b60aeedf212fe4a">equal_targets</a> (const std::vector&lt; T * &gt; &amp;a, const std::vector&lt; T * &gt; &amp;b)</td></tr>
<tr class="memdesc:a961b0d79be71a35f0b60aeedf212fe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="#a961b0d79be71a35f0b60aeedf212fe4a">More...</a><br/></td></tr>
<tr class="separator:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae042a1a59dfe209421a92154e83b3145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae042a1a59dfe209421a92154e83b3145"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae042a1a59dfe209421a92154e83b3145">equal_targets</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;b)</td></tr>
<tr class="memdesc:ae042a1a59dfe209421a92154e83b3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="#ae042a1a59dfe209421a92154e83b3145">More...</a><br/></td></tr>
<tr class="separator:ae042a1a59dfe209421a92154e83b3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aef9c6f3c99122a5e04e14bd3d26f9e21">equal_targets</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;b)</td></tr>
<tr class="memdesc:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="#aef9c6f3c99122a5e04e14bd3d26f9e21">More...</a><br/></td></tr>
<tr class="separator:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e426c93033a166915ea2990c513a4fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e426c93033a166915ea2990c513a4fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e426c93033a166915ea2990c513a4fa">equal_targets</a> (const std::set&lt; T * &gt; &amp;a, const std::set&lt; T * &gt; &amp;b)</td></tr>
<tr class="memdesc:a6e426c93033a166915ea2990c513a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="#a6e426c93033a166915ea2990c513a4fa">More...</a><br/></td></tr>
<tr class="separator:a6e426c93033a166915ea2990c513a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a806a1898ee38dcc89c3a7d24a18e9fcb">equal_targets</a> (const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;b)</td></tr>
<tr class="memdesc:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="#a806a1898ee38dcc89c3a7d24a18e9fcb">More...</a><br/></td></tr>
<tr class="separator:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7fbdbf02eb7f38788faa2880c7f600d7">equal_targets</a> (const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;a, const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;b)</td></tr>
<tr class="memdesc:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="#a7fbdbf02eb7f38788faa2880c7f600d7">More...</a><br/></td></tr>
<tr class="separator:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752bf432062837ed19ae6ac73ab177c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">executeBinary</a> (const std::string &amp;binaryFilename)</td></tr>
<tr class="memdesc:a1752bf432062837ed19ae6ac73ab177c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a binary file.  <a href="#a1752bf432062837ed19ae6ac73ab177c">More...</a><br/></td></tr>
<tr class="separator:a1752bf432062837ed19ae6ac73ab177c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa4170c4094bc943de6fa5acb5796e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a79fa4170c4094bc943de6fa5acb5796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a directory exists in the file system.  <a href="#a79fa4170c4094bc943de6fa5acb5796e">More...</a><br/></td></tr>
<tr class="separator:a79fa4170c4094bc943de6fa5acb5796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69107e934a60222580ee8ba6882dc3d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a69107e934a60222580ee8ba6882dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file exists in the file system.  <a href="#a69107e934a60222580ee8ba6882dc3d3">More...</a><br/></td></tr>
<tr class="separator:a69107e934a60222580ee8ba6882dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783c22acbaa814d35b915fa6d09696d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a783c22acbaa814d35b915fa6d09696d8">explain</a> (<a class="el" href="classsouffle_1_1_souffle_program.html">SouffleProgram</a> &amp;prog, bool sld=true, bool ncurses=false)</td></tr>
<tr class="separator:a783c22acbaa814d35b915fa6d09696d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c36e5eb0fc8e43102b85fba043aa422"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c36e5eb0fc8e43102b85fba043aa422">extractAdornment</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> magicRelationName)</td></tr>
<tr class="separator:a3c36e5eb0fc8e43102b85fba043aa422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85db0960025701b3a8a8c6e592bbbef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a85db0960025701b3a8a8c6e592bbbef4">extractConstant</a> (<a class="el" href="classsouffle_1_1_symbol_table.html">SymbolTable</a> &amp;symbolTable, std::string normalisedConstant)</td></tr>
<tr class="separator:a85db0960025701b3a8a8c6e592bbbef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3419b4e4df09a580063d2f078a3774"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">fileExtension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8e3419b4e4df09a580063d2f078a3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">File extension, with all else removed.  <a href="#a8e3419b4e4df09a580063d2f078a3774">More...</a><br/></td></tr>
<tr class="separator:a8e3419b4e4df09a580063d2f078a3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2b4ce9b3036075ce407c2b524013a9"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4e2b4ce9b3036075ce407c2b524013a9">findInlineCycle</a> (const <a class="el" href="classsouffle_1_1_precedence_graph.html">PrecedenceGraph</a> &amp;precedenceGraph, <a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * &gt; &amp;origins, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *current, <a class="el" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">AstRelationSet</a> &amp;unvisited, <a class="el" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">AstRelationSet</a> &amp;visiting, <a class="el" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">AstRelationSet</a> &amp;visited)</td></tr>
<tr class="memdesc:a4e2b4ce9b3036075ce407c2b524013a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a cycle consisting entirely of inlined relations.  <a href="#a4e2b4ce9b3036075ce407c2b524013a9">More...</a><br/></td></tr>
<tr class="separator:a4e2b4ce9b3036075ce407c2b524013a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944f0c474df29e5c8e45e4b7df60be5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">findTool</a> (const std::string &amp;tool, const std::string &amp;base, const std::string &amp;path)</td></tr>
<tr class="separator:af944f0c474df29e5c8e45e4b7df60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">formNegatedLiterals</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom)</td></tr>
<tr class="memdesc:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the bodies that will replace the negation of a given inlined atom.  <a href="#a2e5ef82376f71d4d7ebfcfa64437d540">More...</a><br/></td></tr>
<tr class="separator:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a> (const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation referenced by the given atom.  <a href="#ab18cbb3adc2ab328de0db30a3fddf7e0">More...</a><br/></td></tr>
<tr class="separator:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864e03a1043eca84e933df62177c024b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a864e03a1043eca84e933df62177c024b">getBinaryOpForSymbol</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a864e03a1043eca84e933df62177c024b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts symbolic representation of an operator to the operator.  <a href="#a864e03a1043eca84e933df62177c024b">More...</a><br/></td></tr>
<tr class="separator:a864e03a1043eca84e933df62177c024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a4ed07c31abae549ab7461fb9b7ee"><td class="memItemLeft" align="right" valign="top">std::set&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a598a4ed07c31abae549ab7461fb9b7ee">getBodyRelations</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:a598a4ed07c31abae549ab7461fb9b7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations referenced in the body of the given clause.  <a href="#a598a4ed07c31abae549ab7461fb9b7ee">More...</a><br/></td></tr>
<tr class="separator:a598a4ed07c31abae549ab7461fb9b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b844f643767fd1388ff0a789bbea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> <br class="typebreak"/>
*, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a549b844f643767fd1388ff0a789bbea5">getConstTerms</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:a549b844f643767fd1388ff0a789bbea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyse the given clause and computes for each contained argument whether it is a constant value or not.  <a href="#a549b844f643767fd1388ff0a789bbea5">More...</a><br/></td></tr>
<tr class="separator:a549b844f643767fd1388ff0a789bbea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620dc7687473311acaa752a76b5c9470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">getEndpoint</a> (std::string mainName)</td></tr>
<tr class="separator:a620dc7687473311acaa752a76b5c9470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ac489d71276da23f5c2d5ba1c51ee"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a8c6ac489d71276da23f5c2d5ba1c51ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8c6ac489d71276da23f5c2d5ba1c51ee">getGreatestCommonSubtypes</a> (const Types &amp;...<a class="el" href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:a8c6ac489d71276da23f5c2d5ba1c51ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the given types.  <a href="#a8c6ac489d71276da23f5c2d5ba1c51ee">More...</a><br/></td></tr>
<tr class="separator:a8c6ac489d71276da23f5c2d5ba1c51ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb20659f25b4513908b813cfdbf43e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23">getGreatestCommonSubtypes</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;b)</td></tr>
<tr class="memdesc:abb20659f25b4513908b813cfdbf43e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the two given types.  <a href="#abb20659f25b4513908b813cfdbf43e23">More...</a><br/></td></tr>
<tr class="separator:abb20659f25b4513908b813cfdbf43e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c2a47b9395910d9fc183cf16ec0ed38">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;set)</td></tr>
<tr class="memdesc:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of all the types in the given set.  <a href="#a3c2a47b9395910d9fc183cf16ec0ed38">More...</a><br/></td></tr>
<tr class="separator:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ab68f123baedeb78d6c94920deb5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;a, const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;b)</td></tr>
<tr class="memdesc:aed5ab68f123baedeb78d6c94920deb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of pair-wise greatest common sub types of the types in the two given sets.  <a href="#aed5ab68f123baedeb78d6c94920deb5d">More...</a><br/></td></tr>
<tr class="separator:aed5ab68f123baedeb78d6c94920deb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247fd46943465169ffe79f25628e5dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> <br class="typebreak"/>
*, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:a247fd46943465169ffe79f25628e5dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyse the given clause and computes for each contained argument whether it is a grounded value or not.  <a href="#a247fd46943465169ffe79f25628e5dad">More...</a><br/></td></tr>
<tr class="separator:a247fd46943465169ffe79f25628e5dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5266d9360a88847a65d1c581f778d89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae5266d9360a88847a65d1c581f778d89">getHeadRelation</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:ae5266d9360a88847a65d1c581f778d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation referenced by the head of the given clause.  <a href="#ae5266d9360a88847a65d1c581f778d89">More...</a><br/></td></tr>
<tr class="separator:ae5266d9360a88847a65d1c581f778d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddc699418d426e1ffcb965e37ccb3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="memdesc:aeddc699418d426e1ffcb965e37ccb3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of arguments that should replace the given argument after one step of inlining.  <a href="#aeddc699418d426e1ffcb965e37ccb3a2">More...</a><br/></td></tr>
<tr class="separator:aeddc699418d426e1ffcb965e37ccb3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> &amp;atom)</td></tr>
<tr class="memdesc:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of atoms that should replace the given atom after one step of inlining.  <a href="#a8ae2dc0fd43bd8abb26027c3f2f448d1">More...</a><br/></td></tr>
<tr class="separator:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4639aeb42a36253468c45df580e18bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac4639aeb42a36253468c45df580e18bf">getInlinedClause</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:ac4639aeb42a36253468c45df580e18bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of clauses that should replace the given clause after one step of inlining.  <a href="#ac4639aeb42a36253468c45df580e18bf">More...</a><br/></td></tr>
<tr class="separator:ac4639aeb42a36253468c45df580e18bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b07f1c5efea50145140a31f755e0d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="memdesc:a25b07f1c5efea50145140a31f755e0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to perform a single step of inlining on the given literal.  <a href="#a25b07f1c5efea50145140a31f755e0d1">More...</a><br/></td></tr>
<tr class="separator:a25b07f1c5efea50145140a31f755e0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814a3034094392e5744454c68463cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_souffle_program.html">souffle::SouffleProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7814a3034094392e5744454c68463cc5">getInstance</a> (const char *<a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="separator:a7814a3034094392e5744454c68463cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf">getLeastCommonSupertypes</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;b)</td></tr>
<tr class="memdesc:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of the two given types.  <a href="#a8aecaefb22443dc01bb4c208cb6aabdf">More...</a><br/></td></tr>
<tr class="separator:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e40a76eef0a150ef9c20743b95f589e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3e40a76eef0a150ef9c20743b95f589e">getLeastCommonSupertypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;set)</td></tr>
<tr class="memdesc:a3e40a76eef0a150ef9c20743b95f589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of all the types in the given set.  <a href="#a3e40a76eef0a150ef9c20743b95f589e">More...</a><br/></td></tr>
<tr class="separator:a3e40a76eef0a150ef9c20743b95f589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7047c228f5d77f45d8f3954a6f1d2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:af8c7047c228f5d77f45d8f3954a6f1d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af8c7047c228f5d77f45d8f3954a6f1d2">getLeastCommonSupertypes</a> (const Types &amp;...<a class="el" href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:af8c7047c228f5d77f45d8f3954a6f1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of the given types.  <a href="#af8c7047c228f5d77f45d8f3954a6f1d2">More...</a><br/></td></tr>
<tr class="separator:af8c7047c228f5d77f45d8f3954a6f1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;a, const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;b)</td></tr>
<tr class="memdesc:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of pair-wise least common super types of the types in the two given sets.  <a href="#a8e5fe6f4fe0781dfc619f8640a1631d3">More...</a><br/></td></tr>
<tr class="separator:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf345b78b314c825a08367912ee42a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8daf345b78b314c825a08367912ee42a">getNextAtomMaxBoundSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt; &amp;atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a8daf345b78b314c825a08367912ee42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815de54b0cfc5cc21aa5bd963bbb8c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a815de54b0cfc5cc21aa5bd963bbb8c81">getNextAtomMaxRatioSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt; &amp;atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a815de54b0cfc5cc21aa5bd963bbb8c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1db2a9f27816ff9604d3c219f49739"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b1db2a9f27816ff9604d3c219f49739">getNextAtomNaiveSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt; atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a9b1db2a9f27816ff9604d3c219f49739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab559af8bc13b344074099f3b7e44e037"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab559af8bc13b344074099f3b7e44e037">getNextAtomSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt; &amp;atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &gt; edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:ab559af8bc13b344074099f3b7e44e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb526d569fc848583a59613102f660d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">getNextEdbName</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:aeb526d569fc848583a59613102f660d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2b075e7c326a8d80aad98075df04cc"><td class="memTemplParams" colspan="2">template&lt;typename TupleType &gt; </td></tr>
<tr class="memitem:acf2b075e7c326a8d80aad98075df04cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acf2b075e7c326a8d80aad98075df04cc">getNull</a> ()</td></tr>
<tr class="memdesc:acf2b075e7c326a8d80aad98075df04cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the null-reference constant.  <a href="#acf2b075e7c326a8d80aad98075df04cc">More...</a><br/></td></tr>
<tr class="separator:acf2b075e7c326a8d80aad98075df04cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_lock.html">Lock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1f3d2bbfbcd58c76463920d43a29b3d0">getOutputLock</a> ()</td></tr>
<tr class="memdesc:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to the lock synchronizing output operations.  <a href="#a1f3d2bbfbcd58c76463920d43a29b3d0">More...</a><br/></td></tr>
<tr class="separator:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526256b2f4d593cceb8b73068e7de882"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="separator:a526256b2f4d593cceb8b73068e7de882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d50b4a86610a92376e2b1b02767551"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a52d50b4a86610a92376e2b1b02767551">getSymbolForBinaryOp</a> (<a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> op)</td></tr>
<tr class="memdesc:a52d50b4a86610a92376e2b1b02767551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts operator to its symbolic representation.  <a href="#a52d50b4a86610a92376e2b1b02767551">More...</a><br/></td></tr>
<tr class="separator:a52d50b4a86610a92376e2b1b02767551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41c6466a40db79b6bc06560990cc831"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac41c6466a40db79b6bc06560990cc831">getSymbolForTernaryOp</a> (<a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> op)</td></tr>
<tr class="memdesc:ac41c6466a40db79b6bc06560990cc831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts operator to its symbolic representation.  <a href="#ac41c6466a40db79b6bc06560990cc831">More...</a><br/></td></tr>
<tr class="separator:ac41c6466a40db79b6bc06560990cc831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fbfcfce875a96761b9d77f91cd8fcd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a41fbfcfce875a96761b9d77f91cd8fcd">getSymbolForUnaryOp</a> (<a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> op)</td></tr>
<tr class="memdesc:a41fbfcfce875a96761b9d77f91cd8fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding symbol for the given relational operator.  <a href="#a41fbfcfce875a96761b9d77f91cd8fcd">More...</a><br/></td></tr>
<tr class="separator:a41fbfcfce875a96761b9d77f91cd8fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413b3992188dfdda83798af7d3f2a40b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a413b3992188dfdda83798af7d3f2a40b">getTernaryOpForSymbol</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a413b3992188dfdda83798af7d3f2a40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts symbolic representation of an operator to the operator.  <a href="#a413b3992188dfdda83798af7d3f2a40b">More...</a><br/></td></tr>
<tr class="separator:a413b3992188dfdda83798af7d3f2a40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6fe661fa54da7de4dccc65c8f82834"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0d6fe661fa54da7de4dccc65c8f82834">getTypeQualifier</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a0d6fe661fa54da7de4dccc65c8f82834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full type qualifier for a given type.  <a href="#a0d6fe661fa54da7de4dccc65c8f82834">More...</a><br/></td></tr>
<tr class="separator:a0d6fe661fa54da7de4dccc65c8f82834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e8675087d5d70a57bfde8ef0ba5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a591e8675087d5d70a57bfde8ef0ba5c7">getUnaryOpForSymbol</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a591e8675087d5d70a57bfde8ef0ba5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding operator for the given symbol.  <a href="#a591e8675087d5d70a57bfde8ef0ba5c7">More...</a><br/></td></tr>
<tr class="separator:a591e8675087d5d70a57bfde8ef0ba5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd078c141c96076832b98038f39e4d48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acd078c141c96076832b98038f39e4d48">getVariables</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root)</td></tr>
<tr class="memdesc:acd078c141c96076832b98038f39e4d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a list of all variables referenced within the AST rooted by the given root node.  <a href="#acd078c141c96076832b98038f39e4d48">More...</a><br/></td></tr>
<tr class="separator:acd078c141c96076832b98038f39e4d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195b2119af025c8ca8df003bc7e417b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8195b2119af025c8ca8df003bc7e417b">getVariables</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> *root)</td></tr>
<tr class="memdesc:a8195b2119af025c8ca8df003bc7e417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a list of all variables referenced within the AST rooted by the given root node.  <a href="#a8195b2119af025c8ca8df003bc7e417b">More...</a><br/></td></tr>
<tr class="separator:a8195b2119af025c8ca8df003bc7e417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d33c614149ed8612b009d37b04ffa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab5d33c614149ed8612b009d37b04ffa0">hasBoundArgument</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, std::set&lt; std::string &gt; boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:ab5d33c614149ed8612b009d37b04ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae039656df27f6089ef34a0a4455dce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae039656df27f6089ef34a0a4455dce5">hasClauseWithAggregatedRelation</a> (const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *relation, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *aggRelation, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;foundLiteral)</td></tr>
<tr class="memdesc:aae039656df27f6089ef34a0a4455dce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given relation has any clauses which contain an aggregation over of a specific relation.  <a href="#aae039656df27f6089ef34a0a4455dce5">More...</a><br/></td></tr>
<tr class="separator:aae039656df27f6089ef34a0a4455dce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab93b9d78c10c77c6d4ab227d5f9b389a">hasClauseWithNegatedRelation</a> (const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *relation, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *negRelation, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;foundLiteral)</td></tr>
<tr class="memdesc:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given relation has any clauses which contain a negation of a specific relation.  <a href="#ab93b9d78c10c77c6d4ab227d5f9b389a">More...</a><br/></td></tr>
<tr class="separator:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfe9bc62b1157c810a572b6c1b310aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">hasPrefix</a> (std::string str, std::string prefix)</td></tr>
<tr class="separator:aacfe9bc62b1157c810a572b6c1b310aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c77d8cc2a9414cd6aeb5d02c74e162d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2c77d8cc2a9414cd6aeb5d02c74e162d">hasUnnamedVariable</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="separator:a2c77d8cc2a9414cd6aeb5d02c74e162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb328ce61aedddf363f53be8e445a8e0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a> (const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="separator:abb328ce61aedddf363f53be8e445a8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e8debde5608979e041dd30e044612a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">identifier</a> (std::string <a class="el" href="structsouffle_1_1id.html">id</a>)</td></tr>
<tr class="memdesc:ad0e8debde5608979e041dd30e044612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned.  <a href="#ad0e8debde5608979e041dd30e044612a">More...</a><br/></td></tr>
<tr class="separator:ad0e8debde5608979e041dd30e044612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb410bc1f341864368bc73608bae7d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d">identifierToString</a> (const <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a05eb410bc1f341864368bc73608bae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions.  <a href="#a05eb410bc1f341864368bc73608bae7d">More...</a><br/></td></tr>
<tr class="separator:a05eb410bc1f341864368bc73608bae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0dfc0a494a70a89da974a472e7b23f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a><br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt;, std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f">inlineBodyLiterals</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *atomInlineClause)</td></tr>
<tr class="memdesc:acd0dfc0a494a70a89da974a472e7b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines the given atom based on a given clause.  <a href="#acd0dfc0a494a70a89da974a472e7b23f">More...</a><br/></td></tr>
<tr class="separator:acd0dfc0a494a70a89da974a472e7b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490f3d9e6d010462a5fd470c081ca2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7490f3d9e6d010462a5fd470c081ca2b">isAggRel</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> rel)</td></tr>
<tr class="separator:a7490f3d9e6d010462a5fd470c081ca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8bfe9b5546db6b9c75d4c5b968d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a01f8bfe9b5546db6b9c75d4c5b968d74">isBindingConstraint</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *<a class="el" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *<a class="el" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>, std::set&lt; std::string &gt; boundArgs)</td></tr>
<tr class="separator:a01f8bfe9b5546db6b9c75d4c5b968d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726544578525e6c61dcef1cfc0d6f996"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">isBoundArgument</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg, std::set&lt; std::string &gt; boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a726544578525e6c61dcef1cfc0d6f996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b72db3f5e04e5478626accb015f740"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740">isBoundComposite</a> (const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> *compositeVariable, std::set&lt; std::string &gt; boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a71b72db3f5e04e5478626accb015f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d324369b5fc672d6cde86cb6c20e304"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &amp;argument)</td></tr>
<tr class="separator:a2d324369b5fc672d6cde86cb6c20e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0921564037c6405c66d8141871d9ea7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0921564037c6405c66d8141871d9ea7b">isEqualAdornment</a> (<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> pred1, std::string adorn1, <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> pred2, std::string adorn2)</td></tr>
<tr class="separator:a0921564037c6405c66d8141871d9ea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64753e143a37bb9414121fc75987cb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a64753e143a37bb9414121fc75987cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given file exists and it is an executable.  <a href="#a64753e143a37bb9414121fc75987cb14">More...</a><br/></td></tr>
<tr class="separator:a64753e143a37bb9414121fc75987cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f27920d30575842a1fdfd0d53f348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa91f27920d30575842a1fdfd0d53f348">isHintsProfilingEnabled</a> ()</td></tr>
<tr class="memdesc:aa91f27920d30575842a1fdfd0d53f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to determine whether hints-profiling is enabled or disabled;.  <a href="#aa91f27920d30575842a1fdfd0d53f348">More...</a><br/></td></tr>
<tr class="separator:aa91f27920d30575842a1fdfd0d53f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d62e96f3d7162806dc7d4d7798297a"><td class="memTemplParams" colspan="2">template&lt;typename TupleType &gt; </td></tr>
<tr class="memitem:a23d62e96f3d7162806dc7d4d7798297a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a23d62e96f3d7162806dc7d4d7798297a">isNull</a> (<a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> ref)</td></tr>
<tr class="memdesc:a23d62e96f3d7162806dc7d4d7798297a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given reference is the null reference encoding the absence of any nested record.  <a href="#a23d62e96f3d7162806dc7d4d7798297a">More...</a><br/></td></tr>
<tr class="separator:a23d62e96f3d7162806dc7d4d7798297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56909036ae0514924e306d0a1a180837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">isNumber</a> (const char *str)</td></tr>
<tr class="memdesc:a56909036ae0514924e306d0a1a180837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a string is a sequence of numbers.  <a href="#a56909036ae0514924e306d0a1a180837">More...</a><br/></td></tr>
<tr class="separator:a56909036ae0514924e306d0a1a180837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">isNumberType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a number type.  <a href="#a4e502e6abb9a3e9a8e4c1168dbf23743">More...</a><br/></td></tr>
<tr class="separator:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c863e60901e130475672aff3942ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:aae6c863e60901e130475672aff3942ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are number types.  <a href="#aae6c863e60901e130475672aff3942ac">More...</a><br/></td></tr>
<tr class="separator:aae6c863e60901e130475672aff3942ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb741155c2a50d6028ac5cfb1bb64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a90eb741155c2a50d6028ac5cfb1bb64f">isNumericBinaryConstraintOp</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:a90eb741155c2a50d6028ac5cfb1bb64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper Functions for Binary Functors.  <a href="#a90eb741155c2a50d6028ac5cfb1bb64f">More...</a><br/></td></tr>
<tr class="separator:a90eb741155c2a50d6028ac5cfb1bb64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecdc282acb8ee99226175690bf397d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5ecdc282acb8ee99226175690bf397d0">isNumericBinaryOp</a> (const <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> op)</td></tr>
<tr class="memdesc:a5ecdc282acb8ee99226175690bf397d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given operator has a numeric return value.  <a href="#a5ecdc282acb8ee99226175690bf397d0">More...</a><br/></td></tr>
<tr class="separator:a5ecdc282acb8ee99226175690bf397d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886a8cccceb06e389e680c9ecf584deb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a886a8cccceb06e389e680c9ecf584deb">isNumericTernaryOp</a> (const <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> op)</td></tr>
<tr class="memdesc:a886a8cccceb06e389e680c9ecf584deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given operator has a numeric return value.  <a href="#a886a8cccceb06e389e680c9ecf584deb">More...</a><br/></td></tr>
<tr class="separator:a886a8cccceb06e389e680c9ecf584deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd31efb9f808712dfee9a892ec1dc08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abd31efb9f808712dfee9a892ec1dc08e">isNumericUnaryOp</a> (const <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> op)</td></tr>
<tr class="memdesc:abd31efb9f808712dfee9a892ec1dc08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given operator has a numeric return value.  <a href="#abd31efb9f808712dfee9a892ec1dc08e">More...</a><br/></td></tr>
<tr class="separator:abd31efb9f808712dfee9a892ec1dc08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c8a82b8d9ed840b32e93186002d18c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">isRecordType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a34c8a82b8d9ed840b32e93186002d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a record type.  <a href="#a34c8a82b8d9ed840b32e93186002d18c">More...</a><br/></td></tr>
<tr class="separator:a34c8a82b8d9ed840b32e93186002d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">isRecordType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are record types.  <a href="#a790e39fcdcb0e62caaee56e0bf7d3b45">More...</a><br/></td></tr>
<tr class="separator:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c60fce08f12e1f11d9d342c17ce56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac79c60fce08f12e1f11d9d342c17ce56">isRecursiveType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:ac79c60fce08f12e1f11d9d342c17ce56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a recursive type.  <a href="#ac79c60fce08f12e1f11d9d342c17ce56">More...</a><br/></td></tr>
<tr class="separator:ac79c60fce08f12e1f11d9d342c17ce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;b)</td></tr>
<tr class="memdesc:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether type a is a subtype of type b.  <a href="#a8cc19c66d9d13ce64e65f14dcabb43b3">More...</a><br/></td></tr>
<tr class="separator:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c148b933873b05a8a7d79863d5f5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a08c148b933873b05a8a7d79863d5f5b1">isSymbolicBinaryConstraintOp</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:a08c148b933873b05a8a7d79863d5f5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether arguments of constraint are numeric.  <a href="#a08c148b933873b05a8a7d79863d5f5b1">More...</a><br/></td></tr>
<tr class="separator:a08c148b933873b05a8a7d79863d5f5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8ed81eb5556d66dba3cf285ecee213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aff8ed81eb5556d66dba3cf285ecee213">isSymbolicBinaryOp</a> (const <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> op)</td></tr>
<tr class="memdesc:aff8ed81eb5556d66dba3cf285ecee213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the operator has a symbolic return value.  <a href="#aff8ed81eb5556d66dba3cf285ecee213">More...</a><br/></td></tr>
<tr class="separator:aff8ed81eb5556d66dba3cf285ecee213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53727befba61d13b3545ef75df0963dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a53727befba61d13b3545ef75df0963dd">isSymbolicTernaryOp</a> (const <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> op)</td></tr>
<tr class="memdesc:a53727befba61d13b3545ef75df0963dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the operator has a symbolic return value.  <a href="#a53727befba61d13b3545ef75df0963dd">More...</a><br/></td></tr>
<tr class="separator:a53727befba61d13b3545ef75df0963dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4786045b9e6b3d5543115981971eb89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae4786045b9e6b3d5543115981971eb89">isSymbolicUnaryOp</a> (const <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> op)</td></tr>
<tr class="memdesc:ae4786045b9e6b3d5543115981971eb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given operator has a symbolic return value.  <a href="#ae4786045b9e6b3d5543115981971eb89">More...</a><br/></td></tr>
<tr class="separator:ae4786045b9e6b3d5543115981971eb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">isSymbolType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a symbol type.  <a href="#a11f6c352eec6bde7b5a0b143ffe64e3b">More...</a><br/></td></tr>
<tr class="separator:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are symbol types.  <a href="#ae9f1f97bcd38ff9cd112ade89e631b80">More...</a><br/></td></tr>
<tr class="separator:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d08224020b450cc75146bcec8a281bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7d08224020b450cc75146bcec8a281bb">isTransactionProfilingEnabled</a> ()</td></tr>
<tr class="memdesc:a7d08224020b450cc75146bcec8a281bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to determine whether transaction-profiling is enabled or disabled;.  <a href="#a7d08224020b450cc75146bcec8a281bb">More...</a><br/></td></tr>
<tr class="separator:a7d08224020b450cc75146bcec8a281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Printer &gt; </td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <br class="typebreak"/>
Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a> (const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;<a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="memdesc:abe4e3f19879707216a2758b03f4e2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="#abe4e3f19879707216a2758b03f4e2deb">More...</a><br/></td></tr>
<tr class="separator:abe4e3f19879707216a2758b03f4e2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <br class="typebreak"/>
<a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt; <a class="el" href="structsouffle_1_1id.html">id</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">join</a> (const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="#a2ff8ab73e5403aebf8bc9e0cd8a17655">More...</a><br/></td></tr>
<tr class="separator:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <br class="typebreak"/>
Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">join</a> (const Container &amp;c, const std::string &amp;sep, const Printer &amp;<a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="memdesc:af5411f3812147edc8be88140d80308bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="#af5411f3812147edc8be88140d80308bd">More...</a><br/></td></tr>
<tr class="separator:af5411f3812147edc8be88140d80308bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <br class="typebreak"/>
<a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt; <a class="el" href="structsouffle_1_1id.html">id</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a> (const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:af2f126a2c7d2ee710ec8600b2af64da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="#af2f126a2c7d2ee710ec8600b2af64da3">More...</a><br/></td></tr>
<tr class="separator:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052d35be8e032f425317fd1b6d7e487a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a052d35be8e032f425317fd1b6d7e487a">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a052d35be8e032f425317fd1b6d7e487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1range.html">range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a> (const Iter &amp;a, const Iter &amp;b)</td></tr>
<tr class="memdesc:acea8a37cc1681f657054f3b30af55003"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the construction of ranges without explicitly specifying the iterator type.  <a href="#acea8a37cc1681f657054f3b30af55003">More...</a><br/></td></tr>
<tr class="separator:acea8a37cc1681f657054f3b30af55003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b6018ec9bf0a9a3110c99b926b3044"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a38b6018ec9bf0a9a3110c99b926b3044">makeInfoRelation</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;originalClause, <a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="separator:a38b6018ec9bf0a9a3110c99b926b3044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d9fd18d29b2a9219b5a6f6a127d215"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a92d9fd18d29b2a9219b5a6f6a127d215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1_lambda_node_mapper.html">detail::LambdaNodeMapper</a>&lt; Lambda &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a92d9fd18d29b2a9219b5a6f6a127d215">makeLambdaMapper</a> (const Lambda &amp;lambda)</td></tr>
<tr class="memdesc:a92d9fd18d29b2a9219b5a6f6a127d215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node mapper based on a corresponding lambda expression.  <a href="#a92d9fd18d29b2a9219b5a6f6a127d215">More...</a><br/></td></tr>
<tr class="separator:a92d9fd18d29b2a9219b5a6f6a127d215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4358a62bfb6a4b5d92306499af4d0684"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a4358a62bfb6a4b5d92306499af4d0684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1_lambda_ram_node_mapper.html">detail::LambdaRamNodeMapper</a><br class="typebreak"/>
&lt; Lambda &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4358a62bfb6a4b5d92306499af4d0684">makeLambdaMapper</a> (const Lambda &amp;lambda)</td></tr>
<tr class="memdesc:a4358a62bfb6a4b5d92306499af4d0684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node mapper based on a corresponding lambda expression.  <a href="#a4358a62bfb6a4b5d92306499af4d0684">More...</a><br/></td></tr>
<tr class="separator:a4358a62bfb6a4b5d92306499af4d0684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c74ca7366692d06582c9431f4cff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa15c74ca7366692d06582c9431f4cff2">makeRelationName</a> (const <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &amp;orig, const std::string &amp;type, int num=-1)</td></tr>
<tr class="separator:aa15c74ca7366692d06582c9431f4cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a10b4d0d4c0df3b810331af0a4ec93d23">maxRetries</a> ()</td></tr>
<tr class="memdesc:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to set the maximum number of retries for a transaction if Intel RTM is enabled (default 15);.  <a href="#a10b4d0d4c0df3b810331af0a4ec93d23">More...</a><br/></td></tr>
<tr class="separator:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7603fe80c7e2681fa81a67870058f60c"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a7603fe80c7e2681fa81a67870058f60c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1member__fun.html">member_fun</a>&lt; C, R, Args...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7603fe80c7e2681fa81a67870058f60c">mfun</a> (C &amp;obj, R(C::*f)(Args...))</td></tr>
<tr class="memdesc:a7603fe80c7e2681fa81a67870058f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an object and matching member function pointer into a callable object.  <a href="#a7603fe80c7e2681fa81a67870058f60c">More...</a><br/></td></tr>
<tr class="separator:a7603fe80c7e2681fa81a67870058f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f038770077ca498a606a43458b26e6"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:ac2f038770077ca498a606a43458b26e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac2f038770077ca498a606a43458b26e6">movePtrVector</a> (std::vector&lt; std::unique_ptr&lt; X &gt;&gt; &amp;source, std::vector&lt; std::unique_ptr&lt; Y &gt;&gt; &amp;destination)</td></tr>
<tr class="memdesc:ac2f038770077ca498a606a43458b26e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function that moves a vector of unique pointers from a source to a destination.  <a href="#ac2f038770077ca498a606a43458b26e6">More...</a><br/></td></tr>
<tr class="separator:ac2f038770077ca498a606a43458b26e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb53246ca22f17f324a309dc63f2e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acbb53246ca22f17f324a309dc63f2e73">nameInlinedUnderscores</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program)</td></tr>
<tr class="memdesc:acbb53246ca22f17f324a309dc63f2e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all underscores in all atoms of inlined relations.  <a href="#acbb53246ca22f17f324a309dc63f2e73">More...</a><br/></td></tr>
<tr class="separator:acbb53246ca22f17f324a309dc63f2e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d520cf7b6c6ac6cf448e4be191efa06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06">negatedConstraintOp</a> (<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:a2d520cf7b6c6ac6cf448e4be191efa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operator Each opeprator requires a negated operator which is necessary for the expansion of complex rule bodies with disjunction and negation.  <a href="#a2d520cf7b6c6ac6cf448e4be191efa06">More...</a><br/></td></tr>
<tr class="separator:a2d520cf7b6c6ac6cf448e4be191efa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ca390c0235d50be215fdc25bb24e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a> (<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="memdesc:a72ca390c0235d50be215fdc25bb24e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negated version of a given literal.  <a href="#a72ca390c0235d50be215fdc25bb24e4d">More...</a><br/></td></tr>
<tr class="separator:a72ca390c0235d50be215fdc25bb24e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a525106d63dbdd220ee8ecc238f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50">nextSrcLoc</a> (<a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a> orig)</td></tr>
<tr class="separator:a816a525106d63dbdd220ee8ecc238f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">none_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>)</td></tr>
<tr class="memdesc:af4ec690ba482fd3a9692b5e31f6ad347"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="#af4ec690ba482fd3a9692b5e31f6ad347">More...</a><br/></td></tr>
<tr class="separator:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abc8556c87eabd8a087d1e0fb9f8b89b6">normaliseInlinedHeads</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program)</td></tr>
<tr class="memdesc:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace constants in the head of inlined clauses with (constrained) variables.  <a href="#abc8556c87eabd8a087d1e0fb9f8b89b6">More...</a><br/></td></tr>
<tr class="separator:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">now</a> ()</td></tr>
<tr class="separator:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa064251e4aba0690c02ca0150af4a177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa064251e4aba0690c02ca0150af4a177">operator+</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> &amp;<a class="el" href="structsouffle_1_1id.html">id</a>)</td></tr>
<tr class="memdesc:aa064251e4aba0690c02ca0150af4a177"><td class="mdescLeft">&#160;</td><td class="mdescRight">A overloaded operator to add a new prefix to a given relation identifier.  <a href="#aa064251e4aba0690c02ca0150af4a177">More...</a><br/></td></tr>
<tr class="separator:aa064251e4aba0690c02ca0150af4a177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3861fdaa4641b5bb820a8b4d3b447b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_type_identifier.html">AstTypeIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c3861fdaa4641b5bb820a8b4d3b447b">operator+</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classsouffle_1_1_ast_type_identifier.html">AstTypeIdentifier</a> &amp;<a class="el" href="structsouffle_1_1id.html">id</a>)</td></tr>
<tr class="memdesc:a3c3861fdaa4641b5bb820a8b4d3b447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A overloaded operator to add a new prefix to a given relation identifier.  <a href="#a3c3861fdaa4641b5bb820a8b4d3b447b">More...</a><br/></td></tr>
<tr class="separator:a3c3861fdaa4641b5bb820a8b4d3b447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf2396e4d4fb479990191006785299"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad8cf2396e4d4fb479990191006785299">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classsouffle_1_1_rule_body.html">RuleBody</a> &amp;body)</td></tr>
<tr class="separator:ad8cf2396e4d4fb479990191006785299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3194e440e935d0d6089f8fa6bf405086"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:a3194e440e935d0d6089f8fa6bf405086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">pack</a> (const Tuple &amp;<a class="el" href="classsouffle_1_1tuple.html">tuple</a>)</td></tr>
<tr class="memdesc:a3194e440e935d0d6089f8fa6bf405086"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function packing a tuple of the given arity into a reference.  <a href="#a3194e440e935d0d6089f8fa6bf405086">More...</a><br/></td></tr>
<tr class="separator:a3194e440e935d0d6089f8fa6bf405086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5da1088ffaa55d44c032cedaac4d9d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad5da1088ffaa55d44c032cedaac4d9d0">pack</a> (<a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> *<a class="el" href="classsouffle_1_1tuple.html">tuple</a>, int <a class="el" href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a>)</td></tr>
<tr class="memdesc:ad5da1088ffaa55d44c032cedaac4d9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function packing a tuple of the given arity into a reference.  <a href="#ad5da1088ffaa55d44c032cedaac4d9d0">More...</a><br/></td></tr>
<tr class="separator:ad5da1088ffaa55d44c032cedaac4d9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">pathJoin</a> (const std::string &amp;first, const std::string &amp;second)</td></tr>
<tr class="memdesc:a168e2fae5a34ddc5215c94d27893a7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two paths together; note that this does not resolve overlaps or relative paths.  <a href="#a168e2fae5a34ddc5215c94d27893a7ff">More...</a><br/></td></tr>
<tr class="separator:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9976cdaf1f15164ab4f40e8337e23fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9976cdaf1f15164ab4f40e8337e23fa2">printSizeStore</a> (std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt; &amp;current, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *rel, const <a class="el" href="classsouffle_1_1_type_environment.html">TypeEnvironment</a> &amp;typeEnv, const bool storeOutputOnly)</td></tr>
<tr class="separator:a9976cdaf1f15164ab4f40e8337e23fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f3e2bc00f4340336a0f9a9dc4e9955"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955">reduceSubstitution</a> (std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> * &gt;&gt; &amp;<a class="el" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>)</td></tr>
<tr class="memdesc:a08f3e2bc00f4340336a0f9a9dc4e9955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a vector of substitutions.  <a href="#a08f3e2bc00f4340336a0f9a9dc4e9955">More...</a><br/></td></tr>
<tr class="separator:a08f3e2bc00f4340336a0f9a9dc4e9955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af790a6a39a388c256d64af7140f3a961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">renameVariables</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="memdesc:af790a6a39a388c256d64af7140f3a961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all variables in a given argument uniquely.  <a href="#af790a6a39a388c256d64af7140f3a961">More...</a><br/></td></tr>
<tr class="separator:af790a6a39a388c256d64af7140f3a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6903b947a2473735a22a16f70664b91b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6903b947a2473735a22a16f70664b91b">reorderAdornment</a> (std::vector&lt; std::string &gt; adornment, std::vector&lt; unsigned int &gt; order)</td></tr>
<tr class="separator:a6903b947a2473735a22a16f70664b91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e6aa7bd85198221efb412ec7b898c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e8e6aa7bd85198221efb412ec7b898c">reorderOrdering</a> (std::vector&lt; unsigned int &gt; order)</td></tr>
<tr class="separator:a6e8e6aa7bd85198221efb412ec7b898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877abda5aeabc4122f3bce8d74247919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a877abda5aeabc4122f3bce8d74247919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9046441f0187dc187df0765a55b175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0f9046441f0187dc187df0765a55b175">separateDBs</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a0f9046441f0187dc187df0765a55b175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">simpleName</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name, with extension removed.  <a href="#ab31e06999eb72da2f6d9a85bdd3dda59">More...</a><br/></td></tr>
<tr class="separator:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f32090909fb88cd5af742382c7ddd2c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7f32090909fb88cd5af742382c7ddd2c">split</a> (std::string s, char delim, int <a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a>=-1)</td></tr>
<tr class="memdesc:a7f32090909fb88cd5af742382c7ddd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to split a string  <a href="#a7f32090909fb88cd5af742382c7ddd2c">More...</a><br/></td></tr>
<tr class="separator:a7f32090909fb88cd5af742382c7ddd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8bc2c34ae58f7434a556eeafdfedf"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#adbd8bc2c34ae58f7434a556eeafdfedf">split</a> (std::string str, char delimiter)</td></tr>
<tr class="separator:adbd8bc2c34ae58f7434a556eeafdfedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f428910159c119c1dcdcab76ab7dfa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">stringify</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a06f428910159c119c1dcdcab76ab7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify a string using escapes for newline, tab, double-quotes and semicolons.  <a href="#a06f428910159c119c1dcdcab76ab7dfa">More...</a><br/></td></tr>
<tr class="separator:a06f428910159c119c1dcdcab76ab7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f93cdf21f1a24b593da6691dc892828"><td class="memTemplParams" colspan="2">template&lt;typename Var &gt; </td></tr>
<tr class="memitem:a7f93cdf21f1a24b593da6691dc892828"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1_constraint.html">Constraint</a><br class="typebreak"/>
&lt; <a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a> (const <a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> &amp;a, const <a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> &amp;b, const std::string &amp;symbol=&quot;&quot;)</td></tr>
<tr class="memdesc:a7f93cdf21f1a24b593da6691dc892828"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="#a7f93cdf21f1a24b593da6691dc892828">More...</a><br/></td></tr>
<tr class="separator:a7f93cdf21f1a24b593da6691dc892828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bb15c1b54c1fb493463f09857778b"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </td></tr>
<tr class="memitem:a688bb15c1b54c1fb493463f09857778b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1_constraint.html">Constraint</a><br class="typebreak"/>
&lt; <a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a688bb15c1b54c1fb493463f09857778b">sub</a> (const Val &amp;a, const <a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> &amp;b, const std::string &amp;symbol=&quot;&quot;)</td></tr>
<tr class="memdesc:a688bb15c1b54c1fb493463f09857778b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="#a688bb15c1b54c1fb493463f09857778b">More...</a><br/></td></tr>
<tr class="separator:a688bb15c1b54c1fb493463f09857778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122cfa5acdee4846ecda0855f0beee4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a> ()</td></tr>
<tr class="memdesc:a2122cfa5acdee4846ecda0855f0beee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate temporary file.  <a href="#a2122cfa5acdee4846ecda0855f0beee4">More...</a><br/></td></tr>
<tr class="separator:a2122cfa5acdee4846ecda0855f0beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529b2e542971d474c9d97b1546001dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a529b2e542971d474c9d97b1546001dcf">ternaryOpAcceptsNumbers</a> (int arg, const <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> op)</td></tr>
<tr class="memdesc:a529b2e542971d474c9d97b1546001dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an argument has a number value.  <a href="#a529b2e542971d474c9d97b1546001dcf">More...</a><br/></td></tr>
<tr class="separator:a529b2e542971d474c9d97b1546001dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7778845f2059dbeb6e09b524cf45fca1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7778845f2059dbeb6e09b524cf45fca1">ternaryOpAcceptsSymbols</a> (int arg, const <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> op)</td></tr>
<tr class="memdesc:a7778845f2059dbeb6e09b524cf45fca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an argument has a symbolic value.  <a href="#a7778845f2059dbeb6e09b524cf45fca1">More...</a><br/></td></tr>
<tr class="separator:a7778845f2059dbeb6e09b524cf45fca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">detail::multiplying_printer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> (const T &amp;value, unsigned num)</td></tr>
<tr class="memdesc:a0fff2be077dd5d1105f3a6e718339f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility printing a given value multiple times.  <a href="#a0fff2be077dd5d1105f3a6e718339f2f">More...</a><br/></td></tr>
<tr class="separator:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d35fc5fbcf6970adb86505b9263da"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b5d35fc5fbcf6970adb86505b9263da">toBase64</a> (std::string <a class="el" href="_synthesiser_8cpp.html#afe4cb73cbba700a5928d19ceb4bd2322">data</a>)</td></tr>
<tr class="separator:a9b5d35fc5fbcf6970adb86505b9263da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e347aaf113d69fceb9d2eb6f8b052e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa5e347aaf113d69fceb9d2eb6f8b052e">toBddbddb</a> (std::ostream &amp;out, const <a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="memdesc:aa5e347aaf113d69fceb9d2eb6f8b052e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given souffle-datalog translation unit into bdddbddb input code and writes the result into the given output stream.  <a href="#aa5e347aaf113d69fceb9d2eb6f8b052e">More...</a><br/></td></tr>
<tr class="separator:aa5e347aaf113d69fceb9d2eb6f8b052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399105b8de1698758c5b18bc9efca9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a399105b8de1698758c5b18bc9efca9fa">toBinaryConstraintOp</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a399105b8de1698758c5b18bc9efca9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts symbolic representation of an operator to the operator.  <a href="#a399105b8de1698758c5b18bc9efca9fa">More...</a><br/></td></tr>
<tr class="separator:a399105b8de1698758c5b18bc9efca9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad7410af2a4ba80aecfefede16c6a77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abad7410af2a4ba80aecfefede16c6a77">toBinaryConstraintSymbol</a> (<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:abad7410af2a4ba80aecfefede16c6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts operator to its symbolic representation.  <a href="#abad7410af2a4ba80aecfefede16c6a77">More...</a><br/></td></tr>
<tr class="separator:abad7410af2a4ba80aecfefede16c6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157284692de2638d283c06b62135fe54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a157284692de2638d283c06b62135fe54"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a157284692de2638d283c06b62135fe54">toPtrSet</a> (const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a157284692de2638d283c06b62135fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set of pointers.  <a href="#a157284692de2638d283c06b62135fe54">More...</a><br/></td></tr>
<tr class="separator:a157284692de2638d283c06b62135fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9996cd50fb4bb795892186890469013b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9996cd50fb4bb795892186890469013b"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9996cd50fb4bb795892186890469013b">toPtrSet</a> (const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a9996cd50fb4bb795892186890469013b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set of pointers.  <a href="#a9996cd50fb4bb795892186890469013b">More...</a><br/></td></tr>
<tr class="separator:a9996cd50fb4bb795892186890469013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">toPtrVector</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ad62d4e824a9d74c7462da546a21780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="#ad62d4e824a9d74c7462da546a21780fe">More...</a><br/></td></tr>
<tr class="separator:ad62d4e824a9d74c7462da546a21780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe1e036ca35b6dceb0200ccbebc3dbf9">toPtrVector</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="#abe1e036ca35b6dceb0200ccbebc3dbf9">More...</a><br/></td></tr>
<tr class="separator:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafad5f52d5175fff02862fa747763645"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafad5f52d5175fff02862fa747763645"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aafad5f52d5175fff02862fa747763645">toSet</a> ()</td></tr>
<tr class="memdesc:aafad5f52d5175fff02862fa747763645"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set with a fixed set of elements within a single expression.  <a href="#aafad5f52d5175fff02862fa747763645">More...</a><br/></td></tr>
<tr class="separator:aafad5f52d5175fff02862fa747763645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa3e7ecbc7d7a65ac2de10c9f21543f15">toSet</a> (const T &amp;first, const R &amp;...rest)</td></tr>
<tr class="memdesc:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set with a fixed set of elements within a single expression.  <a href="#aa3e7ecbc7d7a65ac2de10c9f21543f15">More...</a><br/></td></tr>
<tr class="separator:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc08c83ad9634fc515b7aa094702949"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:aecc08c83ad9634fc515b7aa094702949"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting strings into strings (trivial case).  <a href="#aecc08c83ad9634fc515b7aa094702949">More...</a><br/></td></tr>
<tr class="separator:aecc08c83ad9634fc515b7aa094702949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; <a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt; T &gt;<br class="typebreak"/>
::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aac0f01b6b803d03b90d7f33df9351ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting arbitrary objects to strings by utilizing their print capability.  <a href="#aac0f01b6b803d03b90d7f33df9351ade">More...</a><br/></td></tr>
<tr class="separator:aac0f01b6b803d03b90d7f33df9351ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt; T &gt;<br class="typebreak"/>
::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6ae87378d37c861ccf867805d6b6ed4d">toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6ae87378d37c861ccf867805d6b6ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback for the to-string function in case an unprintable object is supposed to be printed.  <a href="#a6ae87378d37c861ccf867805d6b6ed4d">More...</a><br/></td></tr>
<tr class="separator:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">toVector</a> ()</td></tr>
<tr class="memdesc:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="#ab2822ded4e7fd1466479b3fd6a1345a0">More...</a><br/></td></tr>
<tr class="separator:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa8b505a63ac23af9d89fdcbbbba3ea8b">toVector</a> (const T &amp;first, const R &amp;...rest)</td></tr>
<tr class="memdesc:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="#aa8b505a63ac23af9d89fdcbbbba3ea8b">More...</a><br/></td></tr>
<tr class="separator:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d3f12f76a6b9df4ef6c65fdc18e39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a42d3f12f76a6b9df4ef6c65fdc18e39c">transformEqrelRelation</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a42d3f12f76a6b9df4ef6c65fdc18e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform eqrel relations to explicitly define equivalence relations.  <a href="#a42d3f12f76a6b9df4ef6c65fdc18e39c">More...</a><br/></td></tr>
<tr class="separator:a42d3f12f76a6b9df4ef6c65fdc18e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9af2eda2dd88cc60de32a89c4dc891c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac9af2eda2dd88cc60de32a89c4dc891c">unaryOpAcceptsNumbers</a> (const <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> op)</td></tr>
<tr class="memdesc:ac9af2eda2dd88cc60de32a89c4dc891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given operator takes a numeric argument.  <a href="#ac9af2eda2dd88cc60de32a89c4dc891c">More...</a><br/></td></tr>
<tr class="separator:ac9af2eda2dd88cc60de32a89c4dc891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3523c0cffbdbed0fabf4ad2f298f9c51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3523c0cffbdbed0fabf4ad2f298f9c51">unaryOpAcceptsSymbols</a> (const <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> op)</td></tr>
<tr class="memdesc:a3523c0cffbdbed0fabf4ad2f298f9c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given operator takes a symbolic argument.  <a href="#a3523c0cffbdbed0fabf4ad2f298f9c51">More...</a><br/></td></tr>
<tr class="separator:a3523c0cffbdbed0fabf4ad2f298f9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c00257a9f4ce44653d82cee9c563d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">unifyAtoms</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *first, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *second)</td></tr>
<tr class="memdesc:ab66c00257a9f4ce44653d82cee9c563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullable vector of substitutions needed to unify the two given atoms.  <a href="#ab66c00257a9f4ce44653d82cee9c563d">More...</a><br/></td></tr>
<tr class="separator:ab66c00257a9f4ce44653d82cee9c563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb9e5cd2a72ce6acebd8d3eb233a05d"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:aedb9e5cd2a72ce6acebd8d3eb233a05d"><td class="memTemplItemLeft" align="right" valign="top">const Tuple &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aedb9e5cd2a72ce6acebd8d3eb233a05d">unpack</a> (<a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> ref)</td></tr>
<tr class="memdesc:aedb9e5cd2a72ce6acebd8d3eb233a05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function obtaining a pointer to the tuple addressed by the given reference.  <a href="#aedb9e5cd2a72ce6acebd8d3eb233a05d">More...</a><br/></td></tr>
<tr class="separator:aedb9e5cd2a72ce6acebd8d3eb233a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb71fcacdd48ed600f623c3c3b135538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeb71fcacdd48ed600f623c3c3b135538">unpack</a> (<a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> ref, int <a class="el" href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a>)</td></tr>
<tr class="memdesc:aeb71fcacdd48ed600f623c3c3b135538"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function obtaining a pointer to the tuple addressed by the given reference.  <a href="#aeb71fcacdd48ed600f623c3c3b135538">More...</a><br/></td></tr>
<tr class="separator:aeb71fcacdd48ed600f623c3c3b135538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee69f1913bc5a4f49deeca2b10c8323b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aee69f1913bc5a4f49deeca2b10c8323b">updateQualifier</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *originalRelation, <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *newRelation)</td></tr>
<tr class="separator:aee69f1913bc5a4f49deeca2b10c8323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82791915ce06d393ddbb1865ae58b8b6"><td class="memItemLeft" align="right" valign="top">static const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a82791915ce06d393ddbb1865ae58b8b6">usesInvalidWitness</a> (const std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &amp;literals, const std::set&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &gt;&gt; &amp;groundedArguments)</td></tr>
<tr class="separator:a82791915ce06d393ddbb1865ae58b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e134334ce89f6ebc4075e1089b1f80d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a4e134334ce89f6ebc4075e1089b1f80d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:a4e134334ce89f6ebc4075e1089b1f80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#a4e134334ce89f6ebc4075e1089b1f80d">More...</a><br/></td></tr>
<tr class="separator:a4e134334ce89f6ebc4075e1089b1f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bfbc8a1f26432a267d67a7b37ab305"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a56bfbc8a1f26432a267d67a7b37ab305"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56bfbc8a1f26432a267d67a7b37ab305">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:a56bfbc8a1f26432a267d67a7b37ab305"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragments rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#a56bfbc8a1f26432a267d67a7b37ab305">More...</a><br/></td></tr>
<tr class="separator:a56bfbc8a1f26432a267d67a7b37ab305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aed08a0a4f3dee722039516cd22f4ae0b">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:aed08a0a4f3dee722039516cd22f4ae0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#aed08a0a4f3dee722039516cd22f4ae0b">More...</a><br/></td></tr>
<tr class="separator:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761efe11ed6dcdff18dce42b36bc9662"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a761efe11ed6dcdff18dce42b36bc9662"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a><br class="typebreak"/>
&lt; Lambda &gt;::value, void &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a761efe11ed6dcdff18dce42b36bc9662">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a761efe11ed6dcdff18dce42b36bc9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a761efe11ed6dcdff18dce42b36bc9662">More...</a><br/></td></tr>
<tr class="separator:a761efe11ed6dcdff18dce42b36bc9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefd41fae2027ed1ab90fa721dc8ca6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Lambda &gt; </td></tr>
<tr class="memitem:afefd41fae2027ed1ab90fa721dc8ca6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afefd41fae2027ed1ab90fa721dc8ca6f">visitDepthFirst</a> (const std::vector&lt; T * &gt; &amp;list, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:afefd41fae2027ed1ab90fa721dc8ca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#afefd41fae2027ed1ab90fa721dc8ca6f">More...</a><br/></td></tr>
<tr class="separator:afefd41fae2027ed1ab90fa721dc8ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b482457e03d290adeaf963dabd078"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Lambda &gt; </td></tr>
<tr class="memitem:a8e6b482457e03d290adeaf963dabd078"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a8e6b482457e03d290adeaf963dabd078"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a8e6b482457e03d290adeaf963dabd078">More...</a><br/></td></tr>
<tr class="separator:a8e6b482457e03d290adeaf963dabd078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f56d579f447fc1976686014c8b6fed4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:a3f56d579f447fc1976686014c8b6fed4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3f56d579f447fc1976686014c8b6fed4">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:a3f56d579f447fc1976686014c8b6fed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a3f56d579f447fc1976686014c8b6fed4">More...</a><br/></td></tr>
<tr class="separator:a3f56d579f447fc1976686014c8b6fed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75835c6570547ab2d0c50376202dc7"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a5f75835c6570547ab2d0c50376202dc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ram__visitor.html">detail::is_ram_visitor</a><br class="typebreak"/>
&lt; Lambda &gt;::value, void &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a5f75835c6570547ab2d0c50376202dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a5f75835c6570547ab2d0c50376202dc7">More...</a><br/></td></tr>
<tr class="separator:a5f75835c6570547ab2d0c50376202dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bb9099f19c9e5dcf89e3822728496c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:ad9bb9099f19c9e5dcf89e3822728496c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad9bb9099f19c9e5dcf89e3822728496c">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:ad9bb9099f19c9e5dcf89e3822728496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node.  <a href="#ad9bb9099f19c9e5dcf89e3822728496c">More...</a><br/></td></tr>
<tr class="separator:ad9bb9099f19c9e5dcf89e3822728496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4935ab0f9f60f27e711e30ced44ed9"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a6c4935ab0f9f60f27e711e30ced44ed9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6c4935ab0f9f60f27e711e30ced44ed9">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:a6c4935ab0f9f60f27e711e30ced44ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node.  <a href="#a6c4935ab0f9f60f27e711e30ced44ed9">More...</a><br/></td></tr>
<tr class="separator:a6c4935ab0f9f60f27e711e30ced44ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8c81a4bc3ebe951bd58b9b323b451e3a">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node.  <a href="#a8c81a4bc3ebe951bd58b9b323b451e3a">More...</a><br/></td></tr>
<tr class="separator:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1033c68a525f042c980bc63e96363062"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a1033c68a525f042c980bc63e96363062"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a><br class="typebreak"/>
&lt; Lambda &gt;::value, void &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a1033c68a525f042c980bc63e96363062"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node.  <a href="#a1033c68a525f042c980bc63e96363062">More...</a><br/></td></tr>
<tr class="separator:a1033c68a525f042c980bc63e96363062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3213abfc9e18e34bb08056ec91f7b86"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:ae3213abfc9e18e34bb08056ec91f7b86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">visitDepthFirstPreOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:ae3213abfc9e18e34bb08056ec91f7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#ae3213abfc9e18e34bb08056ec91f7b86">More...</a><br/></td></tr>
<tr class="separator:ae3213abfc9e18e34bb08056ec91f7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3257231469cb9f1759b0a615c579dc"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:afe3257231469cb9f1759b0a615c579dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">visitDepthFirstPreOrder</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</td></tr>
<tr class="memdesc:afe3257231469cb9f1759b0a615c579dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#afe3257231469cb9f1759b0a615c579dc">More...</a><br/></td></tr>
<tr class="separator:afe3257231469cb9f1759b0a615c579dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9757564e85959db8b14a9be7d544e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">which</a> (const std::string &amp;<a class="el" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a6e9757564e85959db8b14a9be7d544e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of a which tool.  <a href="#a6e9757564e85959db8b14a9be7d544e1">More...</a><br/></td></tr>
<tr class="separator:a6e9757564e85959db8b14a9be7d544e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad8eee90b91127c302f9bdc1a2778101c"><td class="memItemLeft" align="right" valign="top">static constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad8eee90b91127c302f9bdc1a2778101c">BLOCKBITS</a> = 10u</td></tr>
<tr class="separator:ad8eee90b91127c302f9bdc1a2778101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b448fc0efb23fa5e14bc09cccba6a3"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a33b448fc0efb23fa5e14bc09cccba6a3">BLOCKSIZE</a> = (1u &lt;&lt; BLOCKBITS)</td></tr>
<tr class="separator:a33b448fc0efb23fa5e14bc09cccba6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fcff3b64ca9bdaadbe6a038ee2e4a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">QueryExecutionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad9fcff3b64ca9bdaadbe6a038ee2e4a5">DirectExecution</a></td></tr>
<tr class="memdesc:ad9fcff3b64ca9bdaadbe6a038ee2e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">With this strategy queries will be processed as they are stated by the user.  <a href="#ad9fcff3b64ca9bdaadbe6a038ee2e4a5">More...</a><br/></td></tr>
<tr class="separator:ad9fcff3b64ca9bdaadbe6a038ee2e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ebbb9279d847e1780c7423a4adf030"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#ac0f91401943febd1544ad82fd99bcb04">block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a10ebbb9279d847e1780c7423a4adf030">rank_mask</a> = (1ul &lt;&lt; split_size) - 1</td></tr>
<tr class="separator:a10ebbb9279d847e1780c7423a4adf030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807f7b8118a77f250c57d1c3a08905e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">QueryExecutionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae807f7b8118a77f250c57d1c3a08905e">ScheduledExecution</a></td></tr>
<tr class="memdesc:ae807f7b8118a77f250c57d1c3a08905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">With this strategy queries will be dynamically rescheduled before each execution.  <a href="#ae807f7b8118a77f250c57d1c3a08905e">More...</a><br/></td></tr>
<tr class="separator:ae807f7b8118a77f250c57d1c3a08905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cae1829154de74317f872045c811c2"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab6cae1829154de74317f872045c811c2">split_size</a> = 32u</td></tr>
<tr class="separator:ab6cae1829154de74317f872045c811c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a27e7ae3870a1911c9541de344a1f9f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="namespacesouffle.html#a27e7ae3870a1911c9541de344a1f9f56">souffle::AstDomain</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ast domain that contains ram domain </p>

<p>Definition at line <a class="el" href="_ast_types_8h_source.html#l00027">27</a> of file <a class="el" href="_ast_types_8h_source.html">AstTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a606048097fb760a78f4d0aad940468b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>*, <a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a>&gt; <a class="el" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">souffle::AstRelationSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_relation_8h_source.html#l00385">385</a> of file <a class="el" href="_ast_relation_8h_source.html">AstRelation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f91401943febd1544ad82fd99bcb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="namespacesouffle.html#ac0f91401943febd1544ad82fd99bcb04">souffle::block_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_block_list_8h_source.html#l00221">221</a> of file <a class="el" href="_block_list_8h_source.html">BlockList.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cd4b8e0036a730296e27f748f63f67b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="namespacesouffle.html#a4cd4b8e0036a730296e27f748f63f67b">souffle::Column</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type to reference indices. </p>

<p>Definition at line <a class="el" href="_interpreter_8h_source.html#l00636">636</a> of file <a class="el" href="_interpreter_8h_source.html">Interpreter.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae042659e2cf9240dc085d2d4da94a5f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacesouffle.html#ae042659e2cf9240dc085d2d4da94a5f8">souffle::parent_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_union_find_8h_source.html#l00057">57</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b2899eb6927d9ee92a3628e0c5f4fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;<a class="el" href="structsouffle_1_1_execution_summary.html">ExecutionSummary</a>(const <a class="el" href="classsouffle_1_1_ram_insert.html">RamInsert</a>&amp;, <a class="el" href="classsouffle_1_1_interpreter_environment.html">InterpreterEnvironment</a>&amp; env, std::ostream*)&gt; <a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">souffle::QueryExecutionStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the type of execution strategies for interpreter. </p>

<p>Definition at line <a class="el" href="_interpreter_8h_source.html#l00627">627</a> of file <a class="el" href="_interpreter_8h_source.html">Interpreter.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa54e5c2cf102680c9fec848f5ac6460c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">souffle::RamDomain</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ram_types_8h_source.html#l00037">37</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3c63236e23ffee74b1ec5b83cd735710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacesouffle.html#a3c63236e23ffee74b1ec5b83cd735710">souffle::rank_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_union_find_8h_source.html#l00056">56</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f11646bb70dcb25008f6ee0686731b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="namespacesouffle.html#ac5f11646bb70dcb25008f6ee0686731b">souffle::SearchColumns</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of an index key; each bit represents a column of a table </p>

<p>Definition at line <a class="el" href="_ram_types_8h_source.html#l00045">45</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ede47ca253693a0980e580612116d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::chrono::high_resolution_clock::time_point <a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">souffle::time_point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00908">908</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8cc1c1de7899ad2b9e82ddd25b4607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacesouffle.html#a2d8cc1c1de7899ad2b9e82ddd25b4607">souffle::yyscan_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_parser_driver_8h_source.html#l00033">33</a> of file <a class="el" href="_parser_driver_8h_source.html">ParserDriver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">souffle::BinaryConstraintOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065"></a>__UNDEFINED__</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47"></a>EQ</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0"></a>NE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b"></a>LT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6"></a>LE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020"></a>GT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9"></a>GE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a"></a>MATCH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b"></a>CONTAINS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01"></a>NOT_MATCH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0"></a>NOT_CONTAINS</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00030">30</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                              {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>,  <span class="comment">// undefined operator</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>,             <span class="comment">// equivalence of two values</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>,             <span class="comment">// whether two values are different</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>,             <span class="comment">// less-than</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>,             <span class="comment">// less-than-or-equal-to</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>,             <span class="comment">// greater-than</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>,             <span class="comment">// greater-than-or-equal-to</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>,          <span class="comment">// matching string</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>,       <span class="comment">// whether a sub-string is contained in a string</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>,      <span class="comment">// not matching string</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>    <span class="comment">// whether a sub-string is not contained in a string</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;};</div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">souffle::BinaryConstraintOp::NOT_MATCH</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">souffle::BinaryConstraintOp::LT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">souffle::BinaryConstraintOp::LE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">souffle::BinaryConstraintOp::EQ</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">souffle::BinaryConstraintOp::NE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">souffle::BinaryConstraintOp::GE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">souffle::BinaryConstraintOp::GT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">souffle::BinaryConstraintOp::__UNDEFINED__</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">souffle::BinaryConstraintOp::CONTAINS</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">souffle::BinaryConstraintOp::MATCH</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">souffle::BinaryConstraintOp::NOT_CONTAINS</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">souffle::BinaryOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary Functor Operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa8635afa1dc3f77400843ddfb2efa0065"></a>__UNDEFINED__</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d"></a>ADD</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb"></a>SUB</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c"></a>MUL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646"></a>DIV</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7"></a>EXP</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967"></a>MOD</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7"></a>BAND</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd"></a>BOR</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6"></a>BXOR</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06"></a>LAND</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229"></a>LOR</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5"></a>MAX</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653"></a>MIN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a"></a>CAT</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00026">26</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                    {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>,  <span class="comment">// undefined operator</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>,            <span class="comment">// addition</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">SUB</a>,            <span class="comment">// subtraction</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">MUL</a>,            <span class="comment">// multiplication</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">DIV</a>,            <span class="comment">// division</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>,            <span class="comment">// exponent</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">MOD</a>,            <span class="comment">// modulus</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>,           <span class="comment">// bitwise and</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BOR</a>,            <span class="comment">// bitwise or</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>,           <span class="comment">// bitwise exclusive or</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">LAND</a>,           <span class="comment">// logical and</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">LOR</a>,            <span class="comment">// logical or</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>,            <span class="comment">// max of two numbers</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>,            <span class="comment">// min of two numbers</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">CAT</a>,            <span class="comment">// string concatenation</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;};</div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">souffle::BinaryOp::BAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">souffle::BinaryOp::EXP</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">souffle::BinaryOp::MOD</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">souffle::BinaryOp::BXOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">souffle::BinaryOp::CAT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">souffle::BinaryOp::MIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">souffle::BinaryOp::ADD</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">souffle::BinaryOp::MAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">souffle::BinaryOp::MUL</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">souffle::BinaryConstraintOp::__UNDEFINED__</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">souffle::BinaryOp::LAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">souffle::BinaryOp::DIV</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">souffle::BinaryOp::BOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">souffle::BinaryOp::LOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">souffle::BinaryOp::SUB</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a98fb351bed657eebdba6e217946f77cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cd">souffle::RamNodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda0778d130de0aaec61561e2bfd82e14a3"></a>RN_Relation</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda7676f5ee911e97eaa58e1dcf84c32c5c"></a>RN_RelationRef</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda957b65c7967f8dadb2f1e100070d02df"></a>RN_ElementAccess</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdafeebf712c92e98e255744083fc88df1b"></a>RN_Number</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda389ad978a1adc590ed3a7443f3826ac9"></a>RN_UnaryOperator</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda34ac87bf1212175637e427b827b85ca5"></a>RN_BinaryOperator</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdaa3fc7b52063ef1026b3c795a7787ef11"></a>RN_TernaryOperator</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdae6c22967ac47af42e79bf8cf8a5d2ef9"></a>RN_AutoIncrement</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda2667a69690625f643f4ad6c428f4c4be"></a>RN_Pack</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda289f746e4098127d9dc2a3d49b315761"></a>RN_Argument</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda55f5f8caee82045f03ca2ce043ae93f5"></a>RN_NotExists</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdacfbf34fd69ecd7dc79b40e5aa69058f5"></a>RN_Empty</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda20544bc39b1abd7bfe3180a2d8c887ac"></a>RN_And</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda9668393eb539061dfcb6b301f3b1e7d4"></a>RN_BinaryRelation</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda352127eb5131d323d3bb3d549157edb4"></a>RN_Project</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda33b8d825c4720f99fd4c4d1938be4e20"></a>RN_Lookup</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda4f31ad94e70abc330cee3f5ecb4d0008"></a>RN_Scan</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda39013c5953058360c2fffb8b70197291"></a>RN_Aggregate</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda266d49c1ca2ce074aa65de75e544cba8"></a>RN_Create</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda3dfc8fce163f3e0262385800965f3081"></a>RN_Fact</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdabd1e6f0c2341158b454ac9e197b46dbf"></a>RN_Load</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdac4d422e3f522ddf50d903bc9d86d2bd6"></a>RN_Store</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda044cfc265a30e76bb4401ea8c2092735"></a>RN_Insert</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda45b6499758cdff1b1cd641e6f6b05da4"></a>RN_Clear</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda2016c7cf3de1cbccef18849129e96e5f"></a>RN_Drop</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda86ca15b0aa6e7e2ab4504f7154e32942"></a>RN_PrintSize</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda3ec2ab230c49b984f71f0723ccbd3cf4"></a>RN_LogSize</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdae1c7a265641a15d2af771d6e08ad1cb5"></a>RN_Return</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdac39e5c82dab9188688ad7393a0e44019"></a>RN_Merge</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda3cb4d51d4e612e8edfa924a0dc88fa29"></a>RN_Swap</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda7e273b6a1a729f8823655cde47774b16"></a>RN_Program</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda64eaad858fb336c50b53522c1f9b2b46"></a>RN_Sequence</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda96d010733e134d66f42cfa8ec2cb504d"></a>RN_Loop</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdac0f9284e34690db294d6347caf550da3"></a>RN_Parallel</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda689310ca05901bcb0ad45a4eaf09a022"></a>RN_Exit</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cdacfec87714070f1d244aaab8b106816e4"></a>RN_LogTimer</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a98fb351bed657eebdba6e217946f77cda96502ff75b085775222f85976474aa55"></a>RN_DebugInfo</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_ram_node_8h_source.html#l00028">28</a> of file <a class="el" href="_ram_node_8h_source.html">RamNode.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                 {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="comment">// relation</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda0778d130de0aaec61561e2bfd82e14a3">RN_Relation</a>,</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7676f5ee911e97eaa58e1dcf84c32c5c">RN_RelationRef</a>,</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// values</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda957b65c7967f8dadb2f1e100070d02df">RN_ElementAccess</a>,</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdafeebf712c92e98e255744083fc88df1b">RN_Number</a>,</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda389ad978a1adc590ed3a7443f3826ac9">RN_UnaryOperator</a>,</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda34ac87bf1212175637e427b827b85ca5">RN_BinaryOperator</a>,</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdaa3fc7b52063ef1026b3c795a7787ef11">RN_TernaryOperator</a>,</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae6c22967ac47af42e79bf8cf8a5d2ef9">RN_AutoIncrement</a>,</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2667a69690625f643f4ad6c428f4c4be">RN_Pack</a>,</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda289f746e4098127d9dc2a3d49b315761">RN_Argument</a>,</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="comment">// conditions</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda55f5f8caee82045f03ca2ce043ae93f5">RN_NotExists</a>,</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfbf34fd69ecd7dc79b40e5aa69058f5">RN_Empty</a>,</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda20544bc39b1abd7bfe3180a2d8c887ac">RN_And</a>,</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda9668393eb539061dfcb6b301f3b1e7d4">RN_BinaryRelation</a>,</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="comment">// operations</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda352127eb5131d323d3bb3d549157edb4">RN_Project</a>,</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda33b8d825c4720f99fd4c4d1938be4e20">RN_Lookup</a>,</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda4f31ad94e70abc330cee3f5ecb4d0008">RN_Scan</a>,</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda39013c5953058360c2fffb8b70197291">RN_Aggregate</a>,</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">// statements</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda266d49c1ca2ce074aa65de75e544cba8">RN_Create</a>,</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3dfc8fce163f3e0262385800965f3081">RN_Fact</a>,</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdabd1e6f0c2341158b454ac9e197b46dbf">RN_Load</a>,</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac4d422e3f522ddf50d903bc9d86d2bd6">RN_Store</a>,</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda044cfc265a30e76bb4401ea8c2092735">RN_Insert</a>,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda45b6499758cdff1b1cd641e6f6b05da4">RN_Clear</a>,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2016c7cf3de1cbccef18849129e96e5f">RN_Drop</a>,</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda86ca15b0aa6e7e2ab4504f7154e32942">RN_PrintSize</a>,</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3ec2ab230c49b984f71f0723ccbd3cf4">RN_LogSize</a>,</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae1c7a265641a15d2af771d6e08ad1cb5">RN_Return</a>,</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac39e5c82dab9188688ad7393a0e44019">RN_Merge</a>,</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3cb4d51d4e612e8edfa924a0dc88fa29">RN_Swap</a>,</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="comment">// control flow</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7e273b6a1a729f8823655cde47774b16">RN_Program</a>,</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda64eaad858fb336c50b53522c1f9b2b46">RN_Sequence</a>,</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96d010733e134d66f42cfa8ec2cb504d">RN_Loop</a>,</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac0f9284e34690db294d6347caf550da3">RN_Parallel</a>,</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda689310ca05901bcb0ad45a4eaf09a022">RN_Exit</a>,</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfec87714070f1d244aaab8b106816e4">RN_LogTimer</a>,</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <a class="code" href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96502ff75b085775222f85976474aa55">RN_DebugInfo</a></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;};</div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda45b6499758cdff1b1cd641e6f6b05da4"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda45b6499758cdff1b1cd641e6f6b05da4">souffle::RN_Clear</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00061">RamNode.h:61</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda9668393eb539061dfcb6b301f3b1e7d4"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda9668393eb539061dfcb6b301f3b1e7d4">souffle::RN_BinaryRelation</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00047">RamNode.h:47</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda4f31ad94e70abc330cee3f5ecb4d0008"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda4f31ad94e70abc330cee3f5ecb4d0008">souffle::RN_Scan</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00052">RamNode.h:52</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda3cb4d51d4e612e8edfa924a0dc88fa29"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3cb4d51d4e612e8edfa924a0dc88fa29">souffle::RN_Swap</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00068">RamNode.h:68</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdacfbf34fd69ecd7dc79b40e5aa69058f5"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfbf34fd69ecd7dc79b40e5aa69058f5">souffle::RN_Empty</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00045">RamNode.h:45</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdae6c22967ac47af42e79bf8cf8a5d2ef9"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae6c22967ac47af42e79bf8cf8a5d2ef9">souffle::RN_AutoIncrement</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00039">RamNode.h:39</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda34ac87bf1212175637e427b827b85ca5"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda34ac87bf1212175637e427b827b85ca5">souffle::RN_BinaryOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00037">RamNode.h:37</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda64eaad858fb336c50b53522c1f9b2b46"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda64eaad858fb336c50b53522c1f9b2b46">souffle::RN_Sequence</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00072">RamNode.h:72</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda7676f5ee911e97eaa58e1dcf84c32c5c"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7676f5ee911e97eaa58e1dcf84c32c5c">souffle::RN_RelationRef</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00031">RamNode.h:31</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda86ca15b0aa6e7e2ab4504f7154e32942"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda86ca15b0aa6e7e2ab4504f7154e32942">souffle::RN_PrintSize</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00063">RamNode.h:63</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda55f5f8caee82045f03ca2ce043ae93f5"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda55f5f8caee82045f03ca2ce043ae93f5">souffle::RN_NotExists</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00044">RamNode.h:44</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda96502ff75b085775222f85976474aa55"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96502ff75b085775222f85976474aa55">souffle::RN_DebugInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00077">RamNode.h:77</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda33b8d825c4720f99fd4c4d1938be4e20"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda33b8d825c4720f99fd4c4d1938be4e20">souffle::RN_Lookup</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00051">RamNode.h:51</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda0778d130de0aaec61561e2bfd82e14a3"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda0778d130de0aaec61561e2bfd82e14a3">souffle::RN_Relation</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00030">RamNode.h:30</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdacfec87714070f1d244aaab8b106816e4"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdacfec87714070f1d244aaab8b106816e4">souffle::RN_LogTimer</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00076">RamNode.h:76</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda689310ca05901bcb0ad45a4eaf09a022"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda689310ca05901bcb0ad45a4eaf09a022">souffle::RN_Exit</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00075">RamNode.h:75</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda20544bc39b1abd7bfe3180a2d8c887ac"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda20544bc39b1abd7bfe3180a2d8c887ac">souffle::RN_And</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00046">RamNode.h:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda7e273b6a1a729f8823655cde47774b16"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda7e273b6a1a729f8823655cde47774b16">souffle::RN_Program</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00071">RamNode.h:71</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda2016c7cf3de1cbccef18849129e96e5f"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2016c7cf3de1cbccef18849129e96e5f">souffle::RN_Drop</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00062">RamNode.h:62</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdac4d422e3f522ddf50d903bc9d86d2bd6"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac4d422e3f522ddf50d903bc9d86d2bd6">souffle::RN_Store</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00059">RamNode.h:59</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda389ad978a1adc590ed3a7443f3826ac9"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda389ad978a1adc590ed3a7443f3826ac9">souffle::RN_UnaryOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00036">RamNode.h:36</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdaa3fc7b52063ef1026b3c795a7787ef11"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdaa3fc7b52063ef1026b3c795a7787ef11">souffle::RN_TernaryOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00038">RamNode.h:38</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda289f746e4098127d9dc2a3d49b315761"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda289f746e4098127d9dc2a3d49b315761">souffle::RN_Argument</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00041">RamNode.h:41</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda266d49c1ca2ce074aa65de75e544cba8"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda266d49c1ca2ce074aa65de75e544cba8">souffle::RN_Create</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00056">RamNode.h:56</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda957b65c7967f8dadb2f1e100070d02df"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda957b65c7967f8dadb2f1e100070d02df">souffle::RN_ElementAccess</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00034">RamNode.h:34</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdac39e5c82dab9188688ad7393a0e44019"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac39e5c82dab9188688ad7393a0e44019">souffle::RN_Merge</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00067">RamNode.h:67</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdafeebf712c92e98e255744083fc88df1b"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdafeebf712c92e98e255744083fc88df1b">souffle::RN_Number</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00035">RamNode.h:35</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda96d010733e134d66f42cfa8ec2cb504d"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda96d010733e134d66f42cfa8ec2cb504d">souffle::RN_Loop</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00073">RamNode.h:73</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda352127eb5131d323d3bb3d549157edb4"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda352127eb5131d323d3bb3d549157edb4">souffle::RN_Project</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00050">RamNode.h:50</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdae1c7a265641a15d2af771d6e08ad1cb5"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdae1c7a265641a15d2af771d6e08ad1cb5">souffle::RN_Return</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00065">RamNode.h:65</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda2667a69690625f643f4ad6c428f4c4be"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda2667a69690625f643f4ad6c428f4c4be">souffle::RN_Pack</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00040">RamNode.h:40</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda3dfc8fce163f3e0262385800965f3081"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3dfc8fce163f3e0262385800965f3081">souffle::RN_Fact</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00057">RamNode.h:57</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda044cfc265a30e76bb4401ea8c2092735"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda044cfc265a30e76bb4401ea8c2092735">souffle::RN_Insert</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00060">RamNode.h:60</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdabd1e6f0c2341158b454ac9e197b46dbf"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdabd1e6f0c2341158b454ac9e197b46dbf">souffle::RN_Load</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00058">RamNode.h:58</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda3ec2ab230c49b984f71f0723ccbd3cf4"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda3ec2ab230c49b984f71f0723ccbd3cf4">souffle::RN_LogSize</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00064">RamNode.h:64</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cda39013c5953058360c2fffb8b70197291"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cda39013c5953058360c2fffb8b70197291">souffle::RN_Aggregate</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00053">RamNode.h:53</a></div></div>
<div class="ttc" id="namespacesouffle_html_a98fb351bed657eebdba6e217946f77cdac0f9284e34690db294d6347caf550da3"><div class="ttname"><a href="namespacesouffle.html#a98fb351bed657eebdba6e217946f77cdac0f9284e34690db294d6347caf550da3">souffle::RN_Parallel</a></div><div class="ttdef"><b>Definition:</b> <a href="_ram_node_8h_source.html#l00074">RamNode.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b421b00c7c5768cfaba47f3885e1c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">souffle::TernaryOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ternary Functor Operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5b421b00c7c5768cfaba47f3885e1c44a8635afa1dc3f77400843ddfb2efa0065"></a>__UNDEFINED__</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669"></a>SUBSTR</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00026">26</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                     {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>,  <span class="comment">// undefined operator</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>,         <span class="comment">// addition</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;};</div>
<div class="ttc" id="namespacesouffle_html_a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669"><div class="ttname"><a href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">souffle::TernaryOp::SUBSTR</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">souffle::BinaryConstraintOp::__UNDEFINED__</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">souffle::UnaryOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary Operators for functors and constraints. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a8635afa1dc3f77400843ddfb2efa0065"></a>__UNDEFINED__</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681"></a>ORD</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480"></a>STRLEN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e"></a>NEG</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb"></a>BNOT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0"></a>LNOT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1"></a>SIN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d"></a>COS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e"></a>TAN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff"></a>ASIN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd"></a>ACOS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be"></a>ATAN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69"></a>SINH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d"></a>COSH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1"></a>TANH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2"></a>ASINH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7"></a>ACOSH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21"></a>ATANH</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3"></a>LOG</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a717c9e8fd9648e0022b397a57191e4f4a8c670f8c37b95e1ed14a0ce414b049c7"></a>EXP</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00025">25</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                   {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>,</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">ORD</a>,     <span class="comment">// ordinal number of a string</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>,  <span class="comment">// length of a string</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>,     <span class="comment">// numeric negation</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>,    <span class="comment">// bitwise negation</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">LNOT</a>,    <span class="comment">// logical negation</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">SIN</a>,     <span class="comment">// mathematical sin</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">COS</a>,     <span class="comment">// mathematical cos</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">TAN</a>,     <span class="comment">// mathematical tan</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">ASIN</a>,    <span class="comment">// mathematical asin</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">ACOS</a>,    <span class="comment">// mathematical acos</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">ATAN</a>,    <span class="comment">// mathematical atan</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">SINH</a>,    <span class="comment">// mathematical sinh</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">COSH</a>,    <span class="comment">// mathematical cosh</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">TANH</a>,    <span class="comment">// mathematical tanh</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">ASINH</a>,   <span class="comment">// mathematical asinh</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">ACOSH</a>,   <span class="comment">// mathematical acosh</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">ATANH</a>,   <span class="comment">// mathematical atanh</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">LOG</a>,     <span class="comment">// mathematical natural logarithm</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>      <span class="comment">// mathematical natural exponent</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;};</div>
<div class="ttc" id="namespacesouffle_html_ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7"><div class="ttname"><a href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">souffle::BinaryOp::EXP</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">souffle::UnaryOp::COS</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">souffle::UnaryOp::BNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">souffle::UnaryOp::ORD</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">souffle::UnaryOp::COSH</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">souffle::UnaryOp::SINH</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">souffle::UnaryOp::ACOSH</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">souffle::UnaryOp::STRLEN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">souffle::UnaryOp::ATAN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">souffle::UnaryOp::TANH</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">souffle::UnaryOp::ACOS</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">souffle::UnaryOp::ASIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">souffle::UnaryOp::TAN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">souffle::UnaryOp::ASINH</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">souffle::UnaryOp::ATANH</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">souffle::BinaryConstraintOp::__UNDEFINED__</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">souffle::UnaryOp::SIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">souffle::UnaryOp::LNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">souffle::UnaryOp::NEG</a></div></div>
<div class="ttc" id="namespacesouffle_html_a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3"><div class="ttname"><a href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">souffle::UnaryOp::LOG</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8a2c294e3ff514cd4ca29b466ff3cab3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::absPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++-style realpath. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01009">1009</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;                                                {</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    <span class="keywordtype">char</span> buf[PATH_MAX];</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    <span class="keywordtype">char</span>* res = realpath(path.c_str(), buf);</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    <span class="keywordflow">return</span> (res == <span class="keyword">nullptr</span>) ? <span class="stringliteral">&quot;&quot;</span> : std::string(buf);</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03bcd21bf483197875a4221a669ba676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&gt; souffle::addAggregators </td>
          <td>(</td>
          <td class="paramtype">AstClause *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>ignoredNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00300">300</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                                                       {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    std::set&lt;AstRelationIdentifier&gt; retVal = ignoredNames;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAggregator&amp; aggregator) {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(aggregator, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { retVal.insert(atom.getName()); });</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    });</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a03bcd21bf483197875a4221a669ba676_cgraph.png" border="0" usemap="#namespacesouffle_a03bcd21bf483197875a4221a669ba676_cgraph" alt=""/></div>
<map name="namespacesouffle_a03bcd21bf483197875a4221a669ba676_cgraph" id="namespacesouffle_a03bcd21bf483197875a4221a669ba676_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="213,5,395,32"/><area shape="rect" id="node3" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="227,56,381,83"/><area shape="rect" id="node4" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="443,49,597,90"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="645,49,821,90"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ad864a641b2c6a407647cd6c60ef196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&gt; souffle::addBackwardDependencies </td>
          <td>(</td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00313">313</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00386">addIgnoredRelations()</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                                                                            {</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordtype">bool</span> relationsAdded = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    std::set&lt;AstRelationIdentifier&gt; result;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">for</span> (AstRelationIdentifier relName : <a class="code" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>) {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="comment">// Add the relation itself</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        result.insert(relName);</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    }</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="comment">// Add in all relations that need to use an ignored relation</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : rel-&gt;getClauses()) {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            AstRelationIdentifier clauseHeadName = clause-&gt;getHead()-&gt;getName();</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(relations, clauseHeadName)) {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                <span class="comment">// Clause hasn&#39;t been added yet, so check if it needs to be added</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; subatom) {</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    AstRelationIdentifier atomName = subatom.getName();</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(relations, atomName)) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                        <span class="comment">// Clause uses one of the given relations</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                        result.insert(clauseHeadName);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                        <span class="comment">// Clause name hasn&#39;t been seen yet, so fixed point not reached</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                        relationsAdded = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                });</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        }</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">if</span> (relationsAdded) {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="comment">// Keep going until we reach a fixed point</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196">addBackwardDependencies</a>(program, result);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;}</div>
<div class="ttc" id="_component_model_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_model_8cpp_source.html#l00084">ComponentModel.cpp:84</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0ad864a641b2c6a407647cd6c60ef196"><div class="ttname"><a href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196">souffle::addBackwardDependencies</a></div><div class="ttdeci">std::set&lt; AstRelationIdentifier &gt; addBackwardDependencies(const AstProgram *program, std::set&lt; AstRelationIdentifier &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00313">MagicSet.cpp:313</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0ad864a641b2c6a407647cd6c60ef196_cgraph.png" border="0" usemap="#namespacesouffle_a0ad864a641b2c6a407647cd6c60ef196_cgraph" alt=""/></div>
<map name="namespacesouffle_a0ad864a641b2c6a407647cd6c60ef196_cgraph" id="namespacesouffle_a0ad864a641b2c6a407647cd6c60ef196_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="317,5,435,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="285,56,467,83"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="307,107,445,149"/><area shape="rect" id="node5" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="299,173,453,200"/><area shape="rect" id="node6" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="515,166,669,207"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="717,166,893,207"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abfb26477b4d38c4b4e56f65b124eef3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&gt; souffle::addForwardDependencies </td>
          <td>(</td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00353">353</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_relation_8h_source.html#l00302">souffle::AstRelation::getClauses()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                                                                            {</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="keywordtype">bool</span> relationsAdded = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    std::set&lt;AstRelationIdentifier&gt; result;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordflow">for</span> (AstRelationIdentifier relName : <a class="code" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>) {</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        <span class="comment">// Add the relation itself</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        result.insert(relName);</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="comment">// Add in all the relations that it needs to use</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        AstRelation* associatedRelation = program-&gt;getRelation(relName);</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : associatedRelation-&gt;getClauses()) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;            <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; subatom) {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                AstRelationIdentifier atomName = subatom.getName();</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                result.insert(atomName);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(relations, atomName)) {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                    <span class="comment">// Hasn&#39;t been seen yet, so fixed point not reached</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                    relationsAdded = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                }</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            });</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        }</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    }</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">if</span> (relationsAdded) {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="comment">// Keep going until we reach a fixed point</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abfb26477b4d38c4b4e56f65b124eef3c">addForwardDependencies</a>(program, result);</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div>
<div class="ttc" id="_component_model_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_model_8cpp_source.html#l00084">ComponentModel.cpp:84</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
<div class="ttc" id="namespacesouffle_html_abfb26477b4d38c4b4e56f65b124eef3c"><div class="ttname"><a href="namespacesouffle.html#abfb26477b4d38c4b4e56f65b124eef3c">souffle::addForwardDependencies</a></div><div class="ttdeci">std::set&lt; AstRelationIdentifier &gt; addForwardDependencies(const AstProgram *program, std::set&lt; AstRelationIdentifier &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00353">MagicSet.cpp:353</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abfb26477b4d38c4b4e56f65b124eef3c_cgraph.png" border="0" usemap="#namespacesouffle_abfb26477b4d38c4b4e56f65b124eef3c_cgraph" alt=""/></div>
<map name="namespacesouffle_abfb26477b4d38c4b4e56f65b124eef3c_cgraph" id="namespacesouffle_abfb26477b4d38c4b4e56f65b124eef3c_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="306,5,425,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="297,57,434,98"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="275,123,456,149"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="296,174,435,215"/><area shape="rect" id="node7" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="288,240,443,267"/><area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="514,64,649,91"/><area shape="rect" id="node8" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="504,233,659,274"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="707,233,883,274"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a20da927281260d0ab8c38d2148108538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&gt; souffle::addIgnoredRelations </td>
          <td>(</td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00386">386</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00313">addBackwardDependencies()</a>, <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, <a class="el" href="_component_model_8cpp_source.html#l00084">relations</a>, and <a class="el" href="_explain_provenance_8h_source.html#l00031">split()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                                                            {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">// get a set of all relations specified by the option</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    std::set&lt;std::string&gt; specifiedRelations = <a class="code" href="namespacesouffle.html#adbd8bc2c34ae58f7434a556eeafdfedf">split</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;magic-transform&quot;</span>), <span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// if a star was used as a relation, then magic set will be performed for all nodes</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(specifiedRelations, <span class="stringliteral">&quot;*&quot;</span>)) {</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="comment">// find all specified relations</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    std::set&lt;AstRelationIdentifier&gt; targetRelations;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        std::string mainName = rel-&gt;getName().getNames()[0];</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(specifiedRelations, mainName)) {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            targetRelations.insert(rel-&gt;getName());</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">// add all backward-dependencies to the list of relations to transform;</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="comment">// if we want to magic transform &#39;a&#39;, then we also have to magic transform</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="comment">// every relation that (directly or indirectly) uses &#39;a&#39; in its clauses</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    targetRelations = <a class="code" href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196">addBackwardDependencies</a>(program, targetRelations);</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="comment">// ignore all relations not specified by the option</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    std::set&lt;AstRelationIdentifier&gt; retVal(<a class="code" href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>);</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(targetRelations, rel-&gt;getName())) {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;            retVal.insert(rel-&gt;getName());</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        }</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_adbd8bc2c34ae58f7434a556eeafdfedf"><div class="ttname"><a href="namespacesouffle.html#adbd8bc2c34ae58f7434a556eeafdfedf">souffle::split</a></div><div class="ttdeci">std::set&lt; std::string &gt; split(std::string str, char delimiter)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00048">MagicSet.cpp:48</a></div></div>
<div class="ttc" id="_component_model_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_model_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_model_8cpp_source.html#l00084">ComponentModel.cpp:84</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0ad864a641b2c6a407647cd6c60ef196"><div class="ttname"><a href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196">souffle::addBackwardDependencies</a></div><div class="ttdeci">std::set&lt; AstRelationIdentifier &gt; addBackwardDependencies(const AstProgram *program, std::set&lt; AstRelationIdentifier &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00313">MagicSet.cpp:313</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a20da927281260d0ab8c38d2148108538_cgraph.png" border="0" usemap="#namespacesouffle_a20da927281260d0ab8c38d2148108538_cgraph" alt=""/></div>
<map name="namespacesouffle_a20da927281260d0ab8c38d2148108538_cgraph" id="namespacesouffle_a20da927281260d0ab8c38d2148108538_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0ad864a641b2c6a407647cd6c60ef196" title="souffle::addBackwardDependencies" alt="" coords="243,89,474,116"/><area shape="rect" id="node3" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="554,5,673,32"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="544,158,683,199"/><area shape="rect" id="node9" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="284,191,433,217"/><area shape="rect" id="node10" href="namespacesouffle.html#a7f32090909fb88cd5af742382c7ddd2c" title="utility function to split a string " alt="" coords="312,241,405,268"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="523,56,704,83"/><area shape="rect" id="node6" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="536,107,691,133"/><area shape="rect" id="node7" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="752,99,907,141"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="955,99,1131,141"/><area shape="rect" id="node11" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f" title="A utility printing a given value multiple times. " alt="" coords="563,241,664,268"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a14b5f9eb9ec09c40e558b242e75de872"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::all_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether all elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if for all elements x in c the predicate p(x) is true, false otherwise; for empty containers the result is always true </dd></dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00871">871</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_type_system_8cpp_source.html#l00399">areSubtypesOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00315">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00331">isRecordType()</a>, <a class="el" href="_type_system_8h_source.html#l00265">souffle::TypeSet::isSubsetOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00323">isSymbolType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                                                  {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">std::all_of</a>(c.begin(), c.end(), <a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00871">Util.h:871</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a34f8eecb81c090fca9e58d3357b63ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::any_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether any elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an element x in c such that predicate p(x) is true, false otherwise; for empty containers the result is always false </dd></dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00885">885</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_binary_relation_8h_source.html#l00736">souffle::BinaryRelation&lt; tuple_type &gt;::frontProduct()</a>, <a class="el" href="_type_system_8cpp_source.html#l00410">getLeastCommonSupertypes()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00321">hasUnnamedVariable()</a>, <a class="el" href="_type_system_8cpp_source.html#l00335">isRecursiveType()</a>, <a class="el" href="_binary_relation_8h_source.html#l00331">souffle::BinaryRelation&lt; TupleType &gt;::iterator::iterator()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00344">souffle::ResolveAliasesTransformer::removeComplexTermsInAtoms()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00431">souffle::AstTranslator::translateClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                                                  {</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">std::any_of</a>(c.begin(), c.end(), <a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00885">Util.h:885</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a532e17c4416fc5873367482f2e0623d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void souffle::appendStmt </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; RamStatement &gt; &amp;&#160;</td>
          <td class="paramname"><em>stmtList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; RamStatement &gt;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_translator_8cpp_source.html#l00821">821</a> of file <a class="el" href="_ast_translator_8cpp_source.html">AstTranslator.cpp</a>.</p>

<p>References <a class="el" href="_ram_statement_8h_source.html#l00496">souffle::RamSequence::add()</a>.</p>

<p>Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l01138">createAndLoad()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01171">printSizeStore()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00837">souffle::AstTranslator::translateNonRecursiveRelation()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01240">souffle::AstTranslator::translateProgram()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00942">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    <span class="keywordflow">if</span> (stmt) {</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        <span class="keywordflow">if</span> (stmtList) {</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;            RamSequence* stmtSeq;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;            <span class="keywordflow">if</span> ((stmtSeq = dynamic_cast&lt;RamSequence*&gt;(stmtList.get()))) {</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                stmtSeq-&gt;add(std::move(stmt));</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                stmtList = std::make_unique&lt;RamSequence&gt;(std::move(stmtList), std::move(stmt));</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            }</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;            stmtList = std::move(stmt);</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        }</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    }</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;};</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a532e17c4416fc5873367482f2e0623d9_cgraph.png" border="0" usemap="#namespacesouffle_a532e17c4416fc5873367482f2e0623d9_cgraph" alt=""/></div>
<map name="namespacesouffle_a532e17c4416fc5873367482f2e0623d9_cgraph" id="namespacesouffle_a532e17c4416fc5873367482f2e0623d9_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ram_sequence.html#a0b409325b6311a7e7a19b1d84dae990f" title="Add new statement to the end of ordered list. " alt="" coords="192,5,376,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac810dd526309dc398254f53e18edf50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::areSubtypesOf </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all types in s are subtypes of type b. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00399">399</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00871">all_of()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00365">isSubtypeOf()</a>.</p>
<div class="fragment"><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                                                    {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, [&amp;](<span class="keyword">const</span> Type&amp; t) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(t, b); });</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00365">TypeSystem.cpp:365</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00871">Util.h:871</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph.png" border="0" usemap="#namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph" alt=""/></div>
<map name="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph" id="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="231,20,331,47"/><area shape="rect" id="node3" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="211,71,352,97"/><area shape="rect" id="node4" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="603,71,829,97"/><area shape="rect" id="node5" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="400,20,555,47"/><area shape="rect" id="node9" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="401,121,553,148"/><area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="631,5,801,46"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="877,63,1048,105"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1096,63,1267,105"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="631,122,801,163"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9fbc2262a6164b62766f6fcb67f12ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::baseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l01048">1048</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_src_location_8cpp_source.html#l00031">souffle::AstSrcLocation::extloc()</a>, <a class="el" href="main_8cpp_source.html#l00119">main()</a>, and <a class="el" href="_precedence_graph_8cpp_source.html#l00279">souffle::SCCGraph::printJson()</a>.</p>
<div class="fragment"><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                                                     {</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    <span class="keywordflow">if</span> (filename.empty()) {</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;    }</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    <span class="keywordtype">size_t</span> lastNotSlash = filename.find_last_not_of(<span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    <span class="keywordflow">if</span> (lastNotSlash == std::string::npos) {</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    }</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    <span class="keywordtype">size_t</span> lastSlashBeforeBasename = filename.find_last_of(<span class="charliteral">&#39;/&#39;</span>, lastNotSlash - 1);</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    <span class="keywordflow">if</span> (lastSlashBeforeBasename == std::string::npos) {</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;        lastSlashBeforeBasename = -1;</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    }</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    <span class="keywordflow">return</span> filename.substr(lastSlashBeforeBasename + 1, lastNotSlash - lastSlashBeforeBasename);</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6202e50cad5266ddb9a18f3788df4625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::binaryOpAcceptsNumbers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an argument has a number value. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00145">145</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, and <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">SUB</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00390">souffle::AstBinaryFunctor::acceptsNumbers()</a>, and <a class="el" href="_binary_functor_ops_8h_source.html#l00174">binaryOpAcceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                                                               {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    assert(arg &gt;= 0 &amp;&amp; arg &lt; 2 &amp;&amp; <span class="stringliteral">&quot;argument out of range&quot;</span>);</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">case</span> BinaryOp::ADD:</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">case</span> BinaryOp::SUB:</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MUL:</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">case</span> BinaryOp::DIV:</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">case</span> BinaryOp::EXP:</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BAND:</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BOR:</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BXOR:</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LAND:</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LOR:</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MOD:</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MAX:</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MIN:</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">case</span> BinaryOp::CAT:</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a29028449b83efcd97fc86857d35572c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::binaryOpAcceptsSymbols </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an argument has a symbolic value. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00174">174</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_binary_functor_ops_8h_source.html#l00145">binaryOpAcceptsNumbers()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00395">souffle::AstBinaryFunctor::acceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                                                               {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#a6202e50cad5266ddb9a18f3788df4625">binaryOpAcceptsNumbers</a>(arg, op);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a6202e50cad5266ddb9a18f3788df4625"><div class="ttname"><a href="namespacesouffle.html#a6202e50cad5266ddb9a18f3788df4625">souffle::binaryOpAcceptsNumbers</a></div><div class="ttdeci">bool binaryOpAcceptsNumbers(int arg, const BinaryOp op)</div><div class="ttdoc">Determines whether an argument has a number value. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_functor_ops_8h_source.html#l00145">BinaryFunctorOps.h:145</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a29028449b83efcd97fc86857d35572c0_cgraph.png" border="0" usemap="#namespacesouffle_a29028449b83efcd97fc86857d35572c0_cgraph" alt=""/></div>
<map name="namespacesouffle_a29028449b83efcd97fc86857d35572c0_cgraph" id="namespacesouffle_a29028449b83efcd97fc86857d35572c0_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6202e50cad5266ddb9a18f3788df4625" title="Determines whether an argument has a number value. " alt="" coords="225,5,394,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a90cc6d2beab208ecbf25ddabd458256e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::set&lt;std::string&gt; &gt; souffle::bindArguments </td>
          <td>(</td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>currAtom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00460">460</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00093">getString()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    std::set&lt;std::string&gt; newlyBoundArgs;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    std::string atomAdornment = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            atomAdornment += <span class="stringliteral">&quot;b&quot;</span>;  <span class="comment">// bound</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;            atomAdornment += <span class="stringliteral">&quot;f&quot;</span>;  <span class="comment">// free</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            std::string argName = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(arg);</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            newlyBoundArgs.insert(argName);  <span class="comment">// now bound</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        }</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    }</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// add newly bound arguments to the list of bound arguments</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">for</span> (std::string newArg : newlyBoundArgs) {</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        boundArgs.insert(newArg);</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    }</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">return</span> std::make_pair(atomAdornment, boundArgs);</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a526256b2f4d593cceb8b73068e7de882"><div class="ttname"><a href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">souffle::getString</a></div><div class="ttdeci">std::string getString(const AstArgument *arg)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00093">MagicSet.cpp:93</a></div></div>
<div class="ttc" id="namespacesouffle_html_a726544578525e6c61dcef1cfc0d6f996"><div class="ttname"><a href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00125">MagicSet.cpp:125</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph.png" border="0" usemap="#namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph" alt=""/></div>
<map name="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph" id="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="211,5,421,32"/><area shape="rect" id="node4" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882" title="souffle::getString" alt="" coords="255,56,377,83"/><area shape="rect" id="node5" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="230,107,402,133"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="491,5,626,32"/><area shape="rect" id="node6" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="497,56,621,83"/><area shape="rect" id="node7" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="469,161,648,188"/><area shape="rect" id="node9" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="737,103,855,129"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="728,154,864,195"/><area shape="rect" id="node10" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="707,219,885,261"/><area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="697,285,895,326"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5c6308ee8b92e79229e01daec1d68d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> souffle::bindComposites </td>
          <td>(</td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00610">610</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8h_source.html#l00138">souffle::BindingStore::addBinding()</a>, <a class="el" href="_ast_type_analysis_8cpp_source.html#l00064">constraints</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                                       {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        BindingStore&amp; compositeBindings;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        std::set&lt;AstConstraint*&gt;&amp; <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        <span class="keyword">mutable</span> <span class="keywordtype">int</span> changeCount;</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        M(BindingStore&amp; compositeBindings, std::set&lt;AstConstraint*&gt;&amp; <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>, <span class="keywordtype">int</span> changeCount)</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                : compositeBindings(compositeBindings), constraints(constraints), changeCount(changeCount) {}</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="keywordtype">int</span> getChangeCount()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            <span class="keywordflow">return</span> changeCount;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        }</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;            <span class="keywordflow">if</span> (AstFunctor* functor = dynamic_cast&lt;AstFunctor*&gt;(node.get())) {</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                <span class="comment">// functor found</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                changeCount++;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                <span class="comment">// create new variable name (with appropriate suffix)</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                std::stringstream newVariableName;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+functor&quot;</span> &lt;&lt; changeCount;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                <span class="comment">// add the binding to the BindingStore</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                compositeBindings.addBinding(newVariableName.str(), functor);</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                <span class="comment">// create new constraint (+functorX = original-functor)</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                <span class="keyword">auto</span> newVariable = std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>.insert(<span class="keyword">new</span> AstConstraint(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(newVariable-&gt;clone()),</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(functor-&gt;clone())));</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;                <span class="comment">// update functor to be the variable created</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                <span class="keywordflow">return</span> std::move(newVariable);</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AstRecordInit* record = dynamic_cast&lt;AstRecordInit*&gt;(node.get())) {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                <span class="comment">// record found</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                changeCount++;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                <span class="comment">// create new variable name (with appropriate suffix)</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                std::stringstream newVariableName;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+record&quot;</span> &lt;&lt; changeCount;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                <span class="comment">// add the binding to the BindingStore</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                compositeBindings.addBinding(newVariableName.str(), record);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                <span class="comment">// create new constraint (+recordX = original-record)</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                <span class="keyword">auto</span> newVariable = std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>.insert(<span class="keyword">new</span> AstConstraint(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(newVariable-&gt;clone()),</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(record-&gt;clone())));</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                <span class="comment">// update record to be the variable created</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                <span class="keywordflow">return</span> std::move(newVariable);</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            }</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        }</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    };</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    BindingStore compositeBindings;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="keywordtype">int</span> changeCount = 0;  <span class="comment">// number of functors/records seen so far</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    <span class="comment">// apply the change to all clauses in the program</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : rel-&gt;getClauses()) {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            std::set&lt;AstConstraint*&gt; <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            M update(compositeBindings, constraints, changeCount);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            clause-&gt;apply(update);</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;            changeCount = update.getChangeCount();</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            <span class="keywordflow">for</span> (AstConstraint* constraint : constraints) {</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                clause-&gt;addToBody(std::unique_ptr&lt;AstConstraint&gt;(constraint));</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            }</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        }</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    }</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <span class="keywordflow">return</span> compositeBindings;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
<div class="ttc" id="_ast_type_analysis_8cpp_html_a4551a78b0ee37ec3710ad8cda752cf2e"><div class="ttname"><a href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a></div><div class="ttdeci">Problem&lt; AnalysisVar &gt; constraints</div><div class="ttdoc">The list of constraints making underlying this analysis. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_type_analysis_8cpp_source.html#l00064">AstTypeAnalysis.cpp:64</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph.png" border="0" usemap="#namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph" alt=""/></div>
<map name="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph" id="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_binding_store.html#a9b0552957cd0b90fbcd6909cdc183657" title="souffle::BindingStore\l::addBinding" alt="" coords="217,63,359,105"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="219,129,357,170"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="413,5,558,46"/><area shape="rect" id="node4" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="408,71,563,97"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="417,122,553,163"/><area shape="rect" id="node5" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="611,63,765,105"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="813,63,989,105"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7bd6c596547a92b9afdb621eb8a89c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>* souffle::combineAggregators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AstAggregator * &gt;&#160;</td>
          <td class="paramname"><em>aggrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00452">452</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00426">renameVariables()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00170">rhs</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00474">getInlinedArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                                                                               {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="comment">// Due to variable scoping issues with aggregators, we rename all variables uniquely in the</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="comment">// added aggregator</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <a class="code" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">renameVariables</a>(aggrs[0]);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">if</span> (aggrs.size() == 1) {</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        <span class="keywordflow">return</span> aggrs[0];</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    }</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    AstArgument* <a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = <a class="code" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a>(std::vector&lt;AstAggregator*&gt;(aggrs.begin() + 1, aggrs.end()), fun);</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    AstArgument* result = <span class="keyword">new</span> AstBinaryFunctor(</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            fun, std::unique_ptr&lt;AstArgument&gt;(aggrs[0]), std::unique_ptr&lt;AstArgument&gt;(rhs));</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a7bd6c596547a92b9afdb621eb8a89c91"><div class="ttname"><a href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">souffle::combineAggregators</a></div><div class="ttdeci">AstArgument * combineAggregators(std::vector&lt; AstAggregator * &gt; aggrs, BinaryOp fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00452">InlineRelationsTransformer.cpp:452</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00170">AstTransforms.cpp:170</a></div></div>
<div class="ttc" id="namespacesouffle_html_af790a6a39a388c256d64af7140f3a961"><div class="ttname"><a href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">souffle::renameVariables</a></div><div class="ttdeci">void renameVariables(AstArgument *arg)</div><div class="ttdoc">Renames all variables in a given argument uniquely. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00426">InlineRelationsTransformer.cpp:426</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7bd6c596547a92b9afdb621eb8a89c91_cgraph.png" border="0" usemap="#namespacesouffle_a7bd6c596547a92b9afdb621eb8a89c91_cgraph" alt=""/></div>
<map name="namespacesouffle_a7bd6c596547a92b9afdb621eb8a89c91_cgraph" id="namespacesouffle_a7bd6c596547a92b9afdb621eb8a89c91_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="243,5,410,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="459,5,618,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a190c528007c7083a21c340006061986d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt; &gt; souffle::combineNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; AstLiteral * &gt;&gt;&#160;</td>
          <td class="paramname"><em>litGroups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negated version of a disjunction of conjunctions. </p>
<p>E.g. (a1(x) ^ a2(x) ^ ...) v (b1(x) ^ b2(x) ^ ...) &ndash;into-&gt; (!a1(x) ^ !b1(x)) v (!a2(x) ^ !b2(x)) v ... </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00321">321</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00301">negateLiteral()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00371">formNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                                                     {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; negation;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="comment">// Corner case: !() = ()</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">if</span> (litGroups.empty()) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordflow">return</span> negation;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    std::vector&lt;AstLiteral*&gt; litGroup = litGroups[0];</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">if</span> (litGroups.size() == 1) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="comment">// !(a1 ^ a2 ^ a3 ^ ...) --into-&gt; !a1 v !a2 v !a3 v ...</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; litGroup.size(); i++) {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            std::vector&lt;AstLiteral*&gt; newVec;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a>(litGroup[i]));</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            negation.push_back(newVec);</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">// Done!</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keywordflow">return</span> negation;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="comment">// Produce the negated versions of all disjunctions ignoring the first recursively</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; combinedRHS = <a class="code" href="namespacesouffle.html#a190c528007c7083a21c340006061986d">combineNegatedLiterals</a>(</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt;(litGroups.begin() + 1, litGroups.end()));</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="comment">// We now just need to add the negation of a single literal from the untouched LHS</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">// to every single conjunction on the RHS to finalise creating every possible combination</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordflow">for</span> (AstLiteral* lhsLit : litGroup) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; rhsVec : combinedRHS) {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            std::vector&lt;AstLiteral*&gt; newVec;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a>(lhsLit));</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : rhsVec) {</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                newVec.push_back(lit-&gt;clone());</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            negation.push_back(newVec);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        }</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">return</span> negation;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a190c528007c7083a21c340006061986d"><div class="ttname"><a href="namespacesouffle.html#a190c528007c7083a21c340006061986d">souffle::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; AstLiteral * &gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00321">InlineRelationsTransformer.cpp:321</a></div></div>
<div class="ttc" id="namespacesouffle_html_a72ca390c0235d50be215fdc25bb24e4d"><div class="ttname"><a href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">souffle::negateLiteral</a></div><div class="ttdeci">AstLiteral * negateLiteral(AstLiteral *lit)</div><div class="ttdoc">Returns the negated version of a given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00301">InlineRelationsTransformer.cpp:301</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a190c528007c7083a21c340006061986d_cgraph.png" border="0" usemap="#namespacesouffle_a190c528007c7083a21c340006061986d_cgraph" alt=""/></div>
<map name="namespacesouffle_a190c528007c7083a21c340006061986d_cgraph" id="namespacesouffle_a190c528007c7083a21c340006061986d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="265,85,407,112"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="457,5,634,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="466,56,625,83"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="471,107,620,149"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="471,225,620,266"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="689,5,868,32"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="685,56,872,83"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="704,107,853,149"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="685,173,872,200"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="704,225,853,266"/><area shape="rect" id="node12" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="683,291,875,317"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a97d640155c037c468924198354aae2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::compileToBinary </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>compileCmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles the given source file to a binary file. </p>

<p>Definition at line <a class="el" href="main_8cpp_source.html#l00098">98</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p>References <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                                                                            {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// set up number of threads</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keyword">auto</span> num_threads = std::stoi(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>));</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">if</span> (num_threads == 1) {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        compileCmd += <span class="stringliteral">&quot;-s &quot;</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">// add source code</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    compileCmd += sourceFilename;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">// separate souffle output from executable output</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;profile&quot;</span>)) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        std::cout.flush();</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="comment">// run executable</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span> (system(compileCmd.c_str()) != 0) {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;failed to compile C++ source &lt;&quot;</span> + sourceFilename + <span class="stringliteral">&quot;&gt;&quot;</span>);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    }</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph.png" border="0" usemap="#namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph" alt=""/></div>
<map name="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph" id="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="221,5,371,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6f53082a60ed5593022bde81dc619ac9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T &gt;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00032">32</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00313">addBackwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00353">addForwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00386">addIgnoredRelations()</a>, <a class="el" href="_interpreter_index_8h_source.html#l00063">souffle::InterpreterIndexOrder::append()</a>, <a class="el" href="_interpreter_index_8h_source.html#l00074">souffle::InterpreterIndexOrder::covers()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00527">getNextAtomMaxBoundSIPS()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00486">getNextAtomNaiveSIPS()</a>, <a class="el" href="_rule_scheduler_8h_source.html#l00167">souffle::scheduler::Atom::getVariables()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00100">isBoundComposite()</a>, <a class="el" href="_interpreter_index_8h_source.html#l00108">souffle::InterpreterIndexOrder::isCompatible()</a>, <a class="el" href="_ast_clause_8h_source.html#l00068">souffle::AstExecutionOrder::isComplete()</a>, <a class="el" href="_interpreter_index_8h_source.html#l00079">souffle::InterpreterIndexOrder::isComplete()</a>, <a class="el" href="_interpreter_8h_source.html#l00594">souffle::Order::isComplete()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>, <a class="el" href="_rule_scheduler_8h_source.html#l00242">souffle::scheduler::Problem&lt; CostModel &gt;::solve()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                        {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> (set.find(element) != set.end());</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b30ea606023779f6ede16f65cc52db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; AdornedPredicate &gt;&#160;</td>
          <td class="paramname"><em>adornedPredicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>atomName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>atomAdornment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00037">37</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00025">isEqualAdornment()</a>.</p>
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                                 {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">for</span> (AdornedPredicate seenPred : adornedPredicates) {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a0921564037c6405c66d8141871d9ea7b">isEqualAdornment</a>(seenPred.getName(), seenPred.getAdornment(), atomName, atomAdornment)) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        }</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a0921564037c6405c66d8141871d9ea7b"><div class="ttname"><a href="namespacesouffle.html#a0921564037c6405c66d8141871d9ea7b">souffle::isEqualAdornment</a></div><div class="ttdeci">bool isEqualAdornment(AstRelationIdentifier pred1, std::string adorn1, AstRelationIdentifier pred2, std::string adorn2)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00025">MagicSet.cpp:25</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a9b30ea606023779f6ede16f65cc52db3_cgraph.png" border="0" usemap="#namespacesouffle_a9b30ea606023779f6ede16f65cc52db3_cgraph" alt=""/></div>
<map name="namespacesouffle_a9b30ea606023779f6ede16f65cc52db3_cgraph" id="namespacesouffle_a9b30ea606023779f6ede16f65cc52db3_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0921564037c6405c66d8141871d9ea7b" title="souffle::isEqualAdornment" alt="" coords="174,5,349,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af3295dd83a588d612cf777e600beac4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename C::value_type &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility to check generically whether a given element is contained in a given container. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00111">111</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                                                                       {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">return</span> std::find(container.begin(), container.end(), element) != container.end();</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeeb4465d8c07d802fb161440e0399ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::containsAggregators </td>
          <td>(</td>
          <td class="paramtype">AstClause *&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00172">172</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                            {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="comment">// check for aggregators</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAggregator&amp; aggr) { found = <span class="keyword">true</span>; });</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="keywordflow">return</span> found;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph.png" border="0" usemap="#namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph" alt=""/></div>
<map name="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph" id="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="243,12,397,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="445,5,600,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="648,5,824,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af48d6e1a779132e5412105fc9cfb85ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::containsInlinedAtom </td>
          <td>(</td>
          <td class="paramtype">const AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstClause &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given clause contains an atom that should be inlined. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00133">133</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>, <a class="el" href="_ast_relation_8h_source.html#l00194">souffle::AstRelation::isInline()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00954">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                                                                             {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordtype">bool</span> foundInlinedAtom = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        AstRelation* rel = program.getRelation(atom.getName());</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;isInline()) {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            foundInlinedAtom = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    });</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="keywordflow">return</span> foundInlinedAtom;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph.png" border="0" usemap="#namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph" alt=""/></div>
<map name="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph" id="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="240,5,421,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="261,57,400,98"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_relation.html#a337a8e26fdf7e036a3be3b20b7f04880" title="Check whether relation is an inlined relation. " alt="" coords="262,122,399,163"/><area shape="rect" id="node5" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="253,188,408,215"/><area shape="rect" id="node6" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="469,181,624,222"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="672,181,848,222"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a96cc9786123f78bb67d7fc13d80b9639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>* souffle::convertTupleToNums </td>
          <td>(</td>
          <td class="paramtype">const tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to convert a tuple to a RamDomain pointer. </p>

<p>Definition at line <a class="el" href="_interpreter_interface_8h_source.html#l00031">31</a> of file <a class="el" href="_interpreter_interface_8h_source.html">InterpreterInterface.h</a>.</p>

<p>References <a class="el" href="_souffle_interface_8h_source.html#l00150">souffle::tuple::size()</a>.</p>

<p>Referenced by <a class="el" href="_interpreter_interface_8h_source.html#l00139">souffle::InterpreterRelInterface::contains()</a>, and <a class="el" href="_interpreter_interface_8h_source.html#l00134">souffle::InterpreterRelInterface::insert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                     {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>* newTuple = <span class="keyword">new</span> <a class="code" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a>[t.size()];</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; t.size(); i++) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        newTuple[i] = t[i];</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">return</span> newTuple;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aa54e5c2cf102680c9fec848f5ac6460c"><div class="ttname"><a href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">souffle::RamDomain</a></div><div class="ttdeci">int32_t RamDomain</div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00037">RamTypes.h:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a96cc9786123f78bb67d7fc13d80b9639_cgraph.png" border="0" usemap="#namespacesouffle_a96cc9786123f78bb67d7fc13d80b9639_cgraph" alt=""/></div>
<map name="namespacesouffle_a96cc9786123f78bb67d7fc13d80b9639_cgraph" id="namespacesouffle_a96cc9786123f78bb67d7fc13d80b9639_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1tuple.html#a7a2a91980e45540b7a3db630838373bc" title="return number of elements in the tuple " alt="" coords="249,5,378,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afc675200d6e76f86c35bd33e1db6712c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> souffle::createAdornedIdentifier </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>adornment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00261">261</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00057">souffle::AstRelationIdentifier::append()</a>, and <a class="el" href="_ast_relation_identifier_8h_source.html#l00067">souffle::AstRelationIdentifier::getNames()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                                                                                                       {</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getNames();</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="comment">// change the base name</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    std::stringstream newMainName;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="comment">// add a &#39;+&#39; to avoid name conflict</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    newMainName &lt;&lt; relationNames[0] &lt;&lt; <span class="stringliteral">&quot;+_&quot;</span> &lt;&lt; adornment;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    AstRelationIdentifier newRelationName(newMainName.str());</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="comment">// add in the other names</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; relationNames.size(); i++) {</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        newRelationName.append(relationNames[i]);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_afc675200d6e76f86c35bd33e1db6712c_cgraph.png" border="0" usemap="#namespacesouffle_afc675200d6e76f86c35bd33e1db6712c_cgraph" alt=""/></div>
<map name="namespacesouffle_afc675200d6e76f86c35bd33e1db6712c_cgraph" id="namespacesouffle_afc675200d6e76f86c35bd33e1db6712c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#a40b918b195df8c3eb223c068db7536fe" title="souffle::AstRelationIdentifier\l::append" alt="" coords="256,5,443,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="256,70,443,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae9e37c3eb8d2931dbe421083736b6098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::createAndLoad </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; RamStatement &gt; &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeEnvironment &amp;&#160;</td>
          <td class="paramname"><em>typeEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isComputed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isRecursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>loadInputOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_translator_8cpp_source.html#l01138">1138</a> of file <a class="el" href="_ast_translator_8cpp_source.html">AstTranslator.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00346">souffle::AstRelation::addIODirectives()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00821">appendStmt()</a>, <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>, <a class="el" href="_ast_relation_8h_source.html#l00119">souffle::AstRelation::getArity()</a>, <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::getName()</a>, <a class="el" href="_ast_relation_8h_source.html#l00149">souffle::AstRelation::isInput()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00144">souffle::AstRelation::isOutput()</a>.</p>

<p>Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l01240">souffle::AstTranslator::translateProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;                                  {</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> dir = Global::config().get((rel-&gt;isInput() &amp;&amp; isComputed) ? <span class="stringliteral">&quot;facts-dir&quot;</span> : <span class="stringliteral">&quot;output-dir&quot;</span>);</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> ext = (!rel-&gt;isOutput() || (rel-&gt;isInput() &amp;&amp; isComputed)) ? <span class="stringliteral">&quot;.facts&quot;</span> : <span class="stringliteral">&quot;.csv&quot;</span>;</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    AstRelation* mrel = <span class="keyword">const_cast&lt;</span>AstRelation*<span class="keyword">&gt;</span>(rel)-&gt;clone();</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    <span class="keywordflow">if</span> ((!rel-&gt;isInput() &amp;&amp; !loadInputOnly) ||</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;            (!isComputed &amp;&amp; !isRecursive &amp;&amp; !loadInputOnly &amp;&amp; rel-&gt;isInput())) {</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;        std::unique_ptr&lt;AstIODirective&gt; directive = std::make_unique&lt;AstIODirective&gt;();</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        directive-&gt;setAsInput();</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;        directive-&gt;addKVP(<span class="stringliteral">&quot;intermediate&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>);</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;        mrel-&gt;addIODirectives(std::move(directive));</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    }</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    std::unique_ptr&lt;RamRelation&gt; rrel = getRamRelation(</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;            mrel, &amp;typeEnv, getRelationName(mrel-&gt;getName()), mrel-&gt;getArity(), <span class="keyword">false</span>, dir, ext);</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    <span class="comment">// create and load the relation at the start</span></div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamCreate&gt;(std::unique_ptr&lt;RamRelation&gt;(rrel-&gt;clone())));</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    <span class="keywordflow">if</span> (rel-&gt;isInput() || !loadInputOnly) {</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;        <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamLoad&gt;(std::unique_ptr&lt;RamRelation&gt;(rrel-&gt;clone()),</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;                                    getInputIODirectives(mrel, dir, ext)));</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;    }</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    <span class="comment">// create delta and new relations for recursive relations at the start</span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;    <span class="keywordflow">if</span> (isRecursive) {</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;        <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamCreate&gt;(getRamRelation(rel, &amp;typeEnv,</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                                    <span class="stringliteral">&quot;delta_&quot;</span> + getRelationName(rel-&gt;getName()), rel-&gt;getArity(), <span class="keyword">true</span>)));</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;        <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamCreate&gt;(getRamRelation(rel, &amp;typeEnv,</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                                    <span class="stringliteral">&quot;new_&quot;</span> + getRelationName(rel-&gt;getName()), rel-&gt;getArity(), <span class="keyword">true</span>)));</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    }</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    <span class="keyword">delete</span> mrel;</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a532e17c4416fc5873367482f2e0623d9"><div class="ttname"><a href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">souffle::appendStmt</a></div><div class="ttdeci">static void appendStmt(std::unique_ptr&lt; RamStatement &gt; &amp;stmtList, std::unique_ptr&lt; RamStatement &gt; stmt)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00821">AstTranslator.cpp:821</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae9e37c3eb8d2931dbe421083736b6098_cgraph.png" border="0" usemap="#namespacesouffle_ae9e37c3eb8d2931dbe421083736b6098_cgraph" alt=""/></div>
<map name="namespacesouffle_ae9e37c3eb8d2931dbe421083736b6098_cgraph" id="namespacesouffle_ae9e37c3eb8d2931dbe421083736b6098_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#a6ab4f4409da3c84af64b4a08d26ccd21" title="souffle::AstRelation\l::addIODirectives" alt="" coords="217,5,354,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9" title="souffle::appendStmt" alt="" coords="216,71,355,97"/><area shape="rect" id="node5" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="211,121,360,148"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#a855b01ad5e4a0871ef6c6f6bb1e95d13" title="Return the arity of this relation. " alt="" coords="217,173,354,214"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#a6ae505289ecfc8e40c9f4e47689f5ee8" title="Return the name of the relation. " alt="" coords="217,238,354,279"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_relation.html#aa333dd84cbf78b723d3532baf2aaaaea" title="Check whether relation is an input relation. " alt="" coords="217,303,354,345"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_relation.html#ae8a38221aa94f0df83f602fd1d1d0eb8" title="Check whether relation is an output relation. " alt="" coords="217,369,354,410"/><area shape="rect" id="node4" href="classsouffle_1_1_ram_sequence.html#a0b409325b6311a7e7a19b1d84dae990f" title="Add new statement to the end of ordered list. " alt="" coords="408,71,592,97"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1c175d45710ac3262253fd971d4a2932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> souffle::createMagicIdentifier </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00243">243</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00057">souffle::AstRelationIdentifier::append()</a>, and <a class="el" href="_ast_relation_identifier_8h_source.html#l00067">souffle::AstRelationIdentifier::getNames()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getNames();</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="comment">// change the base name to magic-relation format</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    std::stringstream newMainName;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    newMainName &lt;&lt; <span class="stringliteral">&quot;+m&quot;</span> &lt;&lt; outputNumber &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; relationNames[0];  <span class="comment">// use &quot;+m&quot; to avoid conflicts</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    AstRelationIdentifier newRelationName(newMainName.str());</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">// copy over the other relation names</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; relationNames.size(); i++) {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        newRelationName.append(relationNames[i]);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1c175d45710ac3262253fd971d4a2932_cgraph.png" border="0" usemap="#namespacesouffle_a1c175d45710ac3262253fd971d4a2932_cgraph" alt=""/></div>
<map name="namespacesouffle_a1c175d45710ac3262253fd971d4a2932_cgraph" id="namespacesouffle_a1c175d45710ac3262253fd971d4a2932_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#a40b918b195df8c3eb223c068db7536fe" title="souffle::AstRelationIdentifier\l::append" alt="" coords="245,5,432,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="245,70,432,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a328018b78e55eac5ab9bd242d6f35eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>* souffle::createMagicRelation </td>
          <td>(</td>
          <td class="paramtype">AstRelation *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>magicPredName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l01007">1007</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00113">souffle::AstRelation::addAttribute()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00977">extractAdornment()</a>, <a class="el" href="_ast_relation_8h_source.html#l00119">souffle::AstRelation::getArity()</a>, <a class="el" href="_ast_relation_8h_source.html#l00129">souffle::AstRelation::getAttributes()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00108">souffle::AstRelation::setName()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                                                                                             {</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    <span class="comment">// get the adornment of this argument</span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    std::string adornment = <a class="code" href="namespacesouffle.html#a3c36e5eb0fc8e43102b85fba043aa422">extractAdornment</a>(magicPredName);</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    <span class="comment">// create the relation</span></div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    AstRelation* newMagicRelation = <span class="keyword">new</span> AstRelation();</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    newMagicRelation-&gt;setName(magicPredName);</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    <span class="comment">// copy over (bound) attributes from the original relation</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;    std::vector&lt;AstAttribute*&gt; attrs = original-&gt;getAttributes();</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> currentArg = 0; currentArg &lt; original-&gt;getArity(); currentArg++) {</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <span class="keywordflow">if</span> (adornment[currentArg] == <span class="charliteral">&#39;b&#39;</span>) {</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;            newMagicRelation-&gt;addAttribute(std::unique_ptr&lt;AstAttribute&gt;(attrs[currentArg]-&gt;clone()));</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;        }</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    }</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    <span class="keywordflow">return</span> newMagicRelation;</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a3c36e5eb0fc8e43102b85fba043aa422"><div class="ttname"><a href="namespacesouffle.html#a3c36e5eb0fc8e43102b85fba043aa422">souffle::extractAdornment</a></div><div class="ttdeci">std::string extractAdornment(AstRelationIdentifier magicRelationName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00977">MagicSet.cpp:977</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a328018b78e55eac5ab9bd242d6f35eac_cgraph.png" border="0" usemap="#namespacesouffle_a328018b78e55eac5ab9bd242d6f35eac_cgraph" alt=""/></div>
<map name="namespacesouffle_a328018b78e55eac5ab9bd242d6f35eac_cgraph" id="namespacesouffle_a328018b78e55eac5ab9bd242d6f35eac_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#abc452f3678fbd70929638ae5c779cca6" title="Add a new used type to this relation. " alt="" coords="261,5,398,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a3c36e5eb0fc8e43102b85fba043aa422" title="souffle::extractAdornment" alt="" coords="243,71,415,97"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#a855b01ad5e4a0871ef6c6f6bb1e95d13" title="Return the arity of this relation. " alt="" coords="261,122,398,163"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#adf9ccc5b4924918ea95bd64898196b66" title="Obtains a list of the contained attributes. " alt="" coords="261,187,398,229"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_relation.html#ac2902ef3d54670976da8bcaf4a9f4b45" title="Set name for this relation. " alt="" coords="261,253,398,294"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="464,34,651,75"/><area shape="rect" id="node5" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470" title="souffle::getEndpoint" alt="" coords="488,100,627,127"/><area shape="rect" id="node8" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="490,195,625,221"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a395ec79864680ea50d418a241b05b4a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>* souffle::createNewRelation </td>
          <td>(</td>
          <td class="paramtype">AstRelation *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00226">226</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00113">souffle::AstRelation::addAttribute()</a>, <a class="el" href="_ast_relation_8h_source.html#l00129">souffle::AstRelation::getAttributes()</a>, <a class="el" href="_ast_node_8h_source.html#l00047">souffle::AstNode::getSrcLoc()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00184">nextSrcLoc()</a>, <a class="el" href="_ast_relation_8h_source.html#l00108">souffle::AstRelation::setName()</a>, <a class="el" href="_ast_node_8h_source.html#l00052">souffle::AstNode::setSrcLoc()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00215">updateQualifier()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00914">separateDBs()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    AstRelation* newRelation = <span class="keyword">new</span> AstRelation();</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    newRelation-&gt;setSrcLoc(<a class="code" href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50">nextSrcLoc</a>(original-&gt;getSrcLoc()));</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    newRelation-&gt;setName(newName);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="comment">// copy over the attributes from the original relation</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">for</span> (AstAttribute* attr : original-&gt;getAttributes()) {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        newRelation-&gt;addAttribute(std::unique_ptr&lt;AstAttribute&gt;(attr-&gt;clone()));</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    }</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="comment">// copy over necessary qualifiers</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <a class="code" href="namespacesouffle.html#aee69f1913bc5a4f49deeca2b10c8323b">updateQualifier</a>(original, newRelation);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> newRelation;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aee69f1913bc5a4f49deeca2b10c8323b"><div class="ttname"><a href="namespacesouffle.html#aee69f1913bc5a4f49deeca2b10c8323b">souffle::updateQualifier</a></div><div class="ttdeci">void updateQualifier(AstRelation *originalRelation, AstRelation *newRelation)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00215">MagicSet.cpp:215</a></div></div>
<div class="ttc" id="namespacesouffle_html_a816a525106d63dbdd220ee8ecc238f50"><div class="ttname"><a href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50">souffle::nextSrcLoc</a></div><div class="ttdeci">AstSrcLocation nextSrcLoc(AstSrcLocation orig)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00184">MagicSet.cpp:184</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a395ec79864680ea50d418a241b05b4a0_cgraph.png" border="0" usemap="#namespacesouffle_a395ec79864680ea50d418a241b05b4a0_cgraph" alt=""/></div>
<map name="namespacesouffle_a395ec79864680ea50d418a241b05b4a0_cgraph" id="namespacesouffle_a395ec79864680ea50d418a241b05b4a0_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#abc452f3678fbd70929638ae5c779cca6" title="Add a new used type to this relation. " alt="" coords="259,5,397,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation.html#adf9ccc5b4924918ea95bd64898196b66" title="Obtains a list of the contained attributes. " alt="" coords="259,70,397,111"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="235,136,421,163"/><area shape="rect" id="node6" href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50" title="souffle::nextSrcLoc" alt="" coords="261,187,395,213"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#ac2902ef3d54670976da8bcaf4a9f4b45" title="Set name for this relation. " alt="" coords="259,238,397,279"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="235,304,421,331"/><area shape="rect" id="node9" href="namespacesouffle.html#aee69f1913bc5a4f49deeca2b10c8323b" title="souffle::updateQualifier" alt="" coords="250,355,406,381"/><area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="471,77,606,104"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_relation.html#a15a48bcd5bcf6eebbc4bb4ef16e52685" title="Return qualifier associated with this relation. " alt="" coords="470,282,607,323"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_relation.html#a96ff8bd588002b8182393d95258c9d66" title="Check whether relation is a equivalence relation. " alt="" coords="470,347,607,389"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_relation.html#a9527d30091d612f497c769ca3e87548f" title="Set qualifier associated with this relation. " alt="" coords="470,413,607,454"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a39e9f31e2107493d66acbbd3f3f94460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> souffle::createSubIdentifier </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00280">280</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00057">souffle::AstRelationIdentifier::append()</a>, and <a class="el" href="_ast_relation_identifier_8h_source.html#l00067">souffle::AstRelationIdentifier::getNames()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                                                                                           {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getNames();</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// get the substring of the base name</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    std::stringstream newMainName;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    newMainName &lt;&lt; relationNames[0].substr(start, length);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    AstRelationIdentifier newRelationName(newMainName.str());</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="comment">// add in the remaining names</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; relationNames.size(); i++) {</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        newRelationName.append(relationNames[i]);</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    }</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a39e9f31e2107493d66acbbd3f3f94460_cgraph.png" border="0" usemap="#namespacesouffle_a39e9f31e2107493d66acbbd3f3f94460_cgraph" alt=""/></div>
<map name="namespacesouffle_a39e9f31e2107493d66acbbd3f3f94460_cgraph" id="namespacesouffle_a39e9f31e2107493d66acbbd3f3f94460_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#a40b918b195df8c3eb223c068db7536fe" title="souffle::AstRelationIdentifier\l::append" alt="" coords="232,5,419,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="232,70,419,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeb411c7585f438a75ef3de5b6ae2abc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a>&lt;Iter&gt; souffle::derefIter </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function enabling the construction of a dereferencing iterator utilizing the automated deduction of template parameters. </p>

<p>Definition at line <a class="el" href="_iter_utils_8h_source.html#l00078">78</a> of file <a class="el" href="_iter_utils_8h_source.html">IterUtils.h</a>.</p>

<p>Referenced by <a class="el" href="_type_system_8h_source.html#l00253">souffle::TypeSet::begin()</a>, <a class="el" href="_type_system_8h_source.html#l00259">souffle::TypeSet::end()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00733">souffle::ram::index_utils::IndirectIndex&lt; Tuple, Index &gt;::equalRange()</a>, and <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00774">souffle::ram::index_utils::IndirectIndex&lt; Tuple, Index &gt;::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                                                   {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> IterDerefWrapper&lt;Iter&gt;(iter);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72e10d44624c80609e5c09b131ecf3fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::dirName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++-style dirname. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00985">985</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                                                {</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.empty()) {</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    }</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    <span class="keywordtype">size_t</span> lastNotSlash = <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.find_last_not_of(<span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    <span class="comment">// All &#39;/&#39;</span></div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    <span class="keywordflow">if</span> (lastNotSlash == std::string::npos) {</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    }</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keywordtype">size_t</span> leadingSlash = <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.find_last_of(<span class="charliteral">&#39;/&#39;</span>, lastNotSlash);</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    <span class="comment">// No &#39;/&#39;</span></div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    <span class="keywordflow">if</span> (leadingSlash == std::string::npos) {</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    }</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    <span class="comment">// dirname is &#39;/&#39;</span></div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="keywordflow">if</span> (leadingSlash == 0) {</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    }</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.substr(0, leadingSlash);</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5a93424fa42c59893383c23ecf475766"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long souffle::duration_in_ms </td>
          <td>(</td>
          <td class="paramtype">const time_point &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_point &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00916">916</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;                                                                           {</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8ba27d2caf5a777268d89eaf5cbfed2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long souffle::duration_in_ns </td>
          <td>(</td>
          <td class="paramtype">const time_point &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_point &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00921">921</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                                                                           {</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6e84ddff3bc168499fa141d3a3998494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given value string ends with the given end string. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00760">760</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                                                                      {</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    <span class="keywordflow">if</span> (value.size() &lt; ending.size()) {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    }</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">std::equal</a>(ending.rbegin(), ending.rend(), value.rbegin());</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab0083e5ad86e88ff726ea4e3c7ef23c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two vectors are equal (same vector of elements). </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00295">295</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00099">souffle::ram::index_utils::comparator&lt; First, Rest...&gt;::equal()</a>, and <a class="el" href="_util_8h_source.html#l00323">equal_targets()</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="comment">// check reference</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">if</span> (&amp;a == &amp;b) {</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="comment">// check size</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">if</span> (a.size() != b.size()) {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="comment">// check content</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; a.size(); ++i) {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="comment">// if there is a difference</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordflow">if</span> (!comp(a[i], b[i])) {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        }</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    }</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="comment">// all the same</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a71900d5ac92d70a4132fff4e280dd1cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two sets are equal (same set of elements). </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00349">349</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                                                                              {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="comment">// check reference</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">if</span> (&amp;a == &amp;b) {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="comment">// check size</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">if</span> (a.size() != b.size()) {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="comment">// check content</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it_i = a.begin(); it_i != a.end(); ++it_i) {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it_j = a.begin(); it_j != a.end(); ++it_j) {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="comment">// if there is a difference</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;            <span class="keywordflow">if</span> (!comp(*it_i, *it_j)) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            }</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    }</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">// all the same</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab097fb451e787a08a185a449bacde2db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_ptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00406">406</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00731">souffle::AstAggregator::equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                                       {</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">if</span> (!a &amp;&amp; !b) {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keywordflow">if</span> (a &amp;&amp; b) {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="keywordflow">return</span> *a == *b;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    }</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b13dfdf28e89958f7adeaa43abbe34f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00421">421</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                                                                     {</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">if</span> (!a &amp;&amp; !b) {</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">if</span> (a &amp;&amp; b) {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        <span class="keywordflow">return</span> *a == *b;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    }</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a961b0d79be71a35f0b60aeedf212fe4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two vector of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00323">323</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>

<p>Referenced by <a class="el" href="_ast_literal_8h_source.html#l00164">souffle::AstAtom::equal()</a>, <a class="el" href="_ast_program_8h_source.html#l00224">souffle::AstProgram::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00255">souffle::RamScan::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00314">souffle::RamNotExists::equal()</a>, <a class="el" href="_ast_relation_8h_source.html#l00368">souffle::AstRelation::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00399">souffle::RamFact::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00415">souffle::RamAggregate::equal()</a>, <a class="el" href="_ast_component_8h_source.html#l00431">souffle::AstComponent::equal()</a>, <a class="el" href="_ast_clause_8h_source.html#l00441">souffle::AstClause::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00515">souffle::RamProject::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00547">souffle::RamSequence::equal()</a>, <a class="el" href="_ram_value_8h_source.html#l00552">souffle::RamPack::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00576">souffle::RamReturn::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00592">souffle::AstRecordInit::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00620">souffle::RamParallel::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00731">souffle::AstAggregator::equal()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00413">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                                                                   {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;T*&gt;());</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a961b0d79be71a35f0b60aeedf212fe4a_cgraph.png" border="0" usemap="#namespacesouffle_a961b0d79be71a35f0b60aeedf212fe4a_cgraph" alt=""/></div>
<map name="namespacesouffle_a961b0d79be71a35f0b60aeedf212fe4a_cgraph" id="namespacesouffle_a961b0d79be71a35f0b60aeedf212fe4a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae042a1a59dfe209421a92154e83b3145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two vector of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00332">332</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                                                                                               {</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;std::unique_ptr&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae042a1a59dfe209421a92154e83b3145_cgraph.png" border="0" usemap="#namespacesouffle_ae042a1a59dfe209421a92154e83b3145_cgraph" alt=""/></div>
<map name="namespacesouffle_ae042a1a59dfe209421a92154e83b3145_cgraph" id="namespacesouffle_ae042a1a59dfe209421a92154e83b3145_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aef9c6f3c99122a5e04e14bd3d26f9e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two vector of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00341">341</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                                                                               {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;std::shared_ptr&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aef9c6f3c99122a5e04e14bd3d26f9e21_cgraph.png" border="0" usemap="#namespacesouffle_aef9c6f3c99122a5e04e14bd3d26f9e21_cgraph" alt=""/></div>
<map name="namespacesouffle_aef9c6f3c99122a5e04e14bd3d26f9e21_cgraph" id="namespacesouffle_aef9c6f3c99122a5e04e14bd3d26f9e21_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6e426c93033a166915ea2990c513a4fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two set of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00379">379</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                                             {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;T*&gt;());</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a6e426c93033a166915ea2990c513a4fa_cgraph.png" border="0" usemap="#namespacesouffle_a6e426c93033a166915ea2990c513a4fa_cgraph" alt=""/></div>
<map name="namespacesouffle_a6e426c93033a166915ea2990c513a4fa_cgraph" id="namespacesouffle_a6e426c93033a166915ea2990c513a4fa_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a806a1898ee38dcc89c3a7d24a18e9fcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two set of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00388">388</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;std::unique_ptr&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a806a1898ee38dcc89c3a7d24a18e9fcb_cgraph.png" border="0" usemap="#namespacesouffle_a806a1898ee38dcc89c3a7d24a18e9fcb_cgraph" alt=""/></div>
<map name="namespacesouffle_a806a1898ee38dcc89c3a7d24a18e9fcb_cgraph" id="namespacesouffle_a806a1898ee38dcc89c3a7d24a18e9fcb_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7fbdbf02eb7f38788faa2880c7f600d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two set of pointers are referencing to equivalent targets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00397">397</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00295">equal()</a>.</p>
<div class="fragment"><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">equal</a>(a, b, comp_deref&lt;std::shared_ptr&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a71900d5ac92d70a4132fff4e280dd1cd"><div class="ttname"><a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a></div><div class="ttdeci">bool equal(const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b, const Comp &amp;comp=Comp())</div><div class="ttdoc">A function testing whether two sets are equal (same set of elements). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00349">Util.h:349</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7fbdbf02eb7f38788faa2880c7f600d7_cgraph.png" border="0" usemap="#namespacesouffle_a7fbdbf02eb7f38788faa2880c7f600d7_cgraph" alt=""/></div>
<map name="namespacesouffle_a7fbdbf02eb7f38788faa2880c7f600d7_cgraph" id="namespacesouffle_a7fbdbf02eb7f38788faa2880c7f600d7_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1" title="A function testing whether two vectors are equal (same vector of elements). " alt="" coords="201,5,301,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1752bf432062837ed19ae6ac73ab177c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::executeBinary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binaryFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a binary file. </p>

<p>Definition at line <a class="el" href="main_8cpp_source.html#l00070">70</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p>References <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>, and <a class="el" href="_util_8h_source.html#l00958">isExecutable()</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                                    {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    assert(!binaryFilename.empty() &amp;&amp; <span class="stringliteral">&quot;binary filename cannot be blank&quot;</span>);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// separate souffle output from executable output</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;profile&quot;</span>)) {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        std::cout.flush();</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// check whether the executable exists</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(binaryFilename)) {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Generated executable &lt;&quot;</span> + binaryFilename + <span class="stringliteral">&quot;&gt; could not be found&quot;</span>);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// run executable</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordtype">int</span> result = system(binaryFilename.c_str());</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">// Remove temp files</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">if</span> (Global::config().get(<span class="stringliteral">&quot;dl-program&quot;</span>).empty()) {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keyword">remove</span>(binaryFilename.c_str());</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keyword">remove</span>((binaryFilename + <span class="stringliteral">&quot;.cpp&quot;</span>).c_str());</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">if</span> (result != 0) {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        exit(result);</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00958">Util.h:958</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph.png" border="0" usemap="#namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph" alt=""/></div>
<map name="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph" id="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="205,5,355,32"/><area shape="rect" id="node3" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14" title="Check whether a given file exists and it is an executable. " alt="" coords="208,56,352,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a79fa4170c4094bc943de6fa5acb5796e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::existDir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a directory exists in the file system. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00945">945</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                                            {</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="keyword">struct </span>stat buffer;</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    <span class="keywordflow">if</span> (stat(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.c_str(), &amp;buffer) == 0) {</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;        <span class="keywordflow">if</span> ((buffer.st_mode &amp; S_IFDIR) != 0) {</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        }</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    }</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69107e934a60222580ee8ba6882dc3d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::existFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a file exists in the file system. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00932">932</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                                             {</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keyword">struct </span>stat buffer;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    <span class="keywordflow">if</span> (stat(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.c_str(), &amp;buffer) == 0) {</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;        <span class="keywordflow">if</span> ((buffer.st_mode &amp; S_IFREG) != 0) {</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;        }</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    }</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a783c22acbaa814d35b915fa6d09696d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::explain </td>
          <td>(</td>
          <td class="paramtype">SouffleProgram &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sld</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ncurses</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_explain_8h_source.html#l00269">269</a> of file <a class="el" href="_explain_8h_source.html">Explain.h</a>.</p>

<p>References <a class="el" href="_explain_8h_source.html#l00156">souffle::Explain::explain()</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                                                                 {</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Explain is invoked.\n&quot;</span>;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    ExplainProvenanceSLD prov(prog);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    Explain exp(prov, ncurses);</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    exp.explain();</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a783c22acbaa814d35b915fa6d09696d8_cgraph.png" border="0" usemap="#namespacesouffle_a783c22acbaa814d35b915fa6d09696d8_cgraph" alt=""/></div>
<map name="namespacesouffle_a783c22acbaa814d35b915fa6d09696d8_cgraph" id="namespacesouffle_a783c22acbaa814d35b915fa6d09696d8_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_explain.html#aabd40f949d36ae7cd2782f62088e7c11" title="souffle::Explain::explain" alt="" coords="166,260,327,287"/><area shape="rect" id="node3" href="classsouffle_1_1_explain.html#ae3c25129416040424fa123f70566c8ae" title="souffle::Explain::initialise\lWindow" alt="" coords="385,5,551,46"/><area shape="rect" id="node5" href="namespacesouffle.html#a7f32090909fb88cd5af742382c7ddd2c" title="utility function to split a string " alt="" coords="421,71,515,97"/><area shape="rect" id="node7" href="classsouffle_1_1_explain.html#a0959bd00e5dac64e88158ddab67d45a9" title="souffle::Explain::printStr" alt="" coords="387,121,549,148"/><area shape="rect" id="node8" href="classsouffle_1_1_explain.html#a2b162a9221551183972e5eaa781a218b" title="souffle::Explain::parseTuple" alt="" coords="376,172,560,199"/><area shape="rect" id="node9" href="classsouffle_1_1_explain_provenance.html#a340ed47f995b5172ab9f346babc4bfd7" title="souffle::ExplainProvenance\l::explain" alt="" coords="377,223,559,265"/><area shape="rect" id="node10" href="classsouffle_1_1_explain.html#a04c6d4e51a17c6850f37036df137ccd7" title="souffle::Explain::printTree" alt="" coords="383,289,553,316"/><area shape="rect" id="node13" href="classsouffle_1_1_explain_provenance.html#a64e3165acb1b13e24e5f1974d8c29cf2" title="souffle::ExplainProvenance\l::explainSubproof" alt="" coords="377,341,559,382"/><area shape="rect" id="node14" href="classsouffle_1_1_explain_provenance.html#aadcec6224703d8b59f7743ce97bf7f03" title="souffle::ExplainProvenance\l::getRule" alt="" coords="377,406,559,447"/><area shape="rect" id="node15" href="classsouffle_1_1_explain_provenance.html#ad23118b17b9a9bc388cb313f996a94d5" title="souffle::ExplainProvenance\l::getRelationOutput" alt="" coords="377,471,559,513"/><area shape="rect" id="node21" href="classsouffle_1_1_explain.html#a0b102860f7c8ce0062f38e64f25ff1e9" title="souffle::Explain::scrollTree" alt="" coords="379,537,557,564"/><area shape="rect" id="node4" href="classsouffle_1_1_explain.html#a3fca32021a311309cd914e5f845139cb" title="souffle::Explain::makeQuery\lWindow" alt="" coords="608,5,795,46"/><area shape="rect" id="node6" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f" title="A utility printing a given value multiple times. " alt="" coords="651,71,752,97"/><area shape="rect" id="node11" href="classsouffle_1_1_screen_buffer.html#a077af583c179141a81a7a9f3c06b092c" title="souffle::ScreenBuffer\l::getString" alt="" coords="629,282,774,323"/><area shape="rect" id="node12" href="classsouffle_1_1_screen_buffer.html#a2e5e6bf07dbecb217df56d63851a5587" title="souffle::ScreenBuffer\l::print" alt="" coords="843,282,989,323"/><area shape="rect" id="node16" href="classsouffle_1_1_souffle_program.html#a8d60868a2e93de1ccc7b09d140542d0d" title="souffle::SouffleProgram\l::getRelation" alt="" coords="622,377,781,418"/><area shape="rect" id="node17" href="classsouffle_1_1_symbol_mask.html#a8f5dd51f70faaf206bc3bedad2a4e8c7" title="souffle::SymbolMask\l::setSymbol" alt="" coords="629,442,774,483"/><area shape="rect" id="node19" href="classsouffle_1_1_i_o_directives.html#abef5a3f9b0d3393b17f2493c6769df63" title="souffle::IODirectives\l::setRelationName" alt="" coords="630,507,773,549"/><area shape="rect" id="node20" href="classsouffle_1_1_explain_provenance.html#a117ef6b6c90008a386e0e6b3800d0ce8" title="souffle::ExplainProvenance\l::printRelationOutput" alt="" coords="611,573,792,614"/><area shape="rect" id="node18" href="classsouffle_1_1_symbol_mask.html#a73093d37902fa812dc5db128ab9ed85e" title="souffle::SymbolMask\l::getArity" alt="" coords="843,442,989,483"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3c36e5eb0fc8e43102b85fba043aa422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::extractAdornment </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>magicRelationName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00977">977</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00079">getEndpoint()</a>, and <a class="el" href="_ast_relation_identifier_8h_source.html#l00067">souffle::AstRelationIdentifier::getNames()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01007">createMagicRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;                                                                    {</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    std::string baseRelationName = magicRelationName.getNames()[0];</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    <span class="keywordtype">int</span> endpt = <a class="code" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">getEndpoint</a>(baseRelationName);</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;    std::string adornment = baseRelationName.substr(endpt + 1, baseRelationName.size() - (endpt + 1));</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    <span class="keywordflow">return</span> adornment;</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a620dc7687473311acaa752a76b5c9470"><div class="ttname"><a href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">souffle::getEndpoint</a></div><div class="ttdeci">int getEndpoint(std::string mainName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00079">MagicSet.cpp:79</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3c36e5eb0fc8e43102b85fba043aa422_cgraph.png" border="0" usemap="#namespacesouffle_a3c36e5eb0fc8e43102b85fba043aa422_cgraph" alt=""/></div>
<map name="namespacesouffle_a3c36e5eb0fc8e43102b85fba043aa422_cgraph" id="namespacesouffle_a3c36e5eb0fc8e43102b85fba043aa422_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470" title="souffle::getEndpoint" alt="" coords="251,5,389,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="227,57,413,98"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a85db0960025701b3a8a8c6e592bbbef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>* souffle::extractConstant </td>
          <td>(</td>
          <td class="paramtype">SymbolTable &amp;&#160;</td>
          <td class="paramname"><em>symbolTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>normalisedConstant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00985">985</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    <span class="comment">// strip off the prefix up to (and including) the first underscore</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    <span class="keywordtype">size_t</span> argStart = normalisedConstant.find(<span class="charliteral">&#39;_&#39;</span>);</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    std::string arg = normalisedConstant.substr(argStart + 1, normalisedConstant.size());</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    <span class="comment">// -- check if string or num constant --</span></div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    <span class="keywordtype">char</span> indicatorChar = arg[arg.size() - 1];  <span class="comment">// &#39;n&#39; or &#39;s&#39;</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    std::string stringRep = arg.substr(0, arg.size() - 2);</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;s&#39;</span>) {</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        <span class="comment">// string argument</span></div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstStringConstant(symbolTable, stringRep.c_str());</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;n&#39;</span>) {</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;        <span class="comment">// numeric argument</span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstNumberConstant(stoi(stringRep));</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        <span class="comment">// invalid format</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    }</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8e3419b4e4df09a580063d2f078a3774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::fileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File extension, with all else removed. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01083">1083</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;                                                      {</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;    std::string <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a> = path;</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastDot = name.find_last_of(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <span class="comment">// file has no extension</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    <span class="keywordflow">if</span> (lastDot == std::string::npos) <span class="keywordflow">return</span> std::string();</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastSlash = name.find_last_of(<span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="comment">// last slash occurs after last dot, so no extension</span></div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <span class="keywordflow">if</span> (lastSlash != std::string::npos &amp;&amp; lastSlash &gt; lastDot) <span class="keywordflow">return</span> std::string();</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;    <span class="comment">// last dot after last slash, or no slash</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    <span class="keywordflow">return</span> name.substr(lastDot + 1);</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4e2b4ce9b3036075ce407c2b524013a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a>&gt; souffle::findInlineCycle </td>
          <td>(</td>
          <td class="paramtype">const PrecedenceGraph &amp;&#160;</td>
          <td class="paramname"><em>precedenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const AstRelation *, const AstRelation * &gt; &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationSet &amp;&#160;</td>
          <td class="paramname"><em>unvisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationSet &amp;&#160;</td>
          <td class="paramname"><em>visiting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationSet &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a cycle consisting entirely of inlined relations. </p>
<p>If no cycle exists, then an empty vector is returned. </p>

<p>Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00858">858</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::getName()</a>, and <a class="el" href="_precedence_graph_8h_source.html#l00051">souffle::PrecedenceGraph::graph()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00936">souffle::AstSemanticChecker::checkInlining()</a>.</p>
<div class="fragment"><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    std::vector&lt;AstRelationIdentifier&gt; result;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;    <span class="keywordflow">if</span> (current == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;        <span class="comment">// Not looking at any nodes at the moment, so choose any node from the unvisited list</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        <span class="keywordflow">if</span> (unvisited.empty()) {</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            <span class="comment">// Nothing left to visit - so no cycles exist!</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;        }</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="comment">// Choose any element from the unvisited set</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        current = *unvisited.begin();</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        origins[current] = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        <span class="comment">// Move it to &quot;currently visiting&quot;</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        unvisited.erase(current);</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        visiting.insert(current);</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;        <span class="comment">// Check if we can find a cycle beginning from this node</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        std::vector&lt;AstRelationIdentifier&gt; subresult =</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;                <a class="code" href="namespacesouffle.html#a4e2b4ce9b3036075ce407c2b524013a9">findInlineCycle</a>(precedenceGraph, origins, current, unvisited, visiting, visited);</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;        <span class="keywordflow">if</span> (subresult.empty()) {</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;            <span class="comment">// No cycle found, try again from another node</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a4e2b4ce9b3036075ce407c2b524013a9">findInlineCycle</a>(precedenceGraph, origins, <span class="keyword">nullptr</span>, unvisited, visiting, visited);</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;            <span class="comment">// Cycle found! Return it</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;            <span class="keywordflow">return</span> subresult;</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        }</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    }</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    <span class="comment">// Check neighbours</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">AstRelationSet</a>&amp; successors = precedenceGraph.graph().successors(current);</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstRelation* successor : successors) {</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <span class="comment">// Only care about inlined neighbours in the graph</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        <span class="keywordflow">if</span> (successor-&gt;isInline()) {</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;            <span class="keywordflow">if</span> (visited.find(successor) != visited.end()) {</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                <span class="comment">// The neighbour has already been visited, so move on</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;            }</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;            <span class="keywordflow">if</span> (visiting.find(successor) != visiting.end()) {</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                <span class="comment">// Found a cycle!!</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                <span class="comment">// Construct the cycle in reverse</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;                <span class="keywordflow">while</span> (current != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;                    result.push_back(current-&gt;getName());</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                    current = origins[current];</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                }</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            }</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;            <span class="comment">// Node has not been visited yet</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            origins[successor] = current;</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            <span class="comment">// Move from unvisited to visiting</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            unvisited.erase(successor);</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            visiting.insert(successor);</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            <span class="comment">// Visit recursively and check if a cycle is formed</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            std::vector&lt;AstRelationIdentifier&gt; subgraphCycle =</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                    <a class="code" href="namespacesouffle.html#a4e2b4ce9b3036075ce407c2b524013a9">findInlineCycle</a>(precedenceGraph, origins, successor, unvisited, visiting, visited);</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            <span class="keywordflow">if</span> (!subgraphCycle.empty()) {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                <span class="comment">// Found a cycle!</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;                <span class="keywordflow">return</span> subgraphCycle;</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            }</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    }</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    <span class="comment">// Visited all neighbours with no cycle found, so done visiting this node.</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    visiting.erase(current);</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    visited.insert(current);</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a4e2b4ce9b3036075ce407c2b524013a9"><div class="ttname"><a href="namespacesouffle.html#a4e2b4ce9b3036075ce407c2b524013a9">souffle::findInlineCycle</a></div><div class="ttdeci">std::vector&lt; AstRelationIdentifier &gt; findInlineCycle(const PrecedenceGraph &amp;precedenceGraph, std::map&lt; const AstRelation *, const AstRelation * &gt; &amp;origins, const AstRelation *current, AstRelationSet &amp;unvisited, AstRelationSet &amp;visiting, AstRelationSet &amp;visited)</div><div class="ttdoc">Find a cycle consisting entirely of inlined relations. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00858">AstSemanticChecker.cpp:858</a></div></div>
<div class="ttc" id="namespacesouffle_html_a606048097fb760a78f4d0aad940468b0"><div class="ttname"><a href="namespacesouffle.html#a606048097fb760a78f4d0aad940468b0">souffle::AstRelationSet</a></div><div class="ttdeci">std::set&lt; const AstRelation *, AstNameComparison &gt; AstRelationSet</div><div class="ttdef"><b>Definition:</b> <a href="_ast_relation_8h_source.html#l00385">AstRelation.h:385</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4e2b4ce9b3036075ce407c2b524013a9_cgraph.png" border="0" usemap="#namespacesouffle_a4e2b4ce9b3036075ce407c2b524013a9_cgraph" alt=""/></div>
<map name="namespacesouffle_a4e2b4ce9b3036075ce407c2b524013a9_cgraph" id="namespacesouffle_a4e2b4ce9b3036075ce407c2b524013a9_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#a6ae505289ecfc8e40c9f4e47689f5ee8" title="Return the name of the relation. " alt="" coords="226,5,363,46"/><area shape="rect" id="node3" href="classsouffle_1_1_precedence_graph.html#aaaa7bc2a66bb69fceff4b8e699c87eda" title="souffle::PrecedenceGraph\l::graph" alt="" coords="208,70,381,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af944f0c474df29e5c8e45e4b7df60be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::findTool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l01031">1031</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;                                                                                               {</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    std::string dir = <a class="code" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a>(base);</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    std::stringstream sstr(path);</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;    std::string <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>;</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;    <span class="keywordflow">while</span> (std::getline(sstr, sub, <span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;        std::string subpath = dir + <span class="stringliteral">&quot;/&quot;</span> + sub + <span class="charliteral">&#39;/&#39;</span> + tool;</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(subpath)) {</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">absPath</a>(subpath);</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;        }</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    }</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a72e10d44624c80609e5c09b131ecf3fb"><div class="ttname"><a href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">souffle::dirName</a></div><div class="ttdeci">std::string dirName(const std::string &amp;name)</div><div class="ttdoc">C++-style dirname. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00985">Util.h:985</a></div></div>
<div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00223">Constraints.h:223</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00958">Util.h:958</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8a2c294e3ff514cd4ca29b466ff3cab3"><div class="ttname"><a href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">souffle::absPath</a></div><div class="ttdeci">std::string absPath(const std::string &amp;path)</div><div class="ttdoc">C++-style realpath. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01009">Util.h:1009</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2e5ef82376f71d4d7ebfcfa64437d540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt; &gt; souffle::formNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the bodies that will replace the negation of a given inlined atom. </p>
<p>E.g. a(x) &lt;- (a11(x), a12(x)) ; (a21(x), a22(x)) =&gt; !a(x) &lt;- (!a11(x), !a21(x)) ; (!a11(x), !a22(x)) ; ... Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is the negation of a literal in the ith rule of a. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00371">371</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00321">combineNegatedLiterals()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00238">inlineBodyLiterals()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="comment">// Constraints added to unify atoms should not be negated and should be added to</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="comment">// all the final rule combinations produced, and so should be stored separately.</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; addedBodyLiterals;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    std::vector&lt;std::vector&lt;AstConstraint*&gt;&gt; addedConstraints;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="comment">// Go through every possible clause associated with the given atom</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">for</span> (AstClause* inClause : program.getRelation(atom-&gt;getName())-&gt;getClauses()) {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="comment">// Form the replacement clause by inlining based on the current clause</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        std::pair&lt;NullableVector&lt;AstLiteral*&gt;, std::vector&lt;AstConstraint*&gt;&gt; inlineResult =</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                <a class="code" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f">inlineBodyLiterals</a>(atom, inClause);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        NullableVector&lt;AstLiteral*&gt; replacementBodyLiterals = inlineResult.first;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        std::vector&lt;AstConstraint*&gt; currConstraints = inlineResult.second;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            <span class="comment">// Failed to unify, so just move on</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        addedBodyLiterals.push_back(replacementBodyLiterals.getVector());</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        addedConstraints.push_back(currConstraints);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    }</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// We now have a list of bodies needed to inline the given atom.</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="comment">// We want to inline the negated version, however, which is done using De Morgan&#39;s Law.</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; negatedAddedBodyLiterals =</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <a class="code" href="namespacesouffle.html#a190c528007c7083a21c340006061986d">combineNegatedLiterals</a>(addedBodyLiterals);</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="comment">// Add in the necessary constraints to all the body literals</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; negatedAddedBodyLiterals.size(); i++) {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;AstConstraint*&gt; constraintGroup : addedConstraints) {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            <span class="keywordflow">for</span> (AstConstraint* constraint : constraintGroup) {</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                negatedAddedBodyLiterals[i].push_back(constraint-&gt;clone());</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            }</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        }</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    }</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="comment">// Free up the old body literals and constraints</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; litGroup : addedBodyLiterals) {</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : litGroup) {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;            <span class="keyword">delete</span> lit;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        }</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    }</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;AstConstraint*&gt; consGroup : addedConstraints) {</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">for</span> (AstConstraint* cons : consGroup) {</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            <span class="keyword">delete</span> cons;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        }</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    }</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">return</span> negatedAddedBodyLiterals;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a190c528007c7083a21c340006061986d"><div class="ttname"><a href="namespacesouffle.html#a190c528007c7083a21c340006061986d">souffle::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; AstLiteral * &gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00321">InlineRelationsTransformer.cpp:321</a></div></div>
<div class="ttc" id="namespacesouffle_html_acd0dfc0a494a70a89da974a472e7b23f"><div class="ttname"><a href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f">souffle::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; AstLiteral * &gt;, std::vector&lt; AstConstraint * &gt; &gt; inlineBodyLiterals(AstAtom *atom, AstClause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00238">InlineRelationsTransformer.cpp:238</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph.png" border="0" usemap="#namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph" alt=""/></div>
<map name="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph" id="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a190c528007c7083a21c340006061986d" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="241,205,450,232"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="255,495,436,521"/><area shape="rect" id="node15" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="276,546,415,587"/><area shape="rect" id="node16" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="499,223,653,265"/><area shape="rect" id="node17" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f" title="Inlines the given atom based on a given clause. " alt="" coords="260,393,431,420"/><area shape="rect" id="node28" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="499,602,653,643"/><area shape="rect" id="node3" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="505,151,647,177"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="718,100,895,127"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="727,151,886,177"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="732,253,881,294"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="732,34,881,75"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="967,151,1145,177"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="963,201,1149,228"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="981,253,1131,294"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="963,319,1149,345"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="981,5,1131,46"/><area shape="rect" id="node13" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="960,71,1152,97"/><area shape="rect" id="node18" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="511,289,641,330"/><area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="511,537,641,578"/><area shape="rect" id="node22" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="509,485,643,512"/><area shape="rect" id="node27" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="511,354,641,395"/><area shape="rect" id="node29" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="511,419,641,461"/><area shape="rect" id="node19" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="741,383,872,425"/><area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="741,318,873,359"/><area shape="rect" id="node23" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="702,456,911,483"/><area shape="rect" id="node25" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="718,507,895,533"/><area shape="rect" id="node24" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="989,456,1123,483"/><area shape="rect" id="node26" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1011,507,1101,533"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab18cbb3adc2ab328de0db30a3fddf7e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * souffle::getAtomRelation </td>
          <td>(</td>
          <td class="paramtype">const AstAtom *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relation referenced by the given atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom</td><td>the atom </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced by the atom </dd></dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00036">36</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, and <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>.</p>

<p>Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00758">souffle::TypeAnalysis::analyseTypes()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00044">getBodyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00040">getHeadRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00070">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00057">hasClauseWithNegatedRelation()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00696">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00723">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelationUses()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01168">souffle::AstExecutionPlanChecker::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00431">souffle::AstTranslator::translateClause()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00942">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> program-&gt;getRelation(atom-&gt;getName());</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph.png" border="0" usemap="#namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph" alt=""/></div>
<map name="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph" id="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="221,5,403,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="243,57,381,98"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a864e03a1043eca84e933df62177c024b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffa">BinaryOp</a> souffle::getBinaryOpForSymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts symbolic representation of an operator to the operator. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00087">87</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, and <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">SUB</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                              {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;+&quot;</span>) <span class="keywordflow">return</span> BinaryOp::ADD;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;-&quot;</span>) <span class="keywordflow">return</span> BinaryOp::SUB;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;*&quot;</span>) <span class="keywordflow">return</span> BinaryOp::MUL;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;/&quot;</span>) <span class="keywordflow">return</span> BinaryOp::DIV;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;^&quot;</span>) <span class="keywordflow">return</span> BinaryOp::EXP;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;%&quot;</span>) <span class="keywordflow">return</span> BinaryOp::MOD;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;band&quot;</span>) <span class="keywordflow">return</span> BinaryOp::BAND;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;bor&quot;</span>) <span class="keywordflow">return</span> BinaryOp::BOR;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;bxor&quot;</span>) <span class="keywordflow">return</span> BinaryOp::BXOR;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;land&quot;</span>) <span class="keywordflow">return</span> BinaryOp::LAND;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;lor&quot;</span>) <span class="keywordflow">return</span> BinaryOp::LOR;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;max&quot;</span>) <span class="keywordflow">return</span> BinaryOp::MAX;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;min&quot;</span>) <span class="keywordflow">return</span> BinaryOp::MIN;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;cat&quot;</span>) <span class="keywordflow">return</span> BinaryOp::CAT;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognised operator: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">return</span> BinaryOp::__UNDEFINED__;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a598a4ed07c31abae549ab7461fb9b7ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * &gt; souffle::getBodyRelations </td>
          <td>(</td>
          <td class="paramtype">const AstClause *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relations referenced in the body of the given clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced in the clause body </dd></dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00044">44</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00036">getAtomRelation()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00068">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_precedence_graph_8cpp_source.html#l00031">souffle::PrecedenceGraph::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::set&lt;const AstRelation*&gt; bodyRelations;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : clause-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                *lit, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { bodyRelations.insert(<a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)); });</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : clause-&gt;getHead()-&gt;getArguments()) {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                *arg, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { bodyRelations.insert(<a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)); });</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    }</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">return</span> bodyRelations;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00036">AstUtils.cpp:36</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph.png" border="0" usemap="#namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph" alt=""/></div>
<map name="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph" id="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="227,5,437,32"/><area shape="rect" id="node4" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="249,56,415,83"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="267,107,397,149"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="267,173,397,214"/><area shape="rect" id="node9" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="255,239,409,265"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="509,5,643,32"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="485,56,667,83"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="507,107,645,149"/><area shape="rect" id="node10" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="499,231,653,273"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="715,231,891,273"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a549b844f643767fd1388ff0a789bbea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, bool &gt; souffle::getConstTerms </td>
          <td>(</td>
          <td class="paramtype">const AstClause &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyse the given clause and computes for each contained argument whether it is a constant value or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause to be analyzed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map mapping each contained argument to a boolean indicating whether the argument represents a constant value or not </dd></dl>

<p>Definition at line <a class="el" href="_ast_type_analysis_8cpp_source.html#l00247">247</a> of file <a class="el" href="_ast_type_analysis_8cpp_source.html">AstTypeAnalysis.cpp</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_argument_8h_source.html#l00464">souffle::AstTernaryFunctor::getArg()</a>, <a class="el" href="_ast_argument_8h_source.html#l00556">souffle::AstRecordInit::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00257">souffle::AstConstraint::getLHS()</a>, <a class="el" href="_ast_argument_8h_source.html#l00367">souffle::AstBinaryFunctor::getLHS()</a>, <a class="el" href="_ast_argument_8h_source.html#l00288">souffle::AstUnaryFunctor::getOperand()</a>, <a class="el" href="_ast_literal_8h_source.html#l00267">souffle::AstConstraint::getOperator()</a>, <a class="el" href="_ast_literal_8h_source.html#l00262">souffle::AstConstraint::getRHS()</a>, <a class="el" href="_ast_argument_8h_source.html#l00371">souffle::AstBinaryFunctor::getRHS()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00169">lhs</a>, <a class="el" href="_compiled_ram_record_8h_source.html#l00164">pack()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00170">rhs</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                                                        {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="comment">// define analysis ..</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keyword">struct </span>Analysis : <span class="keyword">public</span> AstConstraintAnalysis&lt;BoolDisjunctVar&gt; {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="comment">// #1 - constants are constant</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordtype">void</span> visitConstant(<span class="keyword">const</span> AstConstant&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="comment">// this is a constant value</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            addConstraint(isTrue(getVar(cur)));</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        <span class="comment">// #2 - binary relations may propagate const</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordtype">void</span> visitConstraint(<span class="keyword">const</span> AstConstraint&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="comment">// only target equality</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keywordflow">if</span> (cur.getOperator() != BinaryConstraintOp::EQ) {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            }</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="comment">// if equal, link right and left side</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = getVar(cur.getLHS());</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = getVar(cur.getRHS());</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            addConstraint(imply(<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, rhs));</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            addConstraint(imply(rhs, <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>));</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="comment">// #3 - const is propagated via unary functors</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordtype">void</span> visitUnaryFunctor(<span class="keyword">const</span> AstUnaryFunctor&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            <span class="keyword">auto</span> fun = getVar(cur);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            <span class="keyword">auto</span> op = getVar(cur.getOperand());</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            addConstraint(imply(op, fun));</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        }</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="comment">// #4 - const is propagated via binary functors</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordtype">void</span> visitBinaryFunctor(<span class="keyword">const</span> AstBinaryFunctor&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="keyword">auto</span> fun = getVar(cur);</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = getVar(cur.getLHS());</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="keyword">auto</span> rhs = getVar(cur.getRHS());</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            addConstraint(imply({<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, rhs}, fun));</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            addConstraint(imply({fun, <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>}, <a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>));</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            addConstraint(imply({fun, rhs}, <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>));</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        }</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="comment">// #5 - const is propagated via ternary functors</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordtype">void</span> visitTernaryFunctor(<span class="keyword">const</span> AstTernaryFunctor&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keyword">auto</span> fun = getVar(cur);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keyword">auto</span> a0 = getVar(cur.getArg(0));</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keyword">auto</span> a1 = getVar(cur.getArg(1));</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            <span class="keyword">auto</span> a2 = getVar(cur.getArg(2));</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            addConstraint(imply({a0, a1, a2}, fun));</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        }</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="comment">// #6 - if pack nodes and its components</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordtype">void</span> visitRecordInit(<span class="keyword">const</span> AstRecordInit&amp; init)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="keyword">auto</span> <a class="code" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">pack</a> = getVar(init);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            std::vector&lt;BoolDisjunctVar&gt; subs;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : init.getArguments()) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                subs.push_back(getVar(cur));</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="comment">// link vars in both directions</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            addConstraint(imply(subs, <a class="code" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">pack</a>));</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : subs) {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                addConstraint(imply(<a class="code" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">pack</a>, c));</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            }</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        }</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    };</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">// run analysis on given clause</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">return</span> Analysis().analyse(clause);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a3194e440e935d0d6089f8fa6bf405086"><div class="ttname"><a href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">souffle::pack</a></div><div class="ttdeci">RamDomain pack(const Tuple &amp;tuple)</div><div class="ttdoc">A function packing a tuple of the given arity into a reference. </div><div class="ttdef"><b>Definition:</b> <a href="_compiled_ram_record_8h_source.html#l00164">CompiledRamRecord.h:164</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdoc">The two terms to be equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00169">AstTransforms.cpp:169</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00170">AstTransforms.cpp:170</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a549b844f643767fd1388ff0a789bbea5_cgraph.png" border="0" usemap="#namespacesouffle_a549b844f643767fd1388ff0a789bbea5_cgraph" alt=""/></div>
<map name="namespacesouffle_a549b844f643767fd1388ff0a789bbea5_cgraph" id="namespacesouffle_a549b844f643767fd1388ff0a789bbea5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_ternary_functor.html#a260a737a4d4d1f5afe152eb62ea952e2" title="souffle::AstTernaryFunctor\l::getArg" alt="" coords="214,5,391,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_record_init.html#ae516fe38512e96c666014acce207b983" title="souffle::AstRecordInit\l::getArguments" alt="" coords="228,70,377,111"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="228,135,377,177"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_binary_functor.html#af07199592aa2dfebeb17fb1a3fdee3ab" title="souffle::AstBinaryFunctor\l::getLHS" alt="" coords="217,201,388,242"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_unary_functor.html#a8ce4072c9ac9ba96517ac90cfd45a15f" title="souffle::AstUnaryFunctor\l::getOperand" alt="" coords="219,266,387,307"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="228,331,377,373"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="228,397,377,438"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_binary_functor.html#a23dfd787b0f56c314675dfea50eee0b0" title="souffle::AstBinaryFunctor\l::getRHS" alt="" coords="217,462,388,503"/><area shape="rect" id="node11" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086" title="A function packing a tuple of the given arity into a reference. " alt="" coords="254,528,351,555"/><area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="441,77,575,104"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a620dc7687473311acaa752a76b5c9470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getEndpoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mainName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00079">79</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00977">extractAdornment()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                    {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordtype">int</span> endpt = mainName.size() - 1;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">while</span> (endpt &gt;= 0 &amp;&amp; mainName[endpt] != <span class="charliteral">&#39;_&#39;</span>) {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        endpt--;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">if</span> (endpt == -1) {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        endpt = mainName.size();</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">return</span> endpt;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c6ac489d71276da23f5c2d5ba1c51ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the given types. </p>

<p>Definition at line <a class="el" href="_type_system_8h_source.html#l00483">483</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p>References <a class="el" href="_type_system_8cpp_source.html#l00504">getGreatestCommonSubtypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                                                         {</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8c6ac489d71276da23f5c2d5ba1c51ee">getGreatestCommonSubtypes</a>(TypeSet(<a class="code" href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>...));</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8c6ac489d71276da23f5c2d5ba1c51ee"><div class="ttname"><a href="namespacesouffle.html#a8c6ac489d71276da23f5c2d5ba1c51ee">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const Types &amp;...types)</div><div class="ttdoc">Computes the greatest common sub types of the given types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00483">TypeSystem.h:483</a></div></div>
<div class="ttc" id="_component_model_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_model_8cpp_source.html#l00083">ComponentModel.cpp:83</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8c6ac489d71276da23f5c2d5ba1c51ee_cgraph.png" border="0" usemap="#namespacesouffle_a8c6ac489d71276da23f5c2d5ba1c51ee_cgraph" alt=""/></div>
<map name="namespacesouffle_a8c6ac489d71276da23f5c2d5ba1c51ee_cgraph" id="namespacesouffle_a8c6ac489d71276da23f5c2d5ba1c51ee_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="246,181,437,222"/><area shape="rect" id="node3" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="896,71,1123,97"/><area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1389,151,1560,193"/><area shape="rect" id="node5" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="495,108,636,135"/><area shape="rect" id="node11" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="486,239,645,265"/><area shape="rect" id="node12" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="499,290,631,331"/><area shape="rect" id="node6" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="693,133,848,160"/><area shape="rect" id="node9" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="695,32,847,59"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="924,122,1095,163"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1171,122,1341,163"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="924,5,1095,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abb20659f25b4513908b813cfdbf43e23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the two given types. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00504">504</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00127">souffle::UnionType::getElementTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00059">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, <a class="el" href="_type_system_8cpp_source.html#l00365">isSubtypeOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00084">souffle::TypeEnvironment::isType()</a>.</p>

<p>Referenced by <a class="el" href="_type_system_8cpp_source.html#l00552">getGreatestCommonSubtypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                                                                {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="comment">// make sure they are in the same type environment</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    assert(a.getTypeEnvironment().isType(a) &amp;&amp; a.getTypeEnvironment().isType(b));</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="comment">// if they are equal it is easy</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keywordflow">if</span> (a == b) {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    }</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="comment">// equally simple - check whether one is a sub-type of the other</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, b)) {</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    }</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(b, a)) {</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordflow">return</span> TypeSet(b);</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="comment">// last option: if both are unions with common sub-types</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keywordflow">if</span> (isUnion(a) &amp;&amp; isUnion(b)) {</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <span class="comment">// collect common sub-types of union types</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="keyword">struct </span>collector : <span class="keyword">public</span> TypeVisitor&lt;void&gt; {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keyword">const</span> Type&amp; b;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            TypeSet&amp; res;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            collector(<span class="keyword">const</span> Type&amp; b, TypeSet&amp; res) : b(b), res(res) {}</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            <span class="keywordtype">void</span> visit(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(type, b)) {</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                    res.insert(type);</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                    TypeVisitor&lt;void&gt;::visit(type);</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                }</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            }</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            <span class="keywordtype">void</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : type.getElementTypes()) {</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                    visit(*cur);</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                }</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        };</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;        <span class="comment">// collect all common sub-types</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        collector(b, res).visit(a);</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    }</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="comment">// otherwise there is no common super type</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00365">TypeSystem.cpp:365</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph.png" border="0" usemap="#namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph" alt=""/></div>
<map name="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph" id="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="259,5,391,46"/><area shape="rect" id="node3" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="656,160,883,187"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="246,328,405,355"/><area shape="rect" id="node5" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="255,172,396,199"/><area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1149,241,1320,282"/><area shape="rect" id="node6" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="453,223,608,249"/><area shape="rect" id="node10" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="455,121,607,148"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="684,211,855,253"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="931,211,1101,253"/><area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="684,94,855,135"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3c2a47b9395910d9fc183cf16ec0ed38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of all the types in the given set. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00552">552</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00253">souffle::TypeSet::begin()</a>, <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00259">souffle::TypeSet::end()</a>, <a class="el" href="_type_system_8cpp_source.html#l00504">getGreatestCommonSubtypes()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                                                      {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="comment">// handle the empty set</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keywordflow">if</span> (set.empty()) {</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        <span class="keywordflow">return</span> set;</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    }</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="comment">// handle the all set =&gt; empty set (since no common sub-type)</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="keywordflow">if</span> (set.isAll()) {</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">return</span> TypeSet();</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    }</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    <span class="keyword">auto</span> it = set.begin();</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    res.insert(*it);</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    ++it;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    <span class="comment">// refine sub-set step by step</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="keywordflow">for</span> (; it != set.end(); ++it) {</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        TypeSet tmp;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : res) {</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            tmp.insert(<a class="code" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a>(cur, *it));</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        }</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        res = tmp;</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    }</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="comment">// done</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aed5ab68f123baedeb78d6c94920deb5d"><div class="ttname"><a href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise greatest common sub types of the types in the two given sets. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00581">TypeSystem.cpp:581</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph.png" border="0" usemap="#namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph" alt=""/></div>
<map name="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph" id="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a427bee6bd39217158b0aef0410b1008c" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="263,15,420,41"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="260,148,423,175"/><area shape="rect" id="node5" href="structsouffle_1_1_type_set.html#ac8828a4e976429c7f9d92ced14f15863" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="268,76,415,103"/><area shape="rect" id="node6" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="246,199,437,241"/><area shape="rect" id="node9" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="486,321,645,348"/><area shape="rect" id="node17" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="266,316,417,343"/><area shape="rect" id="node3" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5" title="A factory function enabling the construction of a dereferencing iterator utilizing the automated dedu..." alt="" coords="507,5,624,32"/><area shape="rect" id="node7" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="499,205,631,246"/><area shape="rect" id="node8" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="896,88,1123,115"/><area shape="rect" id="node10" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="495,153,636,180"/><area shape="rect" id="node14" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1389,234,1560,275"/><area shape="rect" id="node11" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="693,208,848,235"/><area shape="rect" id="node15" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="695,157,847,184"/><area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="924,205,1095,246"/><area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1171,205,1341,246"/><area shape="rect" id="node16" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="924,139,1095,181"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aed5ab68f123baedeb78d6c94920deb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of pair-wise greatest common sub types of the types in the two given sets. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00581">581</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8cpp_source.html#l00504">getGreatestCommonSubtypes()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                                                                      {</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="comment">// special cases</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keywordflow">if</span> (a.empty()) {</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    }</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="keywordflow">if</span> (b.empty()) {</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    }</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="keywordflow">if</span> (a.isAll()) {</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    }</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="keywordflow">if</span> (b.isAll()) {</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    }</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="comment">// compute pairwise greatest common sub types</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; x : a) {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; y : b) {</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;            res.insert(<a class="code" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a>(x, y));</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        }</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    }</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aed5ab68f123baedeb78d6c94920deb5d"><div class="ttname"><a href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise greatest common sub types of the types in the two given sets. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00581">TypeSystem.cpp:581</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph.png" border="0" usemap="#namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph" alt=""/></div>
<map name="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph" id="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="260,68,423,94"/><area shape="rect" id="node3" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="246,119,437,160"/><area shape="rect" id="node6" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="486,214,645,241"/><area shape="rect" id="node14" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="266,236,417,262"/><area shape="rect" id="node4" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="499,148,631,190"/><area shape="rect" id="node5" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="896,140,1123,166"/><area shape="rect" id="node7" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="495,97,636,124"/><area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1389,31,1560,72"/><area shape="rect" id="node8" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="693,198,848,225"/><area shape="rect" id="node12" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="695,97,847,124"/><area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="924,191,1095,232"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1171,74,1341,115"/><area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="924,74,1095,115"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a247fd46943465169ffe79f25628e5dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ast_transforms_8cpp.html#a32ecbd9872be86ec1594cff1d9698d99">std::map</a>&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, bool &gt; souffle::getGroundedTerms </td>
          <td>(</td>
          <td class="paramtype">const AstClause &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyse the given clause and computes for each contained argument whether it is a grounded value or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause to be analyzed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map mapping each contained argument to a boolean indicating whether the argument represents a grounded value or not </dd></dl>

<p>Definition at line <a class="el" href="_ast_type_analysis_8cpp_source.html#l00321">321</a> of file <a class="el" href="_ast_type_analysis_8cpp_source.html">AstTypeAnalysis.cpp</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_argument_8h_source.html#l00556">souffle::AstRecordInit::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00186">souffle::AstNegation::getAtom()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00257">souffle::AstConstraint::getLHS()</a>, <a class="el" href="_ast_literal_8h_source.html#l00267">souffle::AstConstraint::getOperator()</a>, <a class="el" href="_ast_literal_8h_source.html#l00262">souffle::AstConstraint::getRHS()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00169">lhs</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00170">rhs</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00701">usesInvalidWitness()</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                                                                           {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="comment">// define analysis ..</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keyword">struct </span>Analysis : <span class="keyword">public</span> AstConstraintAnalysis&lt;BoolDisjunctVar&gt; {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        std::set&lt;const AstAtom*&gt; ignore;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="comment">// #1 - atoms are producing grounded variables</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordtype">void</span> visitAtom(<span class="keyword">const</span> AstAtom&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            <span class="comment">// some atoms need to be skipped (head or negation)</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keywordflow">if</span> (ignore.find(&amp;cur) != ignore.end()) {</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            }</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            <span class="comment">// all arguments are grounded</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : cur.getArguments()) {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                addConstraint(isTrue(getVar(arg)));</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            }</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">// #2 - negations need to be skipped</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keywordtype">void</span> visitNegation(<span class="keyword">const</span> AstNegation&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            <span class="comment">// add nested atom to black-list</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            ignore.insert(cur.getAtom());</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        }</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="comment">// #3 - also skip head</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keywordtype">void</span> visitClause(<span class="keyword">const</span> AstClause&amp; clause)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            <span class="comment">// ignore head</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;            ignore.insert(clause.getHead());</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        }</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="comment">// #4 - binary equality relations propagates groundness</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        <span class="keywordtype">void</span> visitConstraint(<span class="keyword">const</span> AstConstraint&amp; cur)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            <span class="comment">// only target equality</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            <span class="keywordflow">if</span> (cur.getOperator() != BinaryConstraintOp::EQ) {</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            <span class="comment">// if equal, link right and left side</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = getVar(cur.getLHS());</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = getVar(cur.getRHS());</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;            addConstraint(imply(<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, rhs));</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            addConstraint(imply(rhs, <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>));</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        }</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="comment">// #5 - record init nodes</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <span class="keywordtype">void</span> visitRecordInit(<span class="keyword">const</span> AstRecordInit&amp; init)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            <span class="keyword">auto</span> cur = getVar(init);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            std::vector&lt;BoolDisjunctVar&gt; vars;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            <span class="comment">// if record is grounded, so are all its arguments</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : init.getArguments()) {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                <span class="keyword">auto</span> arg_var = getVar(arg);</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                addConstraint(imply(cur, arg_var));</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                vars.push_back(arg_var);</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            }</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="comment">// if all arguments are grounded, so is the record</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            addConstraint(imply(vars, cur));</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="comment">// #6 - constants are also sources of grounded values</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keywordtype">void</span> visitConstant(<span class="keyword">const</span> AstConstant&amp; c)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;            addConstraint(isTrue(getVar(c)));</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        }</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="comment">// #7 - aggregators are grounding values</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordtype">void</span> visitAggregator(<span class="keyword">const</span> AstAggregator&amp; c)<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            addConstraint(isTrue(getVar(c)));</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        }</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    };</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// run analysis on given clause</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">return</span> Analysis().analyse(clause);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;}</div>
<div class="ttc" id="_ast_transforms_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdoc">The two terms to be equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00169">AstTransforms.cpp:169</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00170">AstTransforms.cpp:170</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph.png" border="0" usemap="#namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph" alt=""/></div>
<map name="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph" id="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="235,5,445,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_record_init.html#ae516fe38512e96c666014acce207b983" title="souffle::AstRecordInit\l::getArguments" alt="" coords="265,57,415,98"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_negation.html#a0737c379dac1c350accecb1e2301698c" title="Returns the nested atom as the referenced atom. " alt="" coords="269,122,411,163"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="275,187,405,229"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="265,253,415,294"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="265,318,415,359"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="265,383,415,425"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="494,35,629,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae5266d9360a88847a65d1c581f778d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * souffle::getHeadRelation </td>
          <td>(</td>
          <td class="paramtype">const AstClause *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relation referenced by the head of the given clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced by the clause head </dd></dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00040">40</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_utils_8cpp_source.html#l00036">getAtomRelation()</a>, and <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>.</p>

<p>Referenced by <a class="el" href="_precedence_graph_8cpp_source.html#l00128">souffle::RecursiveClauses::computeIsRecursive()</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(clause-&gt;getHead(), program);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00036">AstUtils.cpp:36</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph.png" border="0" usemap="#namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph" alt=""/></div>
<map name="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph" id="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="222,35,389,61"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="240,86,371,127"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="437,5,619,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="459,57,597,98"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeddc699418d426e1ffcb965e37ccb3a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*&gt; souffle::getInlinedArgument </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstArgument *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of arguments that should replace the given argument after one step of inlining. </p>
<p>Note: This function is currently generalised to perform any required inlining within aggregators as well, making it simple to extend to this later on if desired (and the semantic check is removed). </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00474">474</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="_ast_argument_8h_source.html#l00552">souffle::AstRecordInit::add()</a>, <a class="el" href="_ast_argument_8h_source.html#l00704">souffle::AstAggregator::addBodyLiteral()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00452">combineAggregators()</a>, <a class="el" href="_ast_argument_8h_source.html#l00663">souffle::AstAggregator::count</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="_ast_argument_8h_source.html#l00663">souffle::AstAggregator::max</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="_ast_argument_8h_source.html#l00663">souffle::AstAggregator::min</a>, <a class="el" href="_ast_argument_8h_source.html#l00688">souffle::AstAggregator::setTargetExpression()</a>, and <a class="el" href="_ast_argument_8h_source.html#l00663">souffle::AstAggregator::sum</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00690">getInlinedAtom()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                                                                                             {</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    std::vector&lt;AstArgument*&gt; versions;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="comment">// Each argument has to be handled differently - essentially, want to go down to</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="comment">// nested aggregators, and inline their bodies if needed.</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstAggregator* aggr = dynamic_cast&lt;const AstAggregator*&gt;(arg)) {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="comment">// First try inlining the target expression if necessary</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions =</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                    <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, aggr-&gt;getTargetExpression());</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                <span class="comment">// An element in the target expression can be inlined!</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                <span class="comment">// Create a new aggregator per version of the target expression</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArg : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                    AstAggregator* newAggr = <span class="keyword">new</span> AstAggregator(aggr-&gt;getOperator());</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                    newAggr-&gt;setTargetExpression(std::unique_ptr&lt;AstArgument&gt;(newArg));</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                    <span class="keywordflow">for</span> (AstLiteral* lit : aggr-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                        newAggr-&gt;addBodyLiteral(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                    }</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                    versions.push_back(newAggr);</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        }</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="comment">// Try inlining body arguments if the target expression has not been changed.</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="comment">// (At this point we only handle one step of inlining at a time)</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            std::vector&lt;AstLiteral*&gt; bodyLiterals = aggr-&gt;getBodyLiterals();</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bodyLiterals.size(); i++) {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                AstLiteral* currLit = bodyLiterals[i];</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; literalVersions =</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                        <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, currLit);</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                <span class="keywordflow">if</span> (literalVersions.isValid()) {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                    <span class="comment">// Literal can be inlined!</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                    changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                    AstAggregator::Op op = aggr-&gt;getOperator();</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                    <span class="comment">// Create an aggregator (with the same operation) for each possible body</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                    std::vector&lt;AstAggregator*&gt; aggrVersions;</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                    <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; inlineVersions : literalVersions.getVector()) {</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                        AstAggregator* newAggr = <span class="keyword">new</span> AstAggregator(aggr-&gt;getOperator());</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                            newAggr-&gt;setTargetExpression(</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(aggr-&gt;getTargetExpression()-&gt;clone()));</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                        }</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                        <span class="comment">// Add in everything except the current literal being replaced</span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; bodyLiterals.size(); j++) {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                            <span class="keywordflow">if</span> (i != j) {</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                newAggr-&gt;addBodyLiteral(</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                                        std::unique_ptr&lt;AstLiteral&gt;(bodyLiterals[j]-&gt;clone()));</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                            }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                        }</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                        <span class="comment">// Add in everything new that replaces that literal</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                        <span class="keywordflow">for</span> (AstLiteral* addedLit : inlineVersions) {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                            newAggr-&gt;addBodyLiteral(std::unique_ptr&lt;AstLiteral&gt;(addedLit));</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                        }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                        aggrVersions.push_back(newAggr);</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                    }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                    <span class="comment">// Create the actual overall aggregator that ties the replacement aggregators together.</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                    <span class="keywordflow">if</span> (op == AstAggregator::min) {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                        <span class="comment">// min x : { a(x) }. &lt;=&gt; min ( min x : { a1(x) }, min x : { a2(x) }, ... )</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a>(aggrVersions, BinaryOp::MIN));</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op == AstAggregator::max) {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                        <span class="comment">// max x : { a(x) }. &lt;=&gt; max ( max x : { a1(x) }, max x : { a2(x) }, ... )</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a>(aggrVersions, BinaryOp::MAX));</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op == AstAggregator::count) {</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                        <span class="comment">// count : { a(x) }. &lt;=&gt; sum ( count : { a1(x) }, count : { a2(x) }, ... )</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a>(aggrVersions, BinaryOp::ADD));</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op == AstAggregator::sum) {</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                        <span class="comment">// sum x : { a(x) }. &lt;=&gt; sum ( sum x : { a1(x) }, sum x : { a2(x) }, ... )</span></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">combineAggregators</a>(aggrVersions, BinaryOp::ADD));</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported aggregator type&quot;</span>);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                    }</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                }</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;                <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                }</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            }</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        }</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;const AstFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="comment">// Each type of functor (unary, binary, ternary) must be handled differently.</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> AstUnaryFunctor* functor = dynamic_cast&lt;const AstUnaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions =</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                    <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getOperand());</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArg : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                    AstArgument* newFunctor =</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                            <span class="keyword">new</span> AstUnaryFunctor(functor-&gt;getFunction(), std::unique_ptr&lt;AstArgument&gt;(newArg));</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                    versions.push_back(newFunctor);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                }</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;            }</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> AstBinaryFunctor* functor = dynamic_cast&lt;const AstBinaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            NullableVector&lt;AstArgument*&gt; lhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getLHS());</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            <span class="keywordflow">if</span> (lhsVersions.isValid()) {</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newLhs : lhsVersions.getVector()) {</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                    AstArgument* newFunctor =</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                            <span class="keyword">new</span> AstBinaryFunctor(functor-&gt;getFunction(), std::unique_ptr&lt;AstArgument&gt;(newLhs),</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getRHS()-&gt;clone()));</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                    versions.push_back(newFunctor);</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                }</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                NullableVector&lt;AstArgument*&gt; rhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getRHS());</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                <span class="keywordflow">if</span> (rhsVersions.isValid()) {</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                    changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                    <span class="keywordflow">for</span> (AstArgument* newRhs : rhsVersions.getVector()) {</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                        AstArgument* newFunctor = <span class="keyword">new</span> AstBinaryFunctor(functor-&gt;getFunction(),</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getLHS()-&gt;clone()),</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(newRhs));</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                        versions.push_back(newFunctor);</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                    }</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                }</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;            }</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> AstTernaryFunctor* functor = dynamic_cast&lt;const AstTernaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;            NullableVector&lt;AstArgument*&gt; leftVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getArg(0));</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;            <span class="keywordflow">if</span> (leftVersions.isValid()) {</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newLeft : leftVersions.getVector()) {</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                    AstArgument* newFunctor = <span class="keyword">new</span> AstTernaryFunctor(functor-&gt;getFunction(),</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(newLeft),</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(1)-&gt;clone()),</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(2)-&gt;clone()));</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                    versions.push_back(newFunctor);</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                }</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                NullableVector&lt;AstArgument*&gt; middleVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getArg(1));</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                <span class="keywordflow">if</span> (middleVersions.isValid()) {</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                    changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                    <span class="keywordflow">for</span> (AstArgument* newMiddle : middleVersions.getVector()) {</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                        AstArgument* newFunctor = <span class="keyword">new</span> AstTernaryFunctor(functor-&gt;getFunction(),</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(0)-&gt;clone()),</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(newMiddle),</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(2)-&gt;clone()));</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                        versions.push_back(newFunctor);</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                    }</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                    NullableVector&lt;AstArgument*&gt; rightVersions =</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                            <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, functor-&gt;getArg(2));</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                    <span class="keywordflow">if</span> (rightVersions.isValid()) {</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                        changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                        <span class="keywordflow">for</span> (AstArgument* newRight : rightVersions.getVector()) {</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                            AstArgument* newFunctor = <span class="keyword">new</span> AstTernaryFunctor(functor-&gt;getFunction(),</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(0)-&gt;clone()),</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(functor-&gt;getArg(1)-&gt;clone()),</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(newRight));</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                            versions.push_back(newFunctor);</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                        }</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                    }</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                }</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;            }</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        }</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> AstTypeCast* cast = dynamic_cast&lt;const AstTypeCast*&gt;(arg)) {</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, cast-&gt;getValue());</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newArg : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                AstArgument* newTypeCast =</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                        <span class="keyword">new</span> AstTypeCast(std::unique_ptr&lt;AstArgument&gt;(newArg), cast-&gt;getType());</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                versions.push_back(newTypeCast);</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            }</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        }</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> AstRecordInit* record = dynamic_cast&lt;const AstRecordInit*&gt;(arg)) {</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        std::vector&lt;AstArgument*&gt; recordArguments = record-&gt;getArguments();</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; recordArguments.size(); i++) {</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            AstArgument* currentRecArg = recordArguments[i];</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, currentRecArg);</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArgumentVersion : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                    AstRecordInit* newRecordArg = <span class="keyword">new</span> AstRecordInit();</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; recordArguments.size(); j++) {</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                        <span class="keywordflow">if</span> (i == j) {</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                            newRecordArg-&gt;add(std::unique_ptr&lt;AstArgument&gt;(newArgumentVersion));</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                            newRecordArg-&gt;add(std::unique_ptr&lt;AstArgument&gt;(recordArguments[j]-&gt;clone()));</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                        }</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                    }</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                    versions.push_back(newRecordArg);</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;            }</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;            <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            }</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        }</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    }</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstArgument*&gt;(versions);</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        <span class="comment">// Return an invalid vector - no inlining has occurred</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstArgument*&gt;();</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    }</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a7bd6c596547a92b9afdb621eb8a89c91"><div class="ttname"><a href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91">souffle::combineAggregators</a></div><div class="ttdeci">AstArgument * combineAggregators(std::vector&lt; AstAggregator * &gt; aggrs, BinaryOp fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00452">InlineRelationsTransformer.cpp:452</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00474">InlineRelationsTransformer.cpp:474</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00738">InlineRelationsTransformer.cpp:738</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph.png" border="0" usemap="#namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph" alt=""/></div>
<map name="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph" id="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_record_init.html#ab1b4b5d5d7eddbc0cfccc6b0bfdb4927" title="souffle::AstRecordInit::add" alt="" coords="240,5,419,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_aggregator.html#a2161c1a7c4db052e0f8924dacc8a1470" title="souffle::AstAggregator\l::addBodyLiteral" alt="" coords="253,57,405,98"/><area shape="rect" id="node4" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91" title="souffle::combineAggregators" alt="" coords="235,123,423,149"/><area shape="rect" id="node7" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="249,552,409,579"/><area shape="rect" id="node23" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="989,421,1144,462"/><area shape="rect" id="node24" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="989,851,1144,893"/><area shape="rect" id="node45" href="classsouffle_1_1_ast_aggregator.html#ac2f31fe3ca9c5ee4f99b32f375669c12" title="souffle::AstAggregator\l::setTargetExpression" alt="" coords="253,1063,405,1105"/><area shape="rect" id="node5" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="482,123,649,149"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="733,123,891,149"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="743,510,881,551"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_relation.html#a337a8e26fdf7e036a3be3b20b7f04880" title="Check whether relation is an inlined relation. " alt="" coords="497,545,634,586"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="743,209,881,250"/><area shape="rect" id="node12" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f" title="Inlines the given atom based on a given clause. " alt="" coords="727,676,897,703"/><area shape="rect" id="node26" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="734,275,890,301"/><area shape="rect" id="node30" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="1233,940,1410,967"/><area shape="rect" id="node31" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="472,793,659,820"/><area shape="rect" id="node41" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="491,610,640,651"/><area shape="rect" id="node42" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="491,727,640,769"/><area shape="rect" id="node43" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="491,895,640,937"/><area shape="rect" id="node44" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="493,377,638,418"/><area shape="rect" id="node11" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1503,268,1638,295"/><area shape="rect" id="node13" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1001,734,1132,775"/><area shape="rect" id="node17" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="1001,669,1132,710"/><area shape="rect" id="node18" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="999,487,1134,513"/><area shape="rect" id="node22" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="1001,538,1132,579"/><area shape="rect" id="node25" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1001,603,1132,645"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="1256,558,1387,599"/><area shape="rect" id="node15" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="1477,695,1664,721"/><area shape="rect" id="node16" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1255,675,1387,717"/><area shape="rect" id="node19" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="1217,319,1426,345"/><area shape="rect" id="node20" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="1233,487,1410,513"/><area shape="rect" id="node21" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1525,487,1616,513"/><area shape="rect" id="node27" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1242,624,1401,651"/><area shape="rect" id="node29" href="classsouffle_1_1_ast_atom.html#a307a256c48b3911464bae97c8dc1307d" title="Replace the argument at the given index with the given argument. " alt="" coords="965,268,1168,295"/><area shape="rect" id="node28" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="1481,624,1660,651"/><area shape="rect" id="node32" href="namespacesouffle.html#a190c528007c7083a21c340006061986d" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="707,743,917,769"/><area shape="rect" id="node40" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="721,844,903,871"/><area shape="rect" id="node33" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="995,800,1138,827"/><area shape="rect" id="node34" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1247,793,1396,834"/><area shape="rect" id="node37" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="1247,863,1396,905"/><area shape="rect" id="node35" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="1496,746,1645,787"/><area shape="rect" id="node36" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="1477,812,1664,839"/><area shape="rect" id="node38" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="1496,863,1645,905"/><area shape="rect" id="node39" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="1475,929,1667,956"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8ae2dc0fd43bd8abb26027c3f2f448d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a>*&gt; souffle::getInlinedAtom </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstAtom &amp;&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of atoms that should replace the given atom after one step of inlining. </p>
<p>Assumes the relation the atom belongs to is not inlined itself. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00690">690</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00137">souffle::AstAtom::clone()</a>, <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00474">getInlinedArgument()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>, and <a class="el" href="_ast_literal_8h_source.html#l00105">souffle::AstAtom::setArgument()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00863">getInlinedClause()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                                                                            {</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    std::vector&lt;AstAtom*&gt; versions;</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    <span class="comment">// Try to inline each of the atom&#39;s arguments</span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    std::vector&lt;AstArgument*&gt; arguments = atom.getArguments();</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arguments.size(); i++) {</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;        AstArgument* arg = arguments[i];</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, arg);</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            <span class="comment">// Argument has replacements</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;            <span class="comment">// Create a new atom per new version of the argument</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newArgument : argumentVersions.getVector()) {</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;                AstAtom* newAtom = atom.clone();</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                newAtom-&gt;setArgument(i, std::unique_ptr&lt;AstArgument&gt;(newArgument));</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                versions.push_back(newAtom);</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;            }</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;        }</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;        }</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    }</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstAtom*&gt;(versions);</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        <span class="comment">// Return an invalid vector - no replacements need to be made</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstAtom*&gt;();</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    }</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00474">InlineRelationsTransformer.cpp:474</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph.png" border="0" usemap="#namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph" alt=""/></div>
<map name="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph" id="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1421,508,1579,535"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="1395,5,1605,32"/><area shape="rect" id="node7" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="221,441,403,468"/><area shape="rect" id="node26" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="1192,369,1347,410"/><area shape="rect" id="node27" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="1192,827,1347,869"/><area shape="rect" id="node45" href="classsouffle_1_1_ast_atom.html#a307a256c48b3911464bae97c8dc1307d" title="Replace the argument at the given index with the given argument. " alt="" coords="211,543,413,569"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="1660,508,1839,535"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="1656,559,1843,585"/><area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1682,31,1817,57"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_record_init.html#ab1b4b5d5d7eddbc0cfccc6b0bfdb4927" title="souffle::AstRecordInit::add" alt="" coords="467,500,645,527"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_aggregator.html#a2161c1a7c4db052e0f8924dacc8a1470" title="souffle::AstAggregator\l::addBodyLiteral" alt="" coords="480,369,632,410"/><area shape="rect" id="node10" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91" title="souffle::combineAggregators" alt="" coords="462,239,650,265"/><area shape="rect" id="node13" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="476,551,636,577"/><area shape="rect" id="node44" href="classsouffle_1_1_ast_aggregator.html#ac2f31fe3ca9c5ee4f99b32f375669c12" title="souffle::AstAggregator\l::setTargetExpression" alt="" coords="480,434,632,475"/><area shape="rect" id="node11" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="709,212,875,239"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="959,208,1118,235"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="969,439,1108,481"/><area shape="rect" id="node15" href="classsouffle_1_1_ast_relation.html#a337a8e26fdf7e036a3be3b20b7f04880" title="Check whether relation is an inlined relation. " alt="" coords="723,718,861,759"/><area shape="rect" id="node16" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="970,259,1107,301"/><area shape="rect" id="node17" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f" title="Inlines the given atom based on a given clause. " alt="" coords="953,595,1124,621"/><area shape="rect" id="node29" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="1411,905,1589,932"/><area shape="rect" id="node30" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="699,784,885,811"/><area shape="rect" id="node40" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="717,886,867,927"/><area shape="rect" id="node41" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="717,470,867,511"/><area shape="rect" id="node42" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="717,535,867,577"/><area shape="rect" id="node43" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="719,601,865,642"/><area shape="rect" id="node18" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1204,653,1335,694"/><area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="1204,457,1335,498"/><area shape="rect" id="node22" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1202,107,1337,133"/><area shape="rect" id="node25" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="1204,522,1335,563"/><area shape="rect" id="node28" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1204,587,1335,629"/><area shape="rect" id="node19" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="1435,610,1565,651"/><area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1434,675,1566,717"/><area shape="rect" id="node23" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="1411,107,1589,133"/><area shape="rect" id="node24" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1704,107,1795,133"/><area shape="rect" id="node31" href="namespacesouffle.html#a190c528007c7083a21c340006061986d" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="934,733,1143,760"/><area shape="rect" id="node39" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="948,683,1129,709"/><area shape="rect" id="node32" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1198,748,1341,775"/><area shape="rect" id="node33" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1425,741,1575,782"/><area shape="rect" id="node36" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="1425,806,1575,847"/><area shape="rect" id="node34" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="1675,683,1824,725"/><area shape="rect" id="node35" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="1656,749,1843,776"/><area shape="rect" id="node37" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="1675,803,1824,845"/><area shape="rect" id="node38" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="1653,869,1845,896"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac4639aeb42a36253468c45df580e18bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a>*&gt; souffle::getInlinedClause </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstClause &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of clauses that should replace the given clause after one step of inlining. </p>
<p>If no inlining can occur, the list will only contain a clone of the original clause. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00863">863</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_clause_8cpp_source.html#l00038">souffle::AstClause::addToBody()</a>, <a class="el" href="_ast_clause_8h_source.html#l00377">souffle::AstClause::clone()</a>, <a class="el" href="_ast_clause_8h_source.html#l00413">souffle::AstClause::cloneHead()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00068">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00690">getInlinedAtom()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>, <a class="el" href="_ast_node_8h_source.html#l00047">souffle::AstNode::getSrcLoc()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00051">souffle::AstClause::setHead()</a>, and <a class="el" href="_ast_node_8h_source.html#l00052">souffle::AstNode::setSrcLoc()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00954">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    std::vector&lt;AstClause*&gt; versions;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    <span class="comment">// Try to inline things contained in the arguments of the head first.</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    <span class="comment">// E.g. `a(x, max y : { b(y) }) :- c(x).`, where b should be inlined.</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    AstAtom* head = clause.getHead();</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    NullableVector&lt;AstAtom*&gt; headVersions = <a class="code" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a>(program, *head);</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    <span class="keywordflow">if</span> (headVersions.isValid()) {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        <span class="comment">// The head atom can be inlined!</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        <span class="comment">// Produce the new clauses with the replacement head atoms</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        <span class="keywordflow">for</span> (AstAtom* newHead : headVersions.getVector()) {</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;            AstClause* newClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            newClause-&gt;setSrcLoc(clause.getSrcLoc());</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            newClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(newHead));</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="comment">// The body will remain unchanged</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : clause.getBodyLiterals()) {</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                newClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;            }</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;            versions.push_back(newClause);</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;        }</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    }</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="comment">// Only perform one stage of inlining at a time.</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    <span class="comment">// If the head atoms did not need inlining, try inlining atoms nested in the body.</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        std::vector&lt;AstLiteral*&gt; bodyLiterals = clause.getBodyLiterals();</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bodyLiterals.size(); i++) {</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;            AstLiteral* currLit = bodyLiterals[i];</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;            <span class="comment">// Three possible cases when trying to inline a literal:</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;            <span class="comment">//  1) The literal itself may be directly inlined. In this case, the atom can be replaced</span></div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;            <span class="comment">//    with multiple different bodies, as the inlined atom may have several rules.</span></div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;            <span class="comment">//  2) Otherwise, the literal itself may not need to be inlined, but a subnode (e.g. an argument)</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;            <span class="comment">//    may need to be inlined. In this case, an altered literal must replace the original.</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;            <span class="comment">//    Again, several possible versions may exist, as the inlined relation may have several rules.</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;            <span class="comment">//  3) The literal does not depend on any inlined relations, and so does not need to be changed.</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;            NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; litVersions = <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, currLit);</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;            <span class="keywordflow">if</span> (litVersions.isValid()) {</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                <span class="comment">// Case 1 and 2: Inlining has occurred!</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                <span class="comment">// The literal may be replaced with several different bodies.</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                <span class="comment">// Create a new clause for each possible version.</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; bodyVersions = litVersions.getVector();</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;                <span class="comment">// Create the base clause with the current literal removed</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;                <span class="keyword">auto</span> baseClause = std::unique_ptr&lt;AstClause&gt;(clause.cloneHead());</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                <span class="keywordflow">for</span> (AstLiteral* oldLit : bodyLiterals) {</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                    <span class="keywordflow">if</span> (currLit != oldLit) {</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;                        baseClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(oldLit-&gt;clone()));</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                    }</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                }</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; body : bodyVersions) {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                    AstClause* replacementClause = baseClause-&gt;clone();</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                    <span class="comment">// Add in the current set of literals replacing the inlined literal</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                    <span class="comment">// In Case 2, each body contains exactly one literal</span></div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                    <span class="keywordflow">for</span> (AstLiteral* newLit : body) {</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                        replacementClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(newLit));</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;                    }</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                    versions.push_back(replacementClause);</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                }</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            }</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="comment">// Only replace at most one literal per iteration</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            }</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;        }</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    }</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;        <span class="comment">// Case 3: No inlining changes, so a clone of the original should be returned</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;        std::vector&lt;AstClause*&gt; ret;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        ret.push_back(clause.clone());</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;        <span class="comment">// Inlining changes, so return the replacement clauses.</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        <span class="keywordflow">return</span> versions;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    }</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8ae2dc0fd43bd8abb26027c3f2f448d1"><div class="ttname"><a href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">souffle::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; AstAtom * &gt; getInlinedAtom(AstProgram &amp;program, AstAtom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00690">InlineRelationsTransformer.cpp:690</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00738">InlineRelationsTransformer.cpp:738</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph.png" border="0" usemap="#namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph" alt=""/></div>
<map name="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph" id="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#aa9da90d931189d440bbe7b256e554f8d" title="Add a Literal to the body of the clause. " alt="" coords="235,6,365,47"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1427,473,1557,514"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="1883,480,2069,507"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a6c598326d12aa0ca9af63282c0f1fe23" title="clone head generates a new clause with the same head but empty body " alt="" coords="1189,414,1320,455"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="1883,656,2069,683"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_clause.html#a07290e1b7b9e4ce73c3a5f0482ce88d3" title="Set the head of clause to h. " alt="" coords="1427,590,1557,631"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="1427,707,1557,749"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1427,773,1557,814"/><area shape="rect" id="node15" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="222,1280,378,1307"/><area shape="rect" id="node26" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="692,1305,852,1332"/><area shape="rect" id="node35" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="1415,1811,1569,1853"/><area shape="rect" id="node36" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="1415,1546,1569,1587"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="1664,414,1795,455"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1663,261,1795,302"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#ab60415570b29118f4a476bcecb58bc7c" title="Updates the execution plan associated to this clause. " alt="" coords="1426,225,1558,266"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_clause.html#a586a48936277bdb61b6fbb5619a7abcb" title="Updates the fixed execution order flag. " alt="" coords="1410,290,1574,331"/><area shape="rect" id="node13" href="classsouffle_1_1_ast_clause.html#a9ffbaaeaeac8f4b5a690a7c7bcea748c" title="Determines whether the execution order plan is fixed. " alt="" coords="1409,355,1575,397"/><area shape="rect" id="node16" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1650,739,1809,765"/><area shape="rect" id="node18" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="1625,1007,1834,1033"/><area shape="rect" id="node20" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="437,1735,619,1761"/><area shape="rect" id="node50" href="classsouffle_1_1_ast_atom.html#a307a256c48b3911464bae97c8dc1307d" title="Replace the argument at the given index with the given argument. " alt="" coords="427,1255,629,1281"/><area shape="rect" id="node17" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="1887,739,2065,765"/><area shape="rect" id="node19" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1909,1032,2043,1059"/><area shape="rect" id="node21" href="classsouffle_1_1_ast_record_init.html#ab1b4b5d5d7eddbc0cfccc6b0bfdb4927" title="souffle::AstRecordInit::add" alt="" coords="683,1793,861,1820"/><area shape="rect" id="node22" href="classsouffle_1_1_ast_aggregator.html#a2161c1a7c4db052e0f8924dacc8a1470" title="souffle::AstAggregator\l::addBodyLiteral" alt="" coords="696,1845,848,1886"/><area shape="rect" id="node23" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91" title="souffle::combineAggregators" alt="" coords="678,1911,866,1937"/><area shape="rect" id="node49" href="classsouffle_1_1_ast_aggregator.html#ac2f31fe3ca9c5ee4f99b32f375669c12" title="souffle::AstAggregator\l::setTargetExpression" alt="" coords="696,1727,848,1769"/><area shape="rect" id="node24" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="925,1911,1091,1937"/><area shape="rect" id="node25" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="1175,1911,1334,1937"/><area shape="rect" id="node27" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="1185,1139,1324,1181"/><area shape="rect" id="node28" href="classsouffle_1_1_ast_relation.html#a337a8e26fdf7e036a3be3b20b7f04880" title="Check whether relation is an inlined relation. " alt="" coords="939,1239,1077,1281"/><area shape="rect" id="node29" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="1186,1205,1323,1246"/><area shape="rect" id="node30" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f" title="Inlines the given atom based on a given clause. " alt="" coords="1169,889,1340,916"/><area shape="rect" id="node37" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="1641,1383,1818,1409"/><area shape="rect" id="node38" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="915,1356,1101,1383"/><area shape="rect" id="node45" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="933,1458,1083,1499"/><area shape="rect" id="node46" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="933,991,1083,1033"/><area shape="rect" id="node47" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="933,1057,1083,1098"/><area shape="rect" id="node48" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="935,1122,1081,1163"/><area shape="rect" id="node31" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="1427,941,1557,982"/><area shape="rect" id="node32" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1425,889,1559,916"/><area shape="rect" id="node33" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="1641,889,1818,916"/><area shape="rect" id="node34" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1931,889,2021,916"/><area shape="rect" id="node39" href="namespacesouffle.html#a190c528007c7083a21c340006061986d" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="1150,1271,1359,1297"/><area shape="rect" id="node44" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="1164,1321,1345,1348"/><area shape="rect" id="node40" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1421,1232,1563,1259"/><area shape="rect" id="node41" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="1655,790,1804,831"/><area shape="rect" id="node43" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="1655,1225,1804,1266"/><area shape="rect" id="node42" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="1901,790,2051,831"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a25b07f1c5efea50145140a31f755e0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt; souffle::getInlinedLiteral </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstLiteral *&#160;</td>
          <td class="paramname"><em>lit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to perform a single step of inlining on the given literal. </p>
<p>Returns a pair of nullable vectors (v, w) such that:</p>
<ul>
<li>v is valid if and only if the literal can be directly inlined, whereby it contains the bodies that replace it</li>
<li>if v is not valid, then w is valid if and only if the literal cannot be inlined directly, but contains a subargument that can be. In this case, it will contain the versions that will replace it.</li>
<li>If both are invalid, then no more inlining can occur on this literal and we are done. </li>
</ul>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">738</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8">souffle::AstArgument::clone()</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00371">formNegatedLiterals()</a>, <a class="el" href="_ast_literal_8h_source.html#l00090">souffle::AstAtom::getAtom()</a>, <a class="el" href="_ast_relation_8h_source.html#l00302">souffle::AstRelation::getClauses()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00474">getInlinedArgument()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00690">getInlinedAtom()</a>, <a class="el" href="_ast_literal_8h_source.html#l00257">souffle::AstConstraint::getLHS()</a>, <a class="el" href="_ast_literal_8h_source.html#l00267">souffle::AstConstraint::getOperator()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>, <a class="el" href="_ast_literal_8h_source.html#l00262">souffle::AstConstraint::getRHS()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00238">inlineBodyLiterals()</a>, <a class="el" href="_ast_relation_8h_source.html#l00194">souffle::AstRelation::isInline()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00474">getInlinedArgument()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00863">getInlinedClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                                                                                               {</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    <span class="keywordtype">bool</span> inlined = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; addedBodyLiterals;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    std::vector&lt;AstLiteral*&gt; versions;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="keywordflow">if</span> (AstAtom* atom = dynamic_cast&lt;AstAtom*&gt;(lit)) {</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        <span class="comment">// Check if this atom is meant to be inlined</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        AstRelation* rel = program.getRelation(atom-&gt;getName());</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;isInline()) {</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            <span class="comment">// We found an atom in the clause that needs to be inlined!</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            <span class="comment">// The clause needs to be replaced</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;            <span class="comment">// N new clauses should be formed, where N is the number of clauses</span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            <span class="comment">// associated with the inlined relation</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            <span class="keywordflow">for</span> (AstClause* inClause : rel-&gt;getClauses()) {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                <span class="comment">// Form the replacement clause</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                std::pair&lt;NullableVector&lt;AstLiteral*&gt;, std::vector&lt;AstConstraint*&gt;&gt; inlineResult =</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                        <a class="code" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f">inlineBodyLiterals</a>(atom, inClause);</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                NullableVector&lt;AstLiteral*&gt; replacementBodyLiterals = inlineResult.first;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                std::vector&lt;AstConstraint*&gt; currConstraints = inlineResult.second;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                    <span class="comment">// Failed to unify the atoms! We can skip this one...</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                }</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                <span class="comment">// Unification successful - the returned vector of literals represents one possible body</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                <span class="comment">// replacement We can add in the unification constraints as part of these literals.</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                std::vector&lt;AstLiteral*&gt; bodyResult = replacementBodyLiterals.getVector();</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                <span class="keywordflow">for</span> (AstConstraint* cons : currConstraints) {</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                    bodyResult.push_back(cons);</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                }</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                addedBodyLiterals.push_back(bodyResult);</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            }</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            <span class="comment">// Not meant to be inlined, but a subargument may be</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            NullableVector&lt;AstAtom*&gt; atomVersions = <a class="code" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a>(program, *atom);</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            <span class="keywordflow">if</span> (atomVersions.isValid()) {</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                <span class="comment">// Subnode needs to be inlined, so we have a vector of replacement atoms</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                <span class="keywordflow">for</span> (AstAtom* newAtom : atomVersions.getVector()) {</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                    versions.push_back(newAtom);</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                }</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            }</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        }</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AstNegation* neg = dynamic_cast&lt;AstNegation*&gt;(lit)) {</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        <span class="comment">// For negations, check the corresponding atom</span></div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        AstAtom* atom = neg-&gt;getAtom();</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; atomVersions = <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, atom);</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;            <span class="comment">// The atom can be inlined</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            <span class="keywordflow">if</span> (atomVersions.getVector().empty()) {</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                <span class="comment">// No clauses associated with the atom, so just becomes a true literal</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                std::vector&lt;AstLiteral*&gt; trueBody;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                trueBody.push_back(<span class="keyword">new</span> AstConstraint(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                        std::make_unique&lt;AstNumberConstant&gt;(1), std::make_unique&lt;AstNumberConstant&gt;(1)));</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                addedBodyLiterals.push_back(trueBody);</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                <span class="comment">// Suppose an atom a(x) is inlined and has the following rules:</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                <span class="comment">//  - a(x) :- a11(x), a12(x).</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                <span class="comment">//  - a(x) :- a21(x), a22(x).</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;                <span class="comment">// Then, a(x) &lt;- (a11(x) ^ a12(x)) v (a21(x) ^ a22(x))</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) v !a12(x)) ^ (!a21(x) v !a22(x))</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) ^ !a21(x)) v (!a11(x) ^ !a22(x)) v ...</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                <span class="comment">// Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is a</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                <span class="comment">// negated literal in the ith rule of a.</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                addedBodyLiterals = <a class="code" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">formNegatedLiterals</a>(program, atom);</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;            }</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        }</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        AstConstraint* constraint = <span class="keyword">dynamic_cast&lt;</span>AstConstraint*<span class="keyword">&gt;</span>(lit);</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        NullableVector&lt;AstArgument*&gt; lhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, constraint-&gt;getLHS());</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        <span class="keywordflow">if</span> (lhsVersions.isValid()) {</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newLhs : lhsVersions.getVector()) {</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                AstLiteral* newLit =</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                        <span class="keyword">new</span> AstConstraint(constraint-&gt;getOperator(), std::unique_ptr&lt;AstArgument&gt;(newLhs),</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(constraint-&gt;getRHS()-&gt;clone()));</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                versions.push_back(newLit);</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;            }</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            NullableVector&lt;AstArgument*&gt; rhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, constraint-&gt;getRHS());</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            <span class="keywordflow">if</span> (rhsVersions.isValid()) {</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newRhs : rhsVersions.getVector()) {</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                    AstLiteral* newLit = <span class="keyword">new</span> AstConstraint(constraint-&gt;getOperator(),</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(constraint-&gt;getLHS()-&gt;clone()),</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(newRhs));</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                    versions.push_back(newLit);</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                }</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            }</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;        }</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    }</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;        <span class="comment">// Not inlined directly but found replacement literals</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;        <span class="comment">// Rewrite these as single-literal bodies</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* version : versions) {</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;            std::vector&lt;AstLiteral*&gt; newBody;</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;            newBody.push_back(version);</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;            addedBodyLiterals.push_back(newBody);</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        }</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        inlined = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    }</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    <span class="keywordflow">if</span> (inlined) {</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt;(addedBodyLiterals);</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt;();</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    }</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a2e5ef82376f71d4d7ebfcfa64437d540"><div class="ttname"><a href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">souffle::formNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; formNegatedLiterals(AstProgram &amp;program, AstAtom *atom)</div><div class="ttdoc">Forms the bodies that will replace the negation of a given inlined atom. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00371">InlineRelationsTransformer.cpp:371</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00474">InlineRelationsTransformer.cpp:474</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8ae2dc0fd43bd8abb26027c3f2f448d1"><div class="ttname"><a href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">souffle::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; AstAtom * &gt; getInlinedAtom(AstProgram &amp;program, AstAtom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00690">InlineRelationsTransformer.cpp:690</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00738">InlineRelationsTransformer.cpp:738</a></div></div>
<div class="ttc" id="namespacesouffle_html_acd0dfc0a494a70a89da974a472e7b23f"><div class="ttname"><a href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f">souffle::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; AstLiteral * &gt;, std::vector&lt; AstConstraint * &gt; &gt; inlineBodyLiterals(AstAtom *atom, AstClause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00238">InlineRelationsTransformer.cpp:238</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph.png" border="0" usemap="#namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph" alt=""/></div>
<map name="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph" id="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="234,5,379,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="213,340,400,367"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="961,71,1138,97"/><area shape="rect" id="node17" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="484,122,623,163"/><area shape="rect" id="node18" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="724,581,879,622"/><area shape="rect" id="node19" href="namespacesouffle.html#acd0dfc0a494a70a89da974a472e7b23f" title="Inlines the given atom based on a given clause. " alt="" coords="468,340,639,367"/><area shape="rect" id="node30" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="724,646,879,687"/><area shape="rect" id="node32" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="485,934,622,975"/><area shape="rect" id="node33" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="463,796,644,823"/><area shape="rect" id="node40" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="229,593,385,620"/><area shape="rect" id="node42" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="232,770,381,811"/><area shape="rect" id="node43" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="232,835,381,877"/><area shape="rect" id="node44" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="232,901,381,942"/><area shape="rect" id="node45" href="classsouffle_1_1_ast_relation.html#a337a8e26fdf7e036a3be3b20b7f04880" title="Check whether relation is an inlined relation. " alt="" coords="238,966,375,1007"/><area shape="rect" id="node4" href="namespacesouffle.html#a190c528007c7083a21c340006061986d" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="449,188,658,215"/><area shape="rect" id="node16" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="463,239,644,265"/><area shape="rect" id="node5" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="730,165,873,192"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="970,253,1129,280"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="975,187,1124,229"/><area shape="rect" id="node13" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="975,122,1124,163"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="1209,356,1388,383"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="1205,305,1392,332"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="1224,239,1373,281"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="1205,188,1392,215"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="1224,122,1373,163"/><area shape="rect" id="node15" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="1203,71,1395,97"/><area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="736,463,867,505"/><area shape="rect" id="node23" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="736,333,867,374"/><area shape="rect" id="node24" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="734,529,869,556"/><area shape="rect" id="node29" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="736,398,867,439"/><area shape="rect" id="node31" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="736,267,867,309"/><area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="984,398,1115,439"/><area shape="rect" id="node22" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="983,463,1115,505"/><area shape="rect" id="node25" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="945,728,1154,755"/><area shape="rect" id="node27" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="961,529,1138,556"/><area shape="rect" id="node26" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1231,820,1366,847"/><area shape="rect" id="node28" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1253,529,1344,556"/><area shape="rect" id="node34" href="classsouffle_1_1_ast_record_init.html#ab1b4b5d5d7eddbc0cfccc6b0bfdb4927" title="souffle::AstRecordInit::add" alt="" coords="712,779,891,805"/><area shape="rect" id="node35" href="classsouffle_1_1_ast_aggregator.html#a2161c1a7c4db052e0f8924dacc8a1470" title="souffle::AstAggregator\l::addBodyLiteral" alt="" coords="725,830,877,871"/><area shape="rect" id="node36" href="namespacesouffle.html#a7bd6c596547a92b9afdb621eb8a89c91" title="souffle::combineAggregators" alt="" coords="707,961,895,988"/><area shape="rect" id="node39" href="classsouffle_1_1_ast_aggregator.html#ac2f31fe3ca9c5ee4f99b32f375669c12" title="souffle::AstAggregator\l::setTargetExpression" alt="" coords="725,895,877,937"/><area shape="rect" id="node37" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="966,961,1133,988"/><area shape="rect" id="node38" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="1219,961,1378,988"/><area shape="rect" id="node41" href="classsouffle_1_1_ast_atom.html#a307a256c48b3911464bae97c8dc1307d" title="Replace the argument at the given index with the given argument. " alt="" coords="452,695,655,721"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7814a3034094392e5744454c68463cc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_souffle_program.html">souffle::SouffleProgram</a>* souffle::getInstance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_compiled_souffle_8h_source.html#l00042">42</a> of file <a class="el" href="_compiled_souffle_8h_source.html">CompiledSouffle.h</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance()</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                         {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance</a>(<a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div>
<div class="ttc" id="classsouffle_1_1_program_factory_html_aeeb8c8fa86018f5f19cf6d419acdec54"><div class="ttname"><a href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance</a></div><div class="ttdeci">virtual SouffleProgram * newInstance()=0</div><div class="ttdoc">Create new instance (abstract) </div></div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph.png" border="0" usemap="#namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph" alt=""/></div>
<map name="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph" id="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54" title="Create new instance (abstract) " alt="" coords="192,5,355,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8aecaefb22443dc01bb4c208cb6aabdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of the two given types. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00410">410</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00885">any_of()</a>, <a class="el" href="_type_system_8cpp_source.html#l00103">souffle::TypeEnvironment::getAllTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00059">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, <a class="el" href="_type_system_8cpp_source.html#l00365">isSubtypeOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00084">souffle::TypeEnvironment::isType()</a>.</p>

<p>Referenced by <a class="el" href="_type_system_8cpp_source.html#l00448">getLeastCommonSupertypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                                                               {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// make sure they are in the same type environment</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    assert(a.getTypeEnvironment().isType(a) &amp;&amp; a.getTypeEnvironment().isType(b));</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="comment">// if they are equal it is easy</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span> (a == b) {</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// equally simple - check whether one is a sub-type of the other</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, b)) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        <span class="keywordflow">return</span> TypeSet(b);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(b, a)) {</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    }</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// harder: no obvious relation =&gt; hard way</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    TypeSet superTypes;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    TypeSet all = a.getTypeEnvironment().getAllTypes();</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : all) {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, cur) &amp;&amp; <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(b, cur)) {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            superTypes.insert(cur);</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        }</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    }</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="comment">// filter out non-least super types</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : superTypes) {</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordtype">bool</span> least = !<a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(superTypes, [&amp;](<span class="keyword">const</span> Type&amp; t) { <span class="keywordflow">return</span> t != cur &amp;&amp; <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(t, cur); });</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">if</span> (least) {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            res.insert(cur);</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00885">Util.h:885</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00365">TypeSystem.cpp:365</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph.png" border="0" usemap="#namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph" alt=""/></div>
<map name="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph" id="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="325,5,433,32"/><area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#ac49e87c8c261866e2496381c776539e6" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="293,107,464,149"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="513,85,671,112"/><area shape="rect" id="node5" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="720,216,947,243"/><area shape="rect" id="node6" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="308,249,449,276"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1213,362,1384,403"/><area shape="rect" id="node7" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="515,275,669,301"/><area shape="rect" id="node11" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="516,325,668,352"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="748,267,919,309"/><area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="995,333,1165,374"/><area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="748,333,919,374"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3e40a76eef0a150ef9c20743b95f589e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of all the types in the given set. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00448">448</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00253">souffle::TypeSet::begin()</a>, <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00259">souffle::TypeSet::end()</a>, <a class="el" href="_type_system_8cpp_source.html#l00410">getLeastCommonSupertypes()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                                                     {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="comment">// handle the empty set</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordflow">if</span> (set.empty()) {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        <span class="keywordflow">return</span> set;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    }</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="comment">// handle the all set =&gt; empty set (since no common super-type)</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="keywordflow">if</span> (set.isAll()) {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        <span class="keywordflow">return</span> TypeSet();</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keyword">auto</span> it = set.begin();</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    res.insert(*it);</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    ++it;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="comment">// refine sub-set step by step</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">for</span> (; it != set.end(); ++it) {</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        TypeSet tmp;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : res) {</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            tmp.insert(<a class="code" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a>(cur, *it));</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        }</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        res = tmp;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    }</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="comment">// done</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8e5fe6f4fe0781dfc619f8640a1631d3"><div class="ttname"><a href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise least common super types of the types in the two given sets. ...</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00478">TypeSystem.cpp:478</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph.png" border="0" usemap="#namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph" alt=""/></div>
<map name="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph" id="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a427bee6bd39217158b0aef0410b1008c" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="335,31,492,57"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="332,151,495,177"/><area shape="rect" id="node5" href="structsouffle_1_1_type_set.html#ac8828a4e976429c7f9d92ced14f15863" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="340,88,487,115"/><area shape="rect" id="node6" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="294,201,533,228"/><area shape="rect" id="node9" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="801,348,959,375"/><area shape="rect" id="node18" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="338,449,489,476"/><area shape="rect" id="node3" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5" title="A factory function enabling the construction of a dereferencing iterator utilizing the automated dedu..." alt="" coords="608,5,725,32"/><area shape="rect" id="node7" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="613,56,721,83"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#ac49e87c8c261866e2496381c776539e6" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="581,282,752,323"/><area shape="rect" id="node10" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="1008,196,1235,223"/><area shape="rect" id="node11" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="596,180,737,207"/><area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1501,101,1672,142"/><area shape="rect" id="node12" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="803,231,957,257"/><area shape="rect" id="node16" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="804,129,956,156"/><area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1036,247,1207,289"/><area shape="rect" id="node14" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1283,130,1453,171"/><area shape="rect" id="node17" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1036,130,1207,171"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af8c7047c228f5d77f45d8f3954a6f1d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of the given types. </p>

<p>Definition at line <a class="el" href="_type_system_8h_source.html#l00458">458</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p>References <a class="el" href="_type_system_8cpp_source.html#l00410">getLeastCommonSupertypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                                                        {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af8c7047c228f5d77f45d8f3954a6f1d2">getLeastCommonSupertypes</a>(TypeSet(<a class="code" href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>...));</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_af8c7047c228f5d77f45d8f3954a6f1d2"><div class="ttname"><a href="namespacesouffle.html#af8c7047c228f5d77f45d8f3954a6f1d2">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const Types &amp;...types)</div><div class="ttdoc">Computes the least common super types of the given types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00458">TypeSystem.h:458</a></div></div>
<div class="ttc" id="_component_model_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_model_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_model_8cpp_source.html#l00083">ComponentModel.cpp:83</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af8c7047c228f5d77f45d8f3954a6f1d2_cgraph.png" border="0" usemap="#namespacesouffle_af8c7047c228f5d77f45d8f3954a6f1d2_cgraph" alt=""/></div>
<map name="namespacesouffle_af8c7047c228f5d77f45d8f3954a6f1d2_cgraph" id="namespacesouffle_af8c7047c228f5d77f45d8f3954a6f1d2_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="294,144,533,171"/><area shape="rect" id="node3" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="613,5,721,32"/><area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#ac49e87c8c261866e2496381c776539e6" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="581,107,752,149"/><area shape="rect" id="node5" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="801,85,959,112"/><area shape="rect" id="node6" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="1008,216,1235,243"/><area shape="rect" id="node7" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="596,249,737,276"/><area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1501,362,1672,403"/><area shape="rect" id="node8" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="803,275,957,301"/><area shape="rect" id="node12" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="804,325,956,352"/><area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1036,267,1207,309"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1283,333,1453,374"/><area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1036,333,1207,374"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8e5fe6f4fe0781dfc619f8640a1631d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of pair-wise least common super types of the types in the two given sets. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00478">478</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8cpp_source.html#l00410">getLeastCommonSupertypes()</a>, <a class="el" href="_type_system_8h_source.html#l00226">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                                                                     {</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="comment">// special cases</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">if</span> (a.empty()) {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    }</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">if</span> (b.empty()) {</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    }</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">if</span> (a.isAll()) {</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    }</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <span class="keywordflow">if</span> (b.isAll()) {</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    }</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="comment">// compute pairwise least common super types</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    TypeSet res;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; x : a) {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; y : b) {</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            res.insert(<a class="code" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a>(x, y));</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    }</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8e5fe6f4fe0781dfc619f8640a1631d3"><div class="ttname"><a href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise least common super types of the types in the two given sets. ...</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00478">TypeSystem.cpp:478</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph.png" border="0" usemap="#namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph" alt=""/></div>
<map name="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph" id="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="332,5,495,32"/><area shape="rect" id="node3" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="294,183,533,209"/><area shape="rect" id="node6" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="801,157,959,184"/><area shape="rect" id="node15" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="338,233,489,260"/><area shape="rect" id="node4" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="613,208,721,235"/><area shape="rect" id="node5" href="classsouffle_1_1_type_environment.html#ac49e87c8c261866e2496381c776539e6" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="581,259,752,301"/><area shape="rect" id="node7" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="1008,368,1235,395"/><area shape="rect" id="node8" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="596,401,737,428"/><area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="1501,259,1672,301"/><area shape="rect" id="node9" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="803,477,957,504"/><area shape="rect" id="node13" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="804,427,956,453"/><area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1036,485,1207,526"/><area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="1283,419,1453,461"/><area shape="rect" id="node14" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1036,419,1207,461"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8daf345b78b314c825a08367912ee42a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomMaxBoundSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AstAtom * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00527">527</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00603">getNextAtomSIPS()</a>.</p>
<div class="fragment"><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                                                                            {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="keywordtype">int</span> maxBound = -1;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="keywordtype">int</span> maxIndex = 0;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keywordtype">bool</span> maxIsEDB = <span class="keyword">false</span>;  <span class="comment">// checks if current max index is an EDB predicate</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; atoms.size(); i++) {</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        AstAtom* currAtom = atoms[i];</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <span class="comment">// already done - move on</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        <span class="keywordtype">int</span> numBound = 0;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                numBound++;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            }</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        }</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        <span class="keywordflow">if</span> (numBound &gt; maxBound) {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            maxBound = numBound;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            maxIndex = i;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;            maxIsEDB = <a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(edb, currAtom-&gt;getName());</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!maxIsEDB &amp;&amp; numBound == maxBound &amp;&amp; <a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(edb, currAtom-&gt;getName())) {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            <span class="comment">// prioritise EDB predicates</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            maxIsEDB = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            maxIndex = i;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        }</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    }</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">return</span> maxIndex;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a726544578525e6c61dcef1cfc0d6f996"><div class="ttname"><a href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00125">MagicSet.cpp:125</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8daf345b78b314c825a08367912ee42a_cgraph.png" border="0" usemap="#namespacesouffle_a8daf345b78b314c825a08367912ee42a_cgraph" alt=""/></div>
<map name="namespacesouffle_a8daf345b78b314c825a08367912ee42a_cgraph" id="namespacesouffle_a8daf345b78b314c825a08367912ee42a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="819,82,938,109"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="294,44,503,70"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="308,94,489,121"/><area shape="rect" id="node6" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="313,145,485,172"/><area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="574,44,709,70"/><area shape="rect" id="node7" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="579,145,703,172"/><area shape="rect" id="node8" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="552,196,731,222"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="811,134,947,175"/><area shape="rect" id="node10" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="789,199,968,240"/><area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="779,264,978,306"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a815de54b0cfc5cc21aa5bd963bbb8c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomMaxRatioSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AstAtom * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00562">562</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00080">souffle::AstAtom::getArity()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                                                                            {</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    <span class="keywordtype">double</span> maxRatio = -1;</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    <span class="keywordtype">int</span> maxIndex = 0;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; atoms.size(); i++) {</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        AstAtom* currAtom = atoms[i];</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            <span class="comment">// already done - move on</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        <span class="keywordtype">int</span> numArguments = currAtom-&gt;getArity();</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="keywordflow">if</span> (numArguments == 0) {</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;            <span class="keywordflow">return</span> i;  <span class="comment">// no arguments!</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        }</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="keywordtype">int</span> numBound = 0;</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                numBound++;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;            }</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        }</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordtype">double</span> currRatio = numBound * 1.0 / numArguments;</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        <span class="keywordflow">if</span> (currRatio == 1) {</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;            <span class="keywordflow">return</span> i;  <span class="comment">// all bound, not going to get better than this</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        }</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        <span class="keywordflow">if</span> (currRatio &gt; maxRatio) {</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            maxRatio = currRatio;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            maxIndex = i;</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        }</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    }</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">return</span> maxIndex;</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a726544578525e6c61dcef1cfc0d6f996"><div class="ttname"><a href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00125">MagicSet.cpp:125</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a815de54b0cfc5cc21aa5bd963bbb8c81_cgraph.png" border="0" usemap="#namespacesouffle_a815de54b0cfc5cc21aa5bd963bbb8c81_cgraph" alt=""/></div>
<map name="namespacesouffle_a815de54b0cfc5cc21aa5bd963bbb8c81_cgraph" id="namespacesouffle_a815de54b0cfc5cc21aa5bd963bbb8c81_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="289,5,498,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#aad70ba585b02eac7a0038f8cdcee2c18" title="Return the arity of the atom. " alt="" coords="307,56,480,83"/><area shape="rect" id="node5" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="307,107,479,133"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="569,5,703,32"/><area shape="rect" id="node6" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="574,56,698,83"/><area shape="rect" id="node7" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="547,161,725,188"/><area shape="rect" id="node9" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="814,103,933,129"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="805,154,941,195"/><area shape="rect" id="node10" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="784,219,963,261"/><area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="774,285,973,326"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9b1db2a9f27816ff9604d3c219f49739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomNaiveSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AstAtom * &gt;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00486">486</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00145">hasBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                                                                            {</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="comment">// find the first available atom with at least one bound argument</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="keywordtype">int</span> firstedb = -1;</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <span class="keywordtype">int</span> firstidb = -1;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; atoms.size(); i++) {</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        AstAtom* currAtom = atoms[i];</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            <span class="comment">// already done - move on</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        }</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        AstRelationIdentifier atomName = currAtom-&gt;getName();</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="comment">// check if this is the first edb or idb atom met</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(edb, atomName)) {</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="keywordflow">if</span> (firstedb &lt; 0) {</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                firstedb = i;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (firstidb &lt; 0) {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            firstidb = i;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        <span class="comment">// if it has at least one bound argument, then adorn this atom next</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab5d33c614149ed8612b009d37b04ffa0">hasBoundArgument</a>(currAtom, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            <span class="keywordflow">return</span> i;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    }</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="comment">// all unadorned body atoms only have free arguments</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="comment">// choose the first edb remaining if available</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="keywordflow">if</span> (firstedb &gt;= 0) {</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordflow">return</span> firstedb;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        <span class="keywordflow">return</span> firstidb;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    }</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab5d33c614149ed8612b009d37b04ffa0"><div class="ttname"><a href="namespacesouffle.html#ab5d33c614149ed8612b009d37b04ffa0">souffle::hasBoundArgument</a></div><div class="ttdeci">bool hasBoundArgument(AstAtom *atom, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00145">MagicSet.cpp:145</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a9b1db2a9f27816ff9604d3c219f49739_cgraph.png" border="0" usemap="#namespacesouffle_a9b1db2a9f27816ff9604d3c219f49739_cgraph" alt=""/></div>
<map name="namespacesouffle_a9b1db2a9f27816ff9604d3c219f49739_cgraph" id="namespacesouffle_a9b1db2a9f27816ff9604d3c219f49739_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="1022,84,1141,111"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="265,45,447,72"/><area shape="rect" id="node4" href="namespacesouffle.html#ab5d33c614149ed8612b009d37b04ffa0" title="souffle::hasBoundArgument" alt="" coords="265,96,447,123"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="497,71,706,97"/><area shape="rect" id="node7" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="515,135,687,161"/><area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="777,45,911,72"/><area shape="rect" id="node8" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="782,147,906,173"/><area shape="rect" id="node9" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="755,197,933,224"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="1013,135,1149,177"/><area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="992,201,1171,242"/><area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="982,266,1181,307"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab559af8bc13b344074099f3b7e44e037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AstAtom * &gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; AstRelationIdentifier &gt;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00603">603</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00527">getNextAtomMaxBoundSIPS()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                                                                            {</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8daf345b78b314c825a08367912ee42a">getNextAtomMaxBoundSIPS</a>(atoms, boundArgs, edb, compositeBindings);</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8daf345b78b314c825a08367912ee42a"><div class="ttname"><a href="namespacesouffle.html#a8daf345b78b314c825a08367912ee42a">souffle::getNextAtomMaxBoundSIPS</a></div><div class="ttdeci">int getNextAtomMaxBoundSIPS(std::vector&lt; AstAtom * &gt; &amp;atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; AstRelationIdentifier &gt; edb, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00527">MagicSet.cpp:527</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab559af8bc13b344074099f3b7e44e037_cgraph.png" border="0" usemap="#namespacesouffle_ab559af8bc13b344074099f3b7e44e037_cgraph" alt=""/></div>
<map name="namespacesouffle_ab559af8bc13b344074099f3b7e44e037_cgraph" id="namespacesouffle_ab559af8bc13b344074099f3b7e44e037_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8daf345b78b314c825a08367912ee42a" title="souffle::getNextAtomMaxBoundSIPS" alt="" coords="233,69,471,96"/><area shape="rect" id="node3" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="1046,82,1165,109"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="521,44,730,70"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="535,94,716,121"/><area shape="rect" id="node7" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="539,145,711,172"/><area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="801,44,935,70"/><area shape="rect" id="node8" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="806,145,930,172"/><area shape="rect" id="node9" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="779,196,957,222"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="1037,134,1173,175"/><area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="1016,199,1195,240"/><area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="1006,264,1205,306"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeb526d569fc848583a59613102f660d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getNextEdbName </td>
          <td>(</td>
          <td class="paramtype">AstProgram *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00199">199</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_program_8cpp_source.html#l00112">souffle::AstProgram::getRelation()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00914">separateDBs()</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                                              {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> edbNum = 0;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    std::stringstream newEdbName;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="comment">// find the next unused relation name of the form &quot;newedbX&quot;, X an integer</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">do</span> {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        newEdbName.str(<span class="stringliteral">&quot;&quot;</span>);  <span class="comment">// check</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        edbNum++;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        newEdbName &lt;&lt; <span class="stringliteral">&quot;newedb&quot;</span> &lt;&lt; edbNum;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    } <span class="keywordflow">while</span> (program-&gt;getRelation(newEdbName.str()) != <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keywordflow">return</span> newEdbName.str();</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph.png" border="0" usemap="#namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph" alt=""/></div>
<map name="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph" id="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="227,5,365,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acf2b075e7c326a8d80aad98075df04cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> souffle::getNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the null-reference constant. </p>

<p>Definition at line <a class="el" href="_compiled_ram_record_8h_source.html#l00064">64</a> of file <a class="el" href="_compiled_ram_record_8h_source.html">CompiledRamRecord.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                    {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1f3d2bbfbcd58c76463920d43a29b3d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_lock.html">Lock</a>&amp; souffle::getOutputLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a reference to the lock synchronizing output operations. </p>

<p>Definition at line <a class="el" href="_logger_8h_source.html#l00030">30</a> of file <a class="el" href="_logger_8h_source.html">Logger.h</a>.</p>

<p>Referenced by <a class="el" href="_logger_8h_source.html#l00062">souffle::Logger::~Logger()</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                             {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <span class="keyword">static</span> Lock output_lock;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">return</span> output_lock;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a526256b2f4d593cceb8b73068e7de882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getString </td>
          <td>(</td>
          <td class="paramtype">const AstArgument *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00093">93</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00460">bindArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00155">isBindingConstraint()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                                            {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    std::stringstream argStream;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    argStream &lt;&lt; *arg;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">return</span> argStream.str();</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a52d50b4a86610a92376e2b1b02767551"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getSymbolForBinaryOp </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts operator to its symbolic representation. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00047">47</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, and <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">SUB</a>.</p>

<p>Referenced by <a class="el" href="_ram_value_8h_source.html#l00147">souffle::RamBinaryOperator::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00400">souffle::AstBinaryFunctor::print()</a>, and <a class="el" href="_bddbddb_backend_8cpp_source.html#l00178">souffle::detail::BddbddbConverter::visitFunctor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                                                   {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">case</span> BinaryOp::ADD:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">case</span> BinaryOp::SUB:</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MUL:</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;*&quot;</span>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">case</span> BinaryOp::DIV:</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">case</span> BinaryOp::EXP:</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;^&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MOD:</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;%&quot;</span>;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BAND:</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;band&quot;</span>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BOR:</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bor&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BXOR:</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bxor&quot;</span>;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LAND:</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;land&quot;</span>;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LOR:</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;lor&quot;</span>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MAX:</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;max&quot;</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MIN:</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;min&quot;</span>;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">case</span> BinaryOp::CAT:</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;cat&quot;</span>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;?&quot;</span>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac41c6466a40db79b6bc06560990cc831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getSymbolForTernaryOp </td>
          <td>(</td>
          <td class="paramtype">TernaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts operator to its symbolic representation. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00034">34</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>.</p>

<p>Referenced by <a class="el" href="_ram_value_8h_source.html#l00245">souffle::RamTernaryOperator::print()</a>, and <a class="el" href="_ast_argument_8h_source.html#l00494">souffle::AstTernaryFunctor::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                                     {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordflow">case</span> TernaryOp::SUBSTR:</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;substr&quot;</span>;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;?&quot;</span>;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a41fbfcfce875a96761b9d77f91cd8fcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getSymbolForUnaryOp </td>
          <td>(</td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding symbol for the given relational operator. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00051">51</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">ACOS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">ACOSH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">ASIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">ASINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">ATAN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">ATANH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">COS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">COSH</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">LOG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">SIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">SINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">TAN</a>, and <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">TANH</a>.</p>

<p>Referenced by <a class="el" href="_ram_value_8h_source.html#l00075">souffle::RamUnaryOperator::print()</a>, and <a class="el" href="_ast_argument_8h_source.html#l00317">souffle::AstUnaryFunctor::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                                 {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ORD:</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;ord&quot;</span>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">case</span> UnaryOp::STRLEN:</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;strlen&quot;</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">case</span> UnaryOp::NEG:</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">case</span> UnaryOp::BNOT:</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bnot&quot;</span>;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LNOT:</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;lnot&quot;</span>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SIN:</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;sin&quot;</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COS:</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;cos&quot;</span>;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TAN:</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;tan&quot;</span>;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASIN:</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;asin&quot;</span>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOS:</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;acos&quot;</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATAN:</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;atan&quot;</span>;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SINH:</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;sinh&quot;</span>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COSH:</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;cosh&quot;</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TANH:</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;tanh&quot;</span>;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASINH:</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;asinh&quot;</span>;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOSH:</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;acosh&quot;</span>;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATANH:</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;atanh&quot;</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LOG:</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;log&quot;</span>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">case</span> UnaryOp::EXP:</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;exp&quot;</span>;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;?&quot;</span>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a413b3992188dfdda83798af7d3f2a40b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44">TernaryOp</a> souffle::getTernaryOpForSymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts symbolic representation of an operator to the operator. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00048">48</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>, and <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                                                                {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;substr&quot;</span>) <span class="keywordflow">return</span> TernaryOp::SUBSTR;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognised operator: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">return</span> TernaryOp::__UNDEFINED__;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d6fe661fa54da7de4dccc65c8f82834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getTypeQualifier </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns full type qualifier for a given type. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00256">256</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_macro_8h_source.html#l00035">ASSERT</a>, <a class="el" href="_type_system_8h_source.html#l00127">souffle::UnionType::getElementTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00156">souffle::RecordType::getFields()</a>, <a class="el" href="_type_system_8h_source.html#l00055">souffle::Type::getName()</a>, <a class="el" href="_type_system_8cpp_source.html#l00311">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00327">isRecordType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00319">isSymbolType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00176">seen</a>, and <a class="el" href="_util_8h_source.html#l00673">toString()</a>.</p>
<div class="fragment"><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                                             {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keyword">struct </span>visitor : <span class="keyword">public</span> VisitOnceTypeVisitor&lt;std::string&gt; {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        std::string visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            std::string str = visitType(type);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            str += <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> unionType : type.getElementTypes()) {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                <span class="keywordflow">if</span> (first) {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                    first = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    str += <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                str += visit(*unionType);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            str += <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        std::string visitRecordType(<span class="keyword">const</span> RecordType&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            std::string str = visitType(type);</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            str += <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> field : type.getFields()) {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                <span class="keywordflow">if</span> (first) {</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                    first = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                    str += <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                }</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                str += field.name;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                str += <span class="stringliteral">&quot;#&quot;</span>;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                str += visit(field.type);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            }</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            str += <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        std::string visitType(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            std::string str;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>(type)) {</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                str = <span class="stringliteral">&quot;i:&quot;</span> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(type.getName());</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a>(type)) {</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                str = <span class="stringliteral">&quot;s:&quot;</span> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(type.getName());</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">isRecordType</a>(type)) {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                str = <span class="stringliteral">&quot;r:&quot;</span> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(type.getName());</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                <a class="code" href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unknown type class&quot;</span>);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[&amp;type] = str;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    };</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">return</span> visitor().visit(type);</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00315">TypeSystem.cpp:315</a></div></div>
<div class="ttc" id="namespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00673">Util.h:673</a></div></div>
<div class="ttc" id="_macro_8h_html_aca68c0d4ac8df0838e209fb5300f7be3"><div class="ttname"><a href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a></div><div class="ttdeci">#define ASSERT(x)</div><div class="ttdef"><b>Definition:</b> <a href="_macro_8h_source.html#l00035">Macro.h:35</a></div></div>
<div class="ttc" id="_type_system_8cpp_html_a157c8fc15ecc360f080bfd2d5d6ddbff"><div class="ttname"><a href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a></div><div class="ttdeci">std::map&lt; const Type *, R &gt; seen</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00176">TypeSystem.cpp:176</a></div></div>
<div class="ttc" id="namespacesouffle_html_a790e39fcdcb0e62caaee56e0bf7d3b45"><div class="ttname"><a href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">souffle::isRecordType</a></div><div class="ttdeci">bool isRecordType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are record types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00331">TypeSystem.cpp:331</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae9f1f97bcd38ff9cd112ade89e631b80"><div class="ttname"><a href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are symbol types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00323">TypeSystem.cpp:323</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph.png" border="0" usemap="#namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph" alt=""/></div>
<map name="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph" id="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="233,5,365,46"/><area shape="rect" id="node3" href="structsouffle_1_1_record_type.html#afe02aad8492cb87cc7524798151a34d3" title="souffle::RecordType\l::getFields" alt="" coords="229,70,369,111"/><area shape="rect" id="node4" href="classsouffle_1_1_type.html#a3d4d7bbcf856657e683010bd7af30d24" title="souffle::Type::getName" alt="" coords="219,136,378,163"/><area shape="rect" id="node5" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="221,187,376,213"/><area shape="rect" id="node10" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="223,237,374,264"/><area shape="rect" id="node11" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="223,288,375,315"/><area shape="rect" id="node13" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case). " alt="" coords="241,339,356,365"/><area shape="rect" id="node6" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="427,237,653,264"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="455,171,625,213"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="701,230,872,271"/><area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="920,230,1091,271"/><area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="455,289,625,330"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a591e8675087d5d70a57bfde8ef0ba5c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4">UnaryOp</a> souffle::getUnaryOpForSymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding operator for the given symbol. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00101">101</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">ACOS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">ACOSH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">ASIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">ASINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">ATAN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">ATANH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">COS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">COSH</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">SIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">SINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">TAN</a>, and <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">TANH</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                                                            {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;ord&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ORD;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;strlen&quot;</span>) <span class="keywordflow">return</span> UnaryOp::STRLEN;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;-&quot;</span>) <span class="keywordflow">return</span> UnaryOp::NEG;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;bnot&quot;</span>) <span class="keywordflow">return</span> UnaryOp::BNOT;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;lnot&quot;</span>) <span class="keywordflow">return</span> UnaryOp::LNOT;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;sin&quot;</span>) <span class="keywordflow">return</span> UnaryOp::SIN;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;cos&quot;</span>) <span class="keywordflow">return</span> UnaryOp::COS;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;tan&quot;</span>) <span class="keywordflow">return</span> UnaryOp::TAN;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;asin&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ASIN;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;acos&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ACOS;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;atan&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ATAN;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;sinh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::SINH;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;cosh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::COSH;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;tanh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::TANH;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;asinh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ASINH;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;acosh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ACOSH;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;atanh&quot;</span>) <span class="keywordflow">return</span> UnaryOp::ATANH;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;tan&quot;</span>) <span class="keywordflow">return</span> UnaryOp::TAN;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;exp&quot;</span>) <span class="keywordflow">return</span> UnaryOp::EXP;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognised operator: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">return</span> UnaryOp::__UNDEFINED__;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acd078c141c96076832b98038f39e4d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt; souffle::getVariables </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a list of all variables referenced within the AST rooted by the given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of all variables referenced within </dd></dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00025">25</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00032">getVariables()</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                                                {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="comment">// simply collect the list of all variables by visiting all variables</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    std::vector&lt;const AstVariable*&gt; vars;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(root, [&amp;](<span class="keyword">const</span> AstVariable&amp; var) { vars.push_back(&amp;var); });</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">return</span> vars;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph.png" border="0" usemap="#namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph" alt=""/></div>
<map name="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph" id="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="195,12,349,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="397,5,552,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="600,5,776,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8195b2119af025c8ca8df003bc7e417b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt; souffle::getVariables </td>
          <td>(</td>
          <td class="paramtype">const AstNode *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a list of all variables referenced within the AST rooted by the given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of all variables referenced within </dd></dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00032">32</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_utils_8cpp_source.html#l00025">getVariables()</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                                                {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8195b2119af025c8ca8df003bc7e417b">getVariables</a>(*root);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8195b2119af025c8ca8df003bc7e417b"><div class="ttname"><a href="namespacesouffle.html#a8195b2119af025c8ca8df003bc7e417b">souffle::getVariables</a></div><div class="ttdeci">std::vector&lt; const AstVariable * &gt; getVariables(const AstNode *root)</div><div class="ttdoc">Obtains a list of all variables referenced within the AST rooted by the given root node...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00032">AstUtils.cpp:32</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8195b2119af025c8ca8df003bc7e417b_cgraph.png" border="0" usemap="#namespacesouffle_a8195b2119af025c8ca8df003bc7e417b_cgraph" alt=""/></div>
<map name="namespacesouffle_a8195b2119af025c8ca8df003bc7e417b_cgraph" id="namespacesouffle_a8195b2119af025c8ca8df003bc7e417b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#acd078c141c96076832b98038f39e4d48" title="Obtains a list of all variables referenced within the AST rooted by the given root node..." alt="" coords="195,12,336,39"/><area shape="rect" id="node3" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="384,12,539,39"/><area shape="rect" id="node4" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="587,5,741,46"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="789,5,965,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab5d33c614149ed8612b009d37b04ffa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasBoundArgument </td>
          <td>(</td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00145">145</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00486">getNextAtomNaiveSIPS()</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                                                                                                   {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">for</span> (AstArgument* arg : atom-&gt;getArguments()) {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a726544578525e6c61dcef1cfc0d6f996"><div class="ttname"><a href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00125">MagicSet.cpp:125</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab5d33c614149ed8612b009d37b04ffa0_cgraph.png" border="0" usemap="#namespacesouffle_ab5d33c614149ed8612b009d37b04ffa0_cgraph" alt=""/></div>
<map name="namespacesouffle_ab5d33c614149ed8612b009d37b04ffa0_cgraph" id="namespacesouffle_ab5d33c614149ed8612b009d37b04ffa0_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="238,19,447,45"/><area shape="rect" id="node4" href="namespacesouffle.html#a726544578525e6c61dcef1cfc0d6f996" title="souffle::isBoundArgument" alt="" coords="257,95,429,121"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="518,5,653,32"/><area shape="rect" id="node5" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="523,56,647,83"/><area shape="rect" id="node6" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="496,161,675,188"/><area shape="rect" id="node8" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="763,103,882,129"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="755,154,891,195"/><area shape="rect" id="node9" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="733,219,912,261"/><area shape="rect" id="node10" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="723,285,922,326"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aae039656df27f6089ef34a0a4455dce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasClauseWithAggregatedRelation </td>
          <td>(</td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>aggRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstLiteral *&amp;&#160;</td>
          <td class="paramname"><em>foundLiteral</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given relation has any clauses which contain an aggregation over of a specific relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>the relation to search the clauses of </td></tr>
    <tr><td class="paramname">aggRelation</td><td>the relation to search for in aggregations in clause bodies </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
    <tr><td class="paramname">foundLiteral</td><td>set to the literal found in an aggregation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00070">70</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_utils_8cpp_source.html#l00036">getAtomRelation()</a>, <a class="el" href="_ast_relation_8h_source.html#l00302">souffle::AstRelation::getClauses()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                                                    {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstClause* cl : relation-&gt;getClauses()) {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordtype">bool</span> hasAgg = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*cl, [&amp;](<span class="keyword">const</span> AstAggregator&amp; cur) {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(cur, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                <span class="keywordflow">if</span> (aggRelation == <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)) {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                    foundLiteral = &amp;atom;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                    hasAgg = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            });</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        });</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">if</span> (hasAgg) {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00036">AstUtils.cpp:36</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph.png" border="0" usemap="#namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph" alt=""/></div>
<map name="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph" id="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="278,64,445,91"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="293,115,430,157"/><area shape="rect" id="node7" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="284,181,439,208"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="493,5,675,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="515,57,653,98"/><area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="517,123,651,149"/><area shape="rect" id="node8" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="507,174,661,215"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="723,174,899,215"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab93b9d78c10c77c6d4ab227d5f9b389a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasClauseWithNegatedRelation </td>
          <td>(</td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>negRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstLiteral *&amp;&#160;</td>
          <td class="paramname"><em>foundLiteral</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given relation has any clauses which contain a negation of a specific relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>the relation to search the clauses of </td></tr>
    <tr><td class="paramname">negRelation</td><td>the relation to search for negations of in clause bodies </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
    <tr><td class="paramname">foundLiteral</td><td>set to the negation literal that was found </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00057">57</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_utils_8cpp_source.html#l00036">getAtomRelation()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00302">souffle::AstRelation::getClauses()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                                    {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstClause* cl : relation-&gt;getClauses()) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> AstNegation* neg : cl-&gt;getNegations()) {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keywordflow">if</span> (negRelation == <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(neg-&gt;getAtom(), program)) {</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                foundLiteral = neg;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        }</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00036">AstUtils.cpp:36</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph.png" border="0" usemap="#namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph" alt=""/></div>
<map name="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph" id="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="262,64,429,91"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_relation.html#a0a748962a9a2151a2fabe585346fb0d7" title="Obtains a list of the associated clauses. " alt="" coords="277,115,414,157"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="477,5,659,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="499,57,637,98"/><area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="501,123,635,149"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aacfe9bc62b1157c810a572b6c1b310aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasPrefix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00064">64</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00072">isAggRel()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01028">replaceUnderscores()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                                                {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">if</span> (str.substr(0, prefix.size()).compare(prefix) == 0) {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c77d8cc2a9414cd6aeb5d02c74e162d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::hasUnnamedVariable </td>
          <td>(</td>
          <td class="paramtype">const AstArgument *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00321">321</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00885">any_of()</a>, and <a class="el" href="_macro_8h_source.html#l00035">ASSERT</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00489">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00370">souffle::AstSemanticChecker::checkLiteral()</a>, and <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00355">hasUnnamedVariable()</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                                                       {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstUnnamedVariable*&gt;(arg)) {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstVariable*&gt;(arg)) {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstConstant*&gt;(arg)) {</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    }</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstCounter*&gt;(arg)) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    }</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstUnaryFunctor* uf = dynamic_cast&lt;const AstUnaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(uf-&gt;getOperand());</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    }</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstBinaryFunctor* bf = dynamic_cast&lt;const AstBinaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(bf-&gt;getLHS()) || <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(bf-&gt;getRHS());</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstTernaryFunctor* tf = dynamic_cast&lt;const AstTernaryFunctor*&gt;(arg)) {</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(tf-&gt;getArg(0)) || <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(tf-&gt;getArg(1)) ||</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;               <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(tf-&gt;getArg(2));</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    }</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstRecordInit* ri = dynamic_cast&lt;const AstRecordInit*&gt;(arg)) {</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(ri-&gt;getArguments(), (bool (*)(<span class="keyword">const</span> AstArgument*))<a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    }</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstAggregator*&gt;(arg)) {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported Argument type: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(*arg).name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <a class="code" href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Argument Type!&quot;</span>);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_abb328ce61aedddf363f53be8e445a8e0"><div class="ttname"><a href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">souffle::hasUnnamedVariable</a></div><div class="ttdeci">static bool hasUnnamedVariable(const AstLiteral *lit)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00355">AstSemanticChecker.cpp:355</a></div></div>
<div class="ttc" id="_macro_8h_html_aca68c0d4ac8df0838e209fb5300f7be3"><div class="ttname"><a href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a></div><div class="ttdeci">#define ASSERT(x)</div><div class="ttdef"><b>Definition:</b> <a href="_macro_8h_source.html#l00035">Macro.h:35</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00885">Util.h:885</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph.png" border="0" usemap="#namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph" alt=""/></div>
<map name="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph" id="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="249,5,357,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abb328ce61aedddf363f53be8e445a8e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::hasUnnamedVariable </td>
          <td>(</td>
          <td class="paramtype">const AstLiteral *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00355">355</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00885">any_of()</a>, <a class="el" href="_macro_8h_source.html#l00035">ASSERT</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00321">hasUnnamedVariable()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00196">name</a>.</p>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                                      {</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstAtom* at = dynamic_cast&lt;const AstAtom*&gt;(lit)) {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(at-&gt;getArguments(), (bool (*)(<span class="keyword">const</span> AstArgument*))<a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstNegation* neg = dynamic_cast&lt;const AstNegation*&gt;(lit)) {</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(neg-&gt;getAtom());</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    }</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstConstraint* br = dynamic_cast&lt;const AstConstraint*&gt;(lit)) {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(br-&gt;getLHS()) || <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(br-&gt;getRHS());</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    }</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported Literal type: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(lit).<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <a class="code" href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Argument Type!&quot;</span>);</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_abb328ce61aedddf363f53be8e445a8e0"><div class="ttname"><a href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">souffle::hasUnnamedVariable</a></div><div class="ttdeci">static bool hasUnnamedVariable(const AstLiteral *lit)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00355">AstSemanticChecker.cpp:355</a></div></div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
<div class="ttc" id="_macro_8h_html_aca68c0d4ac8df0838e209fb5300f7be3"><div class="ttname"><a href="_macro_8h.html#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a></div><div class="ttdeci">#define ASSERT(x)</div><div class="ttdef"><b>Definition:</b> <a href="_macro_8h_source.html#l00035">Macro.h:35</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00885">Util.h:885</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph.png" border="0" usemap="#namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph" alt=""/></div>
<map name="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph" id="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="491,5,599,32"/><area shape="rect" id="node3" href="namespacesouffle.html#a2c77d8cc2a9414cd6aeb5d02c74e162d" title="souffle::hasUnnamedVariable" alt="" coords="249,31,442,57"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad0e8debde5608979e041dd30e044612a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::identifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01138">1138</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;                                          {</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keywordtype">id</span>.length(); i++) {</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;        <span class="keywordflow">if</span> ((!isalpha(<span class="keywordtype">id</span>[i]) &amp;&amp; i == 0) || (!isalnum(<span class="keywordtype">id</span>[i]) &amp;&amp; <span class="keywordtype">id</span>[i] != <span class="charliteral">&#39;_&#39;</span>)) {</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;            <span class="keywordtype">id</span>[i] = <span class="charliteral">&#39;_&#39;</span>;</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;        }</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    }</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    <span class="keywordflow">return</span> id;</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a05eb410bc1f341864368bc73608bae7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string souffle::identifierToString </td>
          <td>(</td>
          <td class="paramtype">const AstRelationIdentifier &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions. </p>

<p>Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00024">24</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_translator_8cpp_source.html#l00196">name</a>.</p>

<p>Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00041">makeInfoRelation()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00030">makeRelationName()</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                                                                      {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    ss &lt;&lt; <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acd0dfc0a494a70a89da974a472e7b23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt;, std::vector&lt;<a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a>*&gt; &gt; souffle::inlineBodyLiterals </td>
          <td>(</td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstClause *&#160;</td>
          <td class="paramname"><em>atomInlineClause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines the given atom based on a given clause. </p>
<p>Returns the vector of replacement literals and the necessary constraints. If unification is unsuccessful, the vector of literals is marked as invalid. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00238">238</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_clause_8h_source.html#l00399">souffle::AstClause::apply()</a>, <a class="el" href="_ast_clause_8h_source.html#l00377">souffle::AstClause::clone()</a>, <a class="el" href="_ast_type_analysis_8cpp_source.html#l00064">constraints</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00068">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00020">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00016">souffle::NullableVector&lt; T &gt;::isValid()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00212">unifyAtoms()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00371">formNegatedLiterals()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00738">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                                                    {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    std::vector&lt;AstLiteral*&gt; addedLits;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    std::vector&lt;AstConstraint*&gt; <a class="code" href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="comment">// Rename the variables in the inlined clause to avoid conflicts when unifying multiple atoms</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="comment">// - particularly when an inlined relation appears twice in a clause.</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> inlineCount = 0;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="comment">// Make a temporary clone so we can rename variables without fear</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    AstClause* atomClause = atomInlineClause-&gt;clone();</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keyword">struct </span>VariableRenamer : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordtype">int</span> varnum;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        VariableRenamer(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="keywordflow">if</span> (AstVariable* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                <span class="comment">// Rename the variable</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                <span class="keyword">auto</span> newVar = std::unique_ptr&lt;AstVariable&gt;(var-&gt;clone());</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                std::stringstream newName;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                newName &lt;&lt; <span class="stringliteral">&quot;&lt;inlined_&quot;</span> &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; varnum &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                newVar-&gt;setName(newName.str());</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                <span class="keywordflow">return</span> std::move(newVar);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    };</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    VariableRenamer update(inlineCount);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    atomClause-&gt;apply(update);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    inlineCount++;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="comment">// Get the constraints needed to unify the two atoms</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt; res = <a class="code" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">unifyAtoms</a>(atomClause-&gt;getHead(), atom);</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">if</span> (res.isValid()) {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="keywordflow">for</span> (std::pair&lt;AstArgument*, AstArgument*&gt; pair : res.getVector()) {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            constraints.push_back(<span class="keyword">new</span> AstConstraint(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                    std::unique_ptr&lt;AstArgument&gt;(pair.first-&gt;clone()),</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                    std::unique_ptr&lt;AstArgument&gt;(pair.second-&gt;clone())));</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">// Add in the body of the current clause of the inlined atom</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : atomClause-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            addedLits.push_back(lit-&gt;clone());</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        }</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    }</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keyword">delete</span> atomClause;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">if</span> (changed) {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;AstLiteral*&gt;(addedLits), constraints);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;AstLiteral*&gt;(), constraints);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    }</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ab66c00257a9f4ce44653d82cee9c563d"><div class="ttname"><a href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">souffle::unifyAtoms</a></div><div class="ttdeci">NullableVector&lt; std::pair&lt; AstArgument *, AstArgument * &gt; &gt; unifyAtoms(AstAtom *first, AstAtom *second)</div><div class="ttdoc">Returns the nullable vector of substitutions needed to unify the two given atoms. ...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00212">InlineRelationsTransformer.cpp:212</a></div></div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
<div class="ttc" id="_ast_type_analysis_8cpp_html_a4551a78b0ee37ec3710ad8cda752cf2e"><div class="ttname"><a href="_ast_type_analysis_8cpp.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a></div><div class="ttdeci">Problem&lt; AnalysisVar &gt; constraints</div><div class="ttdoc">The list of constraints making underlying this analysis. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_type_analysis_8cpp_source.html#l00064">AstTypeAnalysis.cpp:64</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acd0dfc0a494a70a89da974a472e7b23f_cgraph.png" border="0" usemap="#namespacesouffle_acd0dfc0a494a70a89da974a472e7b23f_cgraph" alt=""/></div>
<map name="namespacesouffle_acd0dfc0a494a70a89da974a472e7b23f_cgraph" id="namespacesouffle_acd0dfc0a494a70a89da974a472e7b23f_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Mutates this node. " alt="" coords="236,5,367,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="236,70,367,111"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="236,135,367,177"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="236,201,367,242"/><area shape="rect" id="node9" href="classsouffle_1_1_nullable_vector.html#aa79f48ef3a2b9cdc53e316aecf978aa2" title="souffle::NullableVector\l::getVector" alt="" coords="224,266,379,307"/><area shape="rect" id="node10" href="classsouffle_1_1_nullable_vector.html#a1e5e9114c77f302e8800421d2dd7c717" title="souffle::NullableVector\l::isValid" alt="" coords="224,331,379,373"/><area shape="rect" id="node11" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="234,397,369,424"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="467,11,597,53"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="439,77,625,104"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="466,129,598,170"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="427,372,637,399"/><area shape="rect" id="node14" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="443,423,621,449"/><area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="686,372,821,399"/><area shape="rect" id="node15" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="708,423,799,449"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7490f3d9e6d010462a5fd470c081ca2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isAggRel </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00072">72</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00067">souffle::AstRelationIdentifier::getNames()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00064">hasPrefix()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                         {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// TODO (azreika): this covers too much (e.g. user-defined __agg_rel_x)</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="comment">//                 need a way to determine if created by aggregates</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">hasPrefix</a>(rel.getNames()[0], <span class="stringliteral">&quot;__agg_rel_&quot;</span>);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aacfe9bc62b1157c810a572b6c1b310aa"><div class="ttname"><a href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(std::string str, std::string prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00064">MagicSet.cpp:64</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7490f3d9e6d010462a5fd470c081ca2b_cgraph.png" border="0" usemap="#namespacesouffle_a7490f3d9e6d010462a5fd470c081ca2b_cgraph" alt=""/></div>
<map name="namespacesouffle_a7490f3d9e6d010462a5fd470c081ca2b_cgraph" id="namespacesouffle_a7490f3d9e6d010462a5fd470c081ca2b_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#acc40ffc92083f65c1a47442a0e80a0ec" title="souffle::AstRelationIdentifier\l::getNames" alt="" coords="176,5,363,46"/><area shape="rect" id="node3" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="207,71,331,97"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a01f8bfe9b5546db6b9c75d4c5b968d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBindingConstraint </td>
          <td>(</td>
          <td class="paramtype">AstArgument *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstArgument *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00155">155</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00093">getString()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    std::string lhs_name = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>);</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    std::string rhs_name = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(<a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">// only want to check variables we have not bound yet</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;AstVariable*&gt;(<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>) &amp;&amp; (boundArgs.find(lhs_name) == boundArgs.end())) {</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="comment">// return true if the rhs is a bound variable or a constant</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">if</span> (dynamic_cast&lt;AstVariable*&gt;(<a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>) &amp;&amp; (boundArgs.find(rhs_name) != boundArgs.end())) {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstConstant*&gt;(<a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>)) {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    }</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;}</div>
<div class="ttc" id="_ast_transforms_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdoc">The two terms to be equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00169">AstTransforms.cpp:169</a></div></div>
<div class="ttc" id="namespacesouffle_html_a526256b2f4d593cceb8b73068e7de882"><div class="ttname"><a href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">souffle::getString</a></div><div class="ttdeci">std::string getString(const AstArgument *arg)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00093">MagicSet.cpp:93</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00170">AstTransforms.cpp:170</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph.png" border="0" usemap="#namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph" alt=""/></div>
<map name="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph" id="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882" title="souffle::getString" alt="" coords="238,5,359,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a726544578525e6c61dcef1cfc0d6f996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBoundArgument </td>
          <td>(</td>
          <td class="paramtype">AstArgument *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00125">125</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00064">hasPrefix()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00100">isBoundComposite()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00460">bindArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00527">getNextAtomMaxBoundSIPS()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00562">getNextAtomMaxRatioSIPS()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00145">hasBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">if</span> (AstVariable* var = dynamic_cast&lt;AstVariable*&gt;(arg)) {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        std::string variableName = var-&gt;getName();</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">hasPrefix</a>(variableName, <span class="stringliteral">&quot;+functor&quot;</span>) || <a class="code" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">hasPrefix</a>(variableName, <span class="stringliteral">&quot;+record&quot;</span>)) {</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740">isBoundComposite</a>(var, boundArgs, compositeBindings)) {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        }</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(boundArgs, variableName)) {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// found a bound argument, so can stop</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;incomplete checks (MST)&quot;</span>);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    }</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aacfe9bc62b1157c810a572b6c1b310aa"><div class="ttname"><a href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(std::string str, std::string prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00064">MagicSet.cpp:64</a></div></div>
<div class="ttc" id="namespacesouffle_html_a71b72db3f5e04e5478626accb015f740"><div class="ttname"><a href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740">souffle::isBoundComposite</a></div><div class="ttdeci">bool isBoundComposite(const AstVariable *compositeVariable, std::set&lt; std::string &gt; boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00100">MagicSet.cpp:100</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a726544578525e6c61dcef1cfc0d6f996_cgraph.png" border="0" usemap="#namespacesouffle_a726544578525e6c61dcef1cfc0d6f996_cgraph" alt=""/></div>
<map name="namespacesouffle_a726544578525e6c61dcef1cfc0d6f996_cgraph" id="namespacesouffle_a726544578525e6c61dcef1cfc0d6f996_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="494,5,613,32"/><area shape="rect" id="node3" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="254,56,378,83"/><area shape="rect" id="node4" href="namespacesouffle.html#a71b72db3f5e04e5478626accb015f740" title="souffle::isBoundComposite" alt="" coords="227,107,405,133"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="485,57,621,98"/><area shape="rect" id="node6" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="464,122,643,163"/><area shape="rect" id="node7" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="454,187,653,229"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a71b72db3f5e04e5478626accb015f740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBoundComposite </td>
          <td>(</td>
          <td class="paramtype">const AstVariable *&#160;</td>
          <td class="paramname"><em>compositeVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingStore &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00100">100</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_magic_set_8h_source.html#l00147">souffle::BindingStore::addVariableBoundComposite()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00032">contains()</a>, <a class="el" href="_ast_argument_8h_source.html#l00074">souffle::AstVariable::getName()</a>, and <a class="el" href="_magic_set_8h_source.html#l00134">souffle::BindingStore::getVariableDependencies()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00125">isBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                                         {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    std::string variableName = compositeVariable-&gt;getName();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(boundArgs, variableName)) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">bool</span> bound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="comment">// a composite argument is bound iff all its subvariables are bound</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keyword">auto</span> dependencies = compositeBindings.getVariableDependencies(variableName);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; var : dependencies) {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">contains</a>(boundArgs, var)) {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            bound = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    }</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">if</span> (bound) {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="comment">// composite variable bound only because its constituent variables are bound</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        compositeBindings.addVariableBoundComposite(variableName);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">return</span> bound;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a9b30ea606023779f6ede16f65cc52db3"><div class="ttname"><a href="namespacesouffle.html#a9b30ea606023779f6ede16f65cc52db3">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, AstRelationIdentifier atomName, std::string atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00037">MagicSet.cpp:37</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a71b72db3f5e04e5478626accb015f740_cgraph.png" border="0" usemap="#namespacesouffle_a71b72db3f5e04e5478626accb015f740_cgraph" alt=""/></div>
<map name="namespacesouffle_a71b72db3f5e04e5478626accb015f740_cgraph" id="namespacesouffle_a71b72db3f5e04e5478626accb015f740_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_binding_store.html#a9475a538ffdbd5dba71fc1dff46a69dc" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="233,5,431,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a6f53082a60ed5593022bde81dc619ac9" title="souffle::contains" alt="" coords="273,71,391,97"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_variable.html#a298c753e0d5f0ca5c07536ca304d9086" title="souffle::AstVariable\l::getName" alt="" coords="264,122,400,163"/><area shape="rect" id="node5" href="classsouffle_1_1_binding_store.html#a08058db98053df04128550fadda81875" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="243,187,421,229"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2d324369b5fc672d6cde86cb6c20e304"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::isConstantArithExpr </td>
          <td>(</td>
          <td class="paramtype">const AstArgument &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00420">420</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00438">souffle::AstSemanticChecker::checkConstant()</a>.</p>
<div class="fragment"><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                                                             {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstNumberConstant*&gt;(&amp;argument)) {</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstUnaryFunctor* unOp = dynamic_cast&lt;const AstUnaryFunctor*&gt;(&amp;argument)) {</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordflow">return</span> unOp-&gt;isNumerical() &amp;&amp; <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*unOp-&gt;getOperand());</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    }</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstBinaryFunctor* binOp = dynamic_cast&lt;const AstBinaryFunctor*&gt;(&amp;argument)) {</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <span class="keywordflow">return</span> binOp-&gt;isNumerical() &amp;&amp; <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*binOp-&gt;getLHS()) &amp;&amp;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;               <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*binOp-&gt;getRHS());</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> AstTernaryFunctor* ternOp = dynamic_cast&lt;const AstTernaryFunctor*&gt;(&amp;argument)) {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">return</span> ternOp-&gt;isNumerical() &amp;&amp; <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*ternOp-&gt;getArg(0)) &amp;&amp;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;               <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*ternOp-&gt;getArg(1)) &amp;&amp; <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*ternOp-&gt;getArg(2));</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    }</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a2d324369b5fc672d6cde86cb6c20e304"><div class="ttname"><a href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">souffle::isConstantArithExpr</a></div><div class="ttdeci">static bool isConstantArithExpr(const AstArgument &amp;argument)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00420">AstSemanticChecker.cpp:420</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0921564037c6405c66d8141871d9ea7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isEqualAdornment </td>
          <td>(</td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>pred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>adorn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelationIdentifier&#160;</td>
          <td class="paramname"><em>pred2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>adorn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00025">25</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00037">contains()</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                                                                                      {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordflow">return</span> ((pred1 == pred2) &amp;&amp; (adorn1.compare(adorn2) == 0));</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64753e143a37bb9414121fc75987cb14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isExecutable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given file exists and it is an executable. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00958">958</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00070">executeBinary()</a>, and <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                                                {</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) &amp;&amp; !access(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.c_str(), X_OK);</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
<div class="ttc" id="namespacesouffle_html_a69107e934a60222580ee8ba6882dc3d3"><div class="ttname"><a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a></div><div class="ttdeci">bool existFile(const std::string &amp;name)</div><div class="ttdoc">Check whether a file exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00932">Util.h:932</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa91f27920d30575842a1fdfd0d53f348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isHintsProfilingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function to determine whether hints-profiling is enabled or disabled;. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01253">1253</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_b_tree_8h_source.html#l01979">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true &gt;::printStats()</a>.</p>
<div class="fragment"><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;                                      {</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    <span class="keywordflow">return</span> std::getenv(<span class="stringliteral">&quot;SOUFFLE_PROFILE_HINTS&quot;</span>);</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23d62e96f3d7162806dc7d4d7798297a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNull </td>
          <td>(</td>
          <td class="paramtype">RamDomain&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given reference is the null reference encoding the absence of any nested record. </p>

<p>Definition at line <a class="el" href="_compiled_ram_record_8h_source.html#l00069">69</a> of file <a class="el" href="_compiled_ram_record_8h_source.html">CompiledRamRecord.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                           {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">return</span> ref == 0;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a56909036ae0514924e306d0a1a180837"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumber </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a string is a sequence of numbers. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00088">88</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                                      {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">if</span> (str == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">while</span> (*str) {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">if</span> (!isdigit(*str)) {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        str++;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4e502e6abb9a3e9a8e4c1168dbf23743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumberType </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a number type. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00311">311</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00353">souffle::TypeEnvironment::getNumberType()</a>, and <a class="el" href="_type_system_8h_source.html#l00059">souffle::Type::getTypeEnvironment()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8cpp_source.html#l00256">getTypeQualifier()</a>, <a class="el" href="_type_system_8cpp_source.html#l00315">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00365">isSubtypeOf()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00548">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                                    {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getNumberType());</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph.png" border="0" usemap="#namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph" alt=""/></div>
<map name="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph" id="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="236,5,407,46"/><area shape="rect" id="node5" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="208,71,435,97"/><area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="483,5,653,46"/><area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="701,5,872,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aae6c863e60901e130475672aff3942ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumberType </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are number types. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00315">315</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00871">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00311">isNumberType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                                    {</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00315">TypeSystem.cpp:315</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00871">Util.h:871</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph.png" border="0" usemap="#namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph" alt=""/></div>
<map name="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph" id="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="239,5,339,32"/><area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="208,56,371,83"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="214,107,365,133"/><area shape="rect" id="node5" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="212,157,367,184"/><area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="447,121,617,162"/><area shape="rect" id="node9" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="419,187,645,213"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="693,121,864,162"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="912,121,1083,162"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a90eb741155c2a50d6028ac5cfb1bb64f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericBinaryConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const BinaryConstraintOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper Functions for Binary Functors. </p>
<p>Determines whether arguments of constraint are numeric </p>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00136">136</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>.</p>

<p>Referenced by <a class="el" href="_ast_literal_8h_source.html#l00282">souffle::AstConstraint::isNumerical()</a>, and <a class="el" href="_binary_constraint_ops_8h_source.html#l00162">isSymbolicBinaryConstraintOp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                                                                     {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5ecdc282acb8ee99226175690bf397d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericBinaryOp </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given operator has a numeric return value. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00110">110</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaaa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, and <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa241dd841abade20fcb27b8a9f494e1eb">SUB</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00380">souffle::AstBinaryFunctor::isNumerical()</a>, and <a class="el" href="_binary_functor_ops_8h_source.html#l00138">isSymbolicBinaryOp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                                 {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">case</span> BinaryOp::ADD:</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keywordflow">case</span> BinaryOp::SUB:</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MUL:</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">case</span> BinaryOp::DIV:</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">case</span> BinaryOp::EXP:</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BAND:</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BOR:</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">case</span> BinaryOp::BXOR:</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LAND:</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">case</span> BinaryOp::LOR:</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MOD:</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MAX:</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">case</span> BinaryOp::MIN:</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">case</span> BinaryOp::CAT:</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a886a8cccceb06e389e680c9ecf584deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericTernaryOp </td>
          <td>(</td>
          <td class="paramtype">const TernaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given operator has a numeric return value. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00058">58</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00474">souffle::AstTernaryFunctor::isNumerical()</a>, and <a class="el" href="_ternary_functor_ops_8h_source.html#l00072">isSymbolicTernaryOp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                   {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">case</span> TernaryOp::SUBSTR:</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd31efb9f808712dfee9a892ec1dc08e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericUnaryOp </td>
          <td>(</td>
          <td class="paramtype">const UnaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given operator has a numeric return value. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00129">129</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">ACOS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">ACOSH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">ASIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">ASINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">ATAN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">ATANH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">COS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">COSH</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">LOG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">SIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">SINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">TAN</a>, and <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">TANH</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00297">souffle::AstUnaryFunctor::isNumerical()</a>, and <a class="el" href="_unary_functor_ops_8h_source.html#l00161">isSymbolicUnaryOp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                                               {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ORD:</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">case</span> UnaryOp::STRLEN:</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">case</span> UnaryOp::NEG:</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keywordflow">case</span> UnaryOp::BNOT:</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LNOT:</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SIN:</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COS:</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TAN:</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASIN:</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOS:</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATAN:</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SINH:</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COSH:</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TANH:</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASINH:</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOSH:</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATANH:</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LOG:</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">case</span> UnaryOp::EXP:</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a34c8a82b8d9ed840b32e93186002d18c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecordType </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a record type. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00327">327</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00550">souffle::AstSemanticChecker::checkRelationDeclaration()</a>, <a class="el" href="_type_system_8cpp_source.html#l00256">getTypeQualifier()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00331">isRecordType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                                    {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>RecordType*<span class="keyword">&gt;</span>(&amp;type);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a790e39fcdcb0e62caaee56e0bf7d3b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecordType </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are record types. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00331">331</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00871">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00327">isRecordType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                                    {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">isRecordType</a>);</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00871">Util.h:871</a></div></div>
<div class="ttc" id="namespacesouffle_html_a790e39fcdcb0e62caaee56e0bf7d3b45"><div class="ttname"><a href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">souffle::isRecordType</a></div><div class="ttdeci">bool isRecordType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are record types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00331">TypeSystem.cpp:331</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph.png" border="0" usemap="#namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph" alt=""/></div>
<map name="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph" id="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="237,5,337,32"/><area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="205,56,368,83"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="211,107,362,133"/><area shape="rect" id="node5" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="211,157,362,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac79c60fce08f12e1f11d9d342c17ce56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecursiveType </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a recursive type. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00335">335</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00885">any_of()</a>, <a class="el" href="_type_system_8h_source.html#l00127">souffle::UnionType::getElementTypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00156">souffle::RecordType::getFields()</a>.</p>
<div class="fragment"><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                       {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keyword">struct </span>visitor : <span class="keyword">public</span> VisitOnceTypeVisitor&lt;bool&gt; {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keyword">const</span> Type&amp; trg;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        visitor(<span class="keyword">const</span> Type&amp; trg) : trg(trg) {}</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keywordtype">bool</span> visit(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            <span class="keywordflow">if</span> (trg == type) {</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            <span class="keywordflow">return</span> VisitOnceTypeVisitor&lt;bool&gt;::visit(type);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        }</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keywordtype">bool</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            <span class="keyword">auto</span> reachesTrg = [&amp;](<span class="keyword">const</span> Type* cur) { <span class="keywordflow">return</span> this-&gt;visit(*cur); };</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(type.getElementTypes(), reachesTrg);</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        }</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordtype">bool</span> visitRecordType(<span class="keyword">const</span> RecordType&amp; type)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            <span class="keyword">auto</span> reachesTrg = [&amp;](<span class="keyword">const</span> RecordType::Field&amp; cur) { <span class="keywordflow">return</span> this-&gt;visit(cur.type); };</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(type.getFields(), reachesTrg);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        }</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    };</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="comment">// record types are recursive if they contain themselves</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> RecordType* r = dynamic_cast&lt;const RecordType*&gt;(&amp;type)) {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keyword">auto</span> reachesOrigin = visitor(type);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(r-&gt;getFields(),</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                [&amp;](<span class="keyword">const</span> RecordType::Field&amp; field) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> reachesOrigin(field.type); });</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00885">Util.h:885</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph.png" border="0" usemap="#namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph" alt=""/></div>
<map name="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph" id="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="238,5,346,32"/><area shape="rect" id="node3" href="classsouffle_1_1_union_type.html#abb58ef00e41f6e961f51c34e3d44fa68" title="souffle::UnionType\l::getElementTypes" alt="" coords="226,57,358,98"/><area shape="rect" id="node4" href="structsouffle_1_1_record_type.html#afe02aad8492cb87cc7524798151a34d3" title="souffle::RecordType\l::getFields" alt="" coords="222,122,362,163"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8cc19c66d9d13ce64e65f14dcabb43b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSubtypeOf </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether type a is a subtype of type b. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00365">365</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00059">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8cpp_source.html#l00311">isNumberType()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00319">isSymbolType()</a>.</p>

<p>Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00758">souffle::TypeAnalysis::analyseTypes()</a>, <a class="el" href="_type_system_8cpp_source.html#l00399">areSubtypesOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00504">getGreatestCommonSubtypes()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00410">getLeastCommonSupertypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                                               {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="comment">// make sure they are both in the same environment</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keyword">auto</span>&amp; environment = a.getTypeEnvironment();</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    assert(environment.isType(a) &amp;&amp; environment.isType(b));</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">// first check - a type is a sub-type of itself</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">if</span> (a == b) {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    }</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="comment">// check for predefined types</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">if</span> (b == environment.getNumberType()) {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>(a);</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    }</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="keywordflow">if</span> (b == environment.getSymbolType()) {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a>(a);</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="comment">// check primitive type chains</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="keywordflow">if</span> (isA&lt;PrimitiveType&gt;(a)) {</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(as&lt;PrimitiveType&gt;(a).getBaseType(), b)) {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        }</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// next - if b is a union type</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordflow">if</span> (isUnion(b)) {</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        <span class="keywordflow">return</span> isSubType(a, as&lt;UnionType&gt;(b));</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    }</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="comment">// done</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00315">TypeSystem.cpp:315</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00365">TypeSystem.cpp:365</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae9f1f97bcd38ff9cd112ade89e631b80"><div class="ttname"><a href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are symbol types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00323">TypeSystem.cpp:323</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph.png" border="0" usemap="#namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph" alt=""/></div>
<map name="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph" id="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="397,71,624,97"/><area shape="rect" id="node3" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="195,20,349,47"/><area shape="rect" id="node7" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="196,121,348,148"/><area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#a3607b9fb617c47df3da5050384b5f635" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="425,5,596,46"/><area shape="rect" id="node5" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="672,63,843,105"/><area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="891,63,1061,105"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="425,122,596,163"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a08c148b933873b05a8a7d79863d5f5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolicBinaryConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const BinaryConstraintOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether arguments of constraint are numeric. </p>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00162">162</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p>References <a class="el" href="_binary_constraint_ops_8h_source.html#l00136">isNumericBinaryConstraintOp()</a>.</p>

<p>Referenced by <a class="el" href="_ast_literal_8h_source.html#l00287">souffle::AstConstraint::isSymbolic()</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                                                                      {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#a90eb741155c2a50d6028ac5cfb1bb64f">isNumericBinaryConstraintOp</a>(op);</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a90eb741155c2a50d6028ac5cfb1bb64f"><div class="ttname"><a href="namespacesouffle.html#a90eb741155c2a50d6028ac5cfb1bb64f">souffle::isNumericBinaryConstraintOp</a></div><div class="ttdeci">bool isNumericBinaryConstraintOp(const BinaryConstraintOp op)</div><div class="ttdoc">Helper Functions for Binary Functors. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00136">BinaryConstraintOps.h:136</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a08c148b933873b05a8a7d79863d5f5b1_cgraph.png" border="0" usemap="#namespacesouffle_a08c148b933873b05a8a7d79863d5f5b1_cgraph" alt=""/></div>
<map name="namespacesouffle_a08c148b933873b05a8a7d79863d5f5b1_cgraph" id="namespacesouffle_a08c148b933873b05a8a7d79863d5f5b1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a90eb741155c2a50d6028ac5cfb1bb64f" title="Helper Functions for Binary Functors. " alt="" coords="224,5,389,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aff8ed81eb5556d66dba3cf285ecee213"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolicBinaryOp </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the operator has a symbolic return value. </p>

<p>Definition at line <a class="el" href="_binary_functor_ops_8h_source.html#l00138">138</a> of file <a class="el" href="_binary_functor_ops_8h_source.html">BinaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_binary_functor_ops_8h_source.html#l00110">isNumericBinaryOp()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00385">souffle::AstBinaryFunctor::isSymbolic()</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                                                  {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#a5ecdc282acb8ee99226175690bf397d0">isNumericBinaryOp</a>(op);</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a5ecdc282acb8ee99226175690bf397d0"><div class="ttname"><a href="namespacesouffle.html#a5ecdc282acb8ee99226175690bf397d0">souffle::isNumericBinaryOp</a></div><div class="ttdeci">bool isNumericBinaryOp(const BinaryOp op)</div><div class="ttdoc">Determines whether the given operator has a numeric return value. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_functor_ops_8h_source.html#l00110">BinaryFunctorOps.h:110</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aff8ed81eb5556d66dba3cf285ecee213_cgraph.png" border="0" usemap="#namespacesouffle_aff8ed81eb5556d66dba3cf285ecee213_cgraph" alt=""/></div>
<map name="namespacesouffle_aff8ed81eb5556d66dba3cf285ecee213_cgraph" id="namespacesouffle_aff8ed81eb5556d66dba3cf285ecee213_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a5ecdc282acb8ee99226175690bf397d0" title="Determines whether the given operator has a numeric return value. " alt="" coords="241,5,423,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a53727befba61d13b3545ef75df0963dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolicTernaryOp </td>
          <td>(</td>
          <td class="paramtype">const TernaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the operator has a symbolic return value. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00072">72</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_ternary_functor_ops_8h_source.html#l00058">isNumericTernaryOp()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00479">souffle::AstTernaryFunctor::isSymbolic()</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                                    {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#a886a8cccceb06e389e680c9ecf584deb">isNumericTernaryOp</a>(op);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a886a8cccceb06e389e680c9ecf584deb"><div class="ttname"><a href="namespacesouffle.html#a886a8cccceb06e389e680c9ecf584deb">souffle::isNumericTernaryOp</a></div><div class="ttdeci">bool isNumericTernaryOp(const TernaryOp op)</div><div class="ttdoc">Determines whether the given operator has a numeric return value. </div><div class="ttdef"><b>Definition:</b> <a href="_ternary_functor_ops_8h_source.html#l00058">TernaryFunctorOps.h:58</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a53727befba61d13b3545ef75df0963dd_cgraph.png" border="0" usemap="#namespacesouffle_a53727befba61d13b3545ef75df0963dd_cgraph" alt=""/></div>
<map name="namespacesouffle_a53727befba61d13b3545ef75df0963dd_cgraph" id="namespacesouffle_a53727befba61d13b3545ef75df0963dd_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a886a8cccceb06e389e680c9ecf584deb" title="Determines whether the given operator has a numeric return value. " alt="" coords="248,5,437,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae4786045b9e6b3d5543115981971eb89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolicUnaryOp </td>
          <td>(</td>
          <td class="paramtype">const UnaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given operator has a symbolic return value. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00161">161</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_unary_functor_ops_8h_source.html#l00129">isNumericUnaryOp()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00302">souffle::AstUnaryFunctor::isSymbolic()</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                                {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#abd31efb9f808712dfee9a892ec1dc08e">isNumericUnaryOp</a>(op);</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_abd31efb9f808712dfee9a892ec1dc08e"><div class="ttname"><a href="namespacesouffle.html#abd31efb9f808712dfee9a892ec1dc08e">souffle::isNumericUnaryOp</a></div><div class="ttdeci">bool isNumericUnaryOp(const UnaryOp op)</div><div class="ttdoc">Returns whether the given operator has a numeric return value. </div><div class="ttdef"><b>Definition:</b> <a href="_unary_functor_ops_8h_source.html#l00129">UnaryFunctorOps.h:129</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae4786045b9e6b3d5543115981971eb89_cgraph.png" border="0" usemap="#namespacesouffle_ae4786045b9e6b3d5543115981971eb89_cgraph" alt=""/></div>
<map name="namespacesouffle_ae4786045b9e6b3d5543115981971eb89_cgraph" id="namespacesouffle_ae4786045b9e6b3d5543115981971eb89_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abd31efb9f808712dfee9a892ec1dc08e" title="Returns whether the given operator has a numeric return value. " alt="" coords="241,5,421,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a11f6c352eec6bde7b5a0b143ffe64e3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolType </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a symbol type. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00319">319</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_type_system_8h_source.html#l00357">souffle::TypeEnvironment::getSymbolType()</a>, and <a class="el" href="_type_system_8h_source.html#l00059">souffle::Type::getTypeEnvironment()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8cpp_source.html#l00256">getTypeQualifier()</a>, <a class="el" href="_type_system_8cpp_source.html#l00365">isSubtypeOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00323">isSymbolType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                                    {</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getSymbolType());</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph.png" border="0" usemap="#namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph" alt=""/></div>
<map name="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph" id="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="233,5,404,46"/><area shape="rect" id="node5" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="205,71,432,97"/><area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="480,5,651,46"/><area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="699,5,869,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae9f1f97bcd38ff9cd112ade89e631b80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolType </td>
          <td>(</td>
          <td class="paramtype">const TypeSet &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are symbol types. </p>

<p>Definition at line <a class="el" href="_type_system_8cpp_source.html#l00323">323</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00871">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00205">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00210">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00319">isSymbolType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                                    {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a>);</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00871">Util.h:871</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae9f1f97bcd38ff9cd112ade89e631b80"><div class="ttname"><a href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are symbol types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00323">TypeSystem.cpp:323</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph.png" border="0" usemap="#namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph" alt=""/></div>
<map name="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph" id="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="237,5,337,32"/><area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ab8550c260bf67005ef909fa4ad164509" title="Emptiness check. " alt="" coords="205,56,368,83"/><area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad06daeb492b593d454e1e85a5a81d8eb" title="Universality check. " alt="" coords="211,107,362,133"/><area shape="rect" id="node5" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="211,157,363,184"/><area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a66b0c5761bcf5248516f08310f3b0817" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="444,121,615,162"/><area shape="rect" id="node9" href="classsouffle_1_1_type.html#ac0e65ae3329b48ff0f0ad4c1b179b438" title="souffle::Type::getTypeEnvironment" alt="" coords="416,187,643,213"/><area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#ad66cb326f809dc980e7901dfbe1fcdc5" title="souffle::TypeEnvironment\l::getType" alt="" coords="691,121,861,162"/><area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#af6f82790cb9e31b0efb8583894db3fa3" title="souffle::TypeEnvironment\l::isType" alt="" coords="909,121,1080,162"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7d08224020b450cc75146bcec8a281bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isTransactionProfilingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function to determine whether transaction-profiling is enabled or disabled;. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01240">1240</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_b_tree_8h_source.html#l01277">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true &gt;::insert()</a>, and <a class="el" href="_b_tree_8h_source.html#l01979">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true &gt;::printStats()</a>.</p>
<div class="fragment"><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;                                            {</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> res = std::getenv(<span class="stringliteral">&quot;SOUFFLE_PROFILE_TRANSACTIONS&quot;</span>);</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe4e3f19879707216a2758b03f4e2deb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Printer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, Printer&gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00581">581</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_synthesiser_8cpp_source.html#l00267">p</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_explain_provenance_s_l_d_8h_source.html#l00122">souffle::ExplainProvenanceSLD::explain()</a>, <a class="el" href="_util_8h_source.html#l00593">join()</a>, <a class="el" href="_ast_parser_utils_8cpp_source.html#l00135">operator&lt;&lt;()</a>, <a class="el" href="_util_8h_source.html#l00640">std::operator&lt;&lt;()</a>, <a class="el" href="_ast_relation_identifier_8h_source.html#l00086">souffle::AstRelationIdentifier::print()</a>, <a class="el" href="_ast_type_8h_source.html#l00093">souffle::AstTypeIdentifier::print()</a>, <a class="el" href="_ast_component_8h_source.html#l00094">souffle::AstComponentType::print()</a>, <a class="el" href="_interpreter_index_8h_source.html#l00123">souffle::InterpreterIndexOrder::print()</a>, <a class="el" href="_type_system_8cpp_source.html#l00041">souffle::UnionType::print()</a>, <a class="el" href="_type_system_8cpp_source.html#l00051">souffle::RecordType::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00163">souffle::RamStore::print()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00154">souffle::AstProgram::print()</a>, <a class="el" href="_symbol_table_8h_source.html#l00197">souffle::SymbolTable::print()</a>, <a class="el" href="_ast_type_8h_source.html#l00215">souffle::AstUnionType::print()</a>, <a class="el" href="_ram_condition_8h_source.html#l00247">souffle::RamNotExists::print()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00495">souffle::TopologicallySortedSCCGraph::print()</a>, <a class="el" href="_type_system_8h_source.html#l00283">souffle::TypeSet::print()</a>, <a class="el" href="_rule_scheduler_8h_source.html#l00320">souffle::scheduler::Problem&lt; CostModel &gt;::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00365">souffle::RamFact::print()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00097">souffle::AstClause::print()</a>, <a class="el" href="_ram_operation_8cpp_source.html#l00213">souffle::RamAggregate::print()</a>, <a class="el" href="_ast_component_8h_source.html#l00396">souffle::AstComponent::print()</a>, <a class="el" href="_constraints_8h_source.html#l00414">souffle::Problem&lt; Var &gt;::print()</a>, <a class="el" href="_ram_operation_8cpp_source.html#l00258">souffle::RamProject::print()</a>, <a class="el" href="_ram_value_8h_source.html#l00495">souffle::RamPack::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00514">souffle::RamSequence::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00560">souffle::AstRecordInit::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00583">souffle::RamParallel::print()</a>, <a class="el" href="_ast_argument_8cpp_source.html#l00045">souffle::AstAggregator::print()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00260">souffle::SCCGraph::printDot()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00279">souffle::SCCGraph::printJson()</a>, <a class="el" href="_rule_scheduler_8h_source.html#l00242">souffle::scheduler::Problem&lt; CostModel &gt;::solve()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00140">souffle::detail::BddbddbConverter::visitAtom()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00112">souffle::detail::BddbddbConverter::visitClause()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00085">souffle::detail::BddbddbConverter::visitRelation()</a>, and <a class="el" href="_bddbddb_backend_8cpp_source.html#l00211">souffle::detail::BddbddbConverter::visitRelationIdentifier()</a>.</p>
<div class="fragment"><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                                                                              {</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keywordflow">return</span> detail::joined_sequence&lt;Iter, Printer&gt;(a, b, sep, <a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2ff8ab73e5403aebf8bc9e0cd8a17655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt;<a class="el" href="structsouffle_1_1id.html">id</a>&lt;T&gt; &gt; &gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00593">593</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00581">join()</a>.</p>
<div class="fragment"><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                                                                  {</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(a, b, sep, detail::print&lt;id&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00617">Util.h:617</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph.png" border="0" usemap="#namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph" alt=""/></div>
<map name="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph" id="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="145,5,234,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af5411f3812147edc8be88140d80308bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, Printer&gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00605">605</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00581">join()</a>, and <a class="el" href="_synthesiser_8cpp_source.html#l00267">p</a>.</p>
<div class="fragment"><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                                                                                                      {</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(c.begin(), c.end(), sep, <a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
<div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00617">Util.h:617</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph.png" border="0" usemap="#namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph" alt=""/></div>
<map name="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph" id="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="145,5,234,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af2f126a2c7d2ee710ec8600b2af64da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt;<a class="el" href="structsouffle_1_1id.html">id</a>&lt;T&gt; &gt; &gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00617">617</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00581">join()</a>.</p>
<div class="fragment"><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(c.begin(), c.end(), sep, detail::print&lt;id&lt;T&gt;&gt;());</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00617">Util.h:617</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph.png" border="0" usemap="#namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph" alt=""/></div>
<map name="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph" id="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="145,5,234,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a052d35be8e032f425317fd1b6d7e487a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="main_8cpp_source.html#l00119">119</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l01048">baseName()</a>, <a class="el" href="main_8cpp_source.html#l00098">compileToBinary()</a>, <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>, <a class="el" href="_interpreter_8cpp_source.html#l00987">DirectExecution</a>, <a class="el" href="_macro_8h_source.html#l00050">ERROR</a>, <a class="el" href="main_8cpp_source.html#l00070">executeBinary()</a>, <a class="el" href="_util_8h_source.html#l00945">existDir()</a>, <a class="el" href="_util_8h_source.html#l00932">existFile()</a>, <a class="el" href="_explain_8h_source.html#l00269">explain()</a>, <a class="el" href="_util_8h_source.html#l01031">findTool()</a>, <a class="el" href="_debug_report_8cpp_source.html#l00210">souffle::DebugReporter::generateDebugReport()</a>, <a class="el" href="_debug_report_8cpp_source.html#l00150">souffle::DebugReporter::getCodeSection()</a>, <a class="el" href="_global_8h_source.html#l00112">souffle::MainConfig::help()</a>, <a class="el" href="_util_8h_source.html#l01138">identifier()</a>, <a class="el" href="_util_8h_source.html#l00958">isExecutable()</a>, <a class="el" href="_util_8h_source.html#l00088">isNumber()</a>, <a class="el" href="_util_8h_source.html#l00911">now()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00076">souffle::ParserDriver::parseTranslationUnit()</a>, <a class="el" href="_global_8cpp_source.html#l00005">souffle::MainConfig::processArgs()</a>, <a class="el" href="_interpreter_8cpp_source.html#l01002">ScheduledExecution</a>, <a class="el" href="_util_8h_source.html#l01068">simpleName()</a>, <a class="el" href="_util_8h_source.html#l01098">tempFile()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00222">toBddbddb()</a>, <a class="el" href="_ast_translator_8h_source.html#l00084">souffle::AstTranslator::translateUnit()</a>, <a class="el" href="_bddbddb_backend_8h_source.html#l00047">souffle::UnsupportedConstructException::what()</a>, and <a class="el" href="_util_8h_source.html#l00965">which()</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00553">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                                {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">/* Time taking for overall runtime */</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keyword">auto</span> souffle_start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">/* have all to do with command line arguments in its own scope, as these are accessible through the global</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">     * configuration only */</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        Global::config().processArgs(argc, argv,</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                []() {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    std::stringstream header;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                    header &lt;&lt; <span class="stringliteral">&quot;============================================================================&quot;</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                           &lt;&lt; std::endl;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                    header &lt;&lt; <span class="stringliteral">&quot;souffle -- A datalog engine.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                    header &lt;&lt; <span class="stringliteral">&quot;Usage: souffle [OPTION] FILE.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    header &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                           &lt;&lt; std::endl;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                    header &lt;&lt; <span class="stringliteral">&quot;Options:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    <span class="keywordflow">return</span> header.str();</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                }(),</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                []() {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                    std::stringstream footer;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                           &lt;&lt; std::endl;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;Version: &quot;</span> &lt;&lt; PACKAGE_VERSION &lt;&lt; <span class="stringliteral">&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                           &lt;&lt; std::endl;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2016-18 The Souffle Developers.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2013-16 Oracle and/or its affiliates.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;All rights reserved.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    footer &lt;&lt; <span class="stringliteral">&quot;============================================================================&quot;</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                           &lt;&lt; std::endl;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                    <span class="keywordflow">return</span> footer.str();</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                }(),</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                <span class="comment">// command line options, the environment will be filled with the arguments passed to them, or</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="comment">// the empty string if they take none</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                []() {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                    MainOption opts[] = {</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                            {<span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                                    <span class="stringliteral">&quot;&quot;</span>},  <span class="comment">// main option, the datalog program itself, key is always empty</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                            {<span class="stringliteral">&quot;fact-dir&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Specify directory for fact files.&quot;</span>},</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                            {<span class="stringliteral">&quot;include-dir&quot;</span>, <span class="charliteral">&#39;I&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;Specify directory for include files.&quot;</span>},</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                            {<span class="stringliteral">&quot;output-dir&quot;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                    <span class="stringliteral">&quot;Specify directory for output files (if &lt;DIR&gt; is -, stdout is used).&quot;</span>},</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                            {<span class="stringliteral">&quot;jobs&quot;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                    <span class="stringliteral">&quot;Run interpreter/compiler in parallel using N threads, N=auto for system &quot;</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                    <span class="stringliteral">&quot;default.&quot;</span>},</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                            {<span class="stringliteral">&quot;compile&quot;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                                    <span class="stringliteral">&quot;Generate C++ source code, compile to a binary executable, then run this &quot;</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                                    <span class="stringliteral">&quot;executable.&quot;</span>},</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                            {<span class="stringliteral">&quot;auto-schedule&quot;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                    <span class="stringliteral">&quot;Switch on automated clause scheduling for compiler.&quot;</span>},</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                            {<span class="stringliteral">&quot;generate&quot;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                                    <span class="stringliteral">&quot;Generate C++ source code for the given Datalog program and write it to &quot;</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                    <span class="stringliteral">&quot;&lt;FILE&gt;.&quot;</span>},</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                            {<span class="stringliteral">&quot;no-warn&quot;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Disable warnings.&quot;</span>},</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                            {<span class="stringliteral">&quot;magic-transform&quot;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="stringliteral">&quot;RELATIONS&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                    <span class="stringliteral">&quot;Enable magic set transformation changes on the given relations, use &#39;*&#39; &quot;</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                    <span class="stringliteral">&quot;for all.&quot;</span>},</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                            {<span class="stringliteral">&quot;dl-program&quot;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                                    <span class="stringliteral">&quot;Generate C++ source code, written to &lt;FILE&gt;, and compile this to a &quot;</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                                    <span class="stringliteral">&quot;binary executable (without executing it).&quot;</span>},</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                            {<span class="stringliteral">&quot;profile&quot;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                                    <span class="stringliteral">&quot;Enable profiling, and write profile data to &lt;FILE&gt;.&quot;</span>},</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                            {<span class="stringliteral">&quot;bddbddb&quot;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Convert input into bddbddb file format.&quot;</span>},</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                            {<span class="stringliteral">&quot;debug-report&quot;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Write HTML debug report to &lt;FILE&gt;.&quot;</span>},</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="preprocessor">#ifdef USE_PROVENANCE</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="preprocessor"></span>                            {<span class="stringliteral">&quot;provenance&quot;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="stringliteral">&quot;EXPLAIN&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                    <span class="stringliteral">&quot;Enable provenance information via guided SLD.&quot;</span>},</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="preprocessor"></span>                            {<span class="stringliteral">&quot;data-structure&quot;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="stringliteral">&quot;type&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                                    <span class="stringliteral">&quot;Specify data structure (brie/btree/eqrel/hashmap).&quot;</span>},</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                            {<span class="stringliteral">&quot;verbose&quot;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Verbose output.&quot;</span>},</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                            {<span class="stringliteral">&quot;help&quot;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Display this help message.&quot;</span>}};</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                    <span class="keywordflow">return</span> std::vector&lt;MainOption&gt;(std::begin(opts), std::end(opts));</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                }());</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="comment">// ------ command line arguments -------------</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="comment">/* for the help option, if given simply print the help text then exit */</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;&quot;</span>) || Global::config().has(<span class="stringliteral">&quot;help&quot;</span>)) {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            std::cerr &lt;&lt; Global::config().help();</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="comment">/* check that datalog program exists */</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;&quot;</span>))) {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;cannot open file &quot;</span> + std::string(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;&quot;</span>)));</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="comment">/* for the jobs option, to determine the number of threads used */</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;jobs&quot;</span>)) {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">isNumber</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>).c_str())) {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                <span class="keywordflow">if</span> (std::stoi(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>)) &lt; 1) {</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                    <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;Number of jobs in the -j/--jobs options must be greater than zero!&quot;</span>);</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                }</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;jobs&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>)) {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                    <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;Wrong parameter &quot;</span> + Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>) + <span class="stringliteral">&quot; for option -j/--jobs!&quot;</span>);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                Global::config().set(<span class="stringliteral">&quot;jobs&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>);</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;Wrong parameter &quot;</span> + Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>) + <span class="stringliteral">&quot; for option -j/--jobs!&quot;</span>);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="comment">/* if an output directory is given, check it exists */</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;output-dir&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;output-dir&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>) &amp;&amp;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                !<a class="code" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;output-dir&quot;</span>)) &amp;&amp;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                !(Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>) ||</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                        (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>)))) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;output directory &quot;</span> + Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;output-dir&quot;</span>) + <span class="stringliteral">&quot; does not exists&quot;</span>);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="comment">/* ensure that if auto-scheduling is enabled an output file is given */</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;auto-schedule&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;no executable is specified for auto-scheduling (option -o &lt;FILE&gt;)&quot;</span>);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="comment">/* collect all input directories for the c pre-processor */</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;include-dir&quot;</span>)) {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            std::string currentInclude = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            std::string allIncludes = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>&amp; ch : Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;include-dir&quot;</span>)) {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39; &#39;</span>) {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a>(currentInclude)) {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                        <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;include directory &quot;</span> + currentInclude + <span class="stringliteral">&quot; does not exists&quot;</span>);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                        allIncludes += <span class="stringliteral">&quot; -I&quot;</span>;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                        allIncludes += currentInclude;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                        currentInclude = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                    }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                    currentInclude += ch;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                }</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            }</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            allIncludes += <span class="stringliteral">&quot; -I&quot;</span> + currentInclude;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            Global::config().set(<span class="stringliteral">&quot;include-dir&quot;</span>, allIncludes);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        }</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="comment">/* turn on compilation of executables */</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            Global::config().set(<span class="stringliteral">&quot;compile&quot;</span>);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        }</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="comment">/* disable provenance with multithreading */</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;provenance&quot;</span>)) {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;jobs&quot;</span>)) {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>) != <span class="stringliteral">&quot;1&quot;</span>) {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                    <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;provenance cannot be enabled with multiple jobs.&quot;</span>);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                }</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    }</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="comment">// ------ start souffle -------------</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    std::string souffleExecutable = <a class="code" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">which</a>(argv[0]);</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">if</span> (souffleExecutable.empty()) {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;failed to determine souffle executable path&quot;</span>);</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    }</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="comment">/* Create the pipe to establish a communication between cpp and souffle */</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    std::string cmd = <a class="code" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">::which</a>(<span class="stringliteral">&quot;mcpp&quot;</span>);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(cmd)) {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;failed to locate mcpp pre-processor&quot;</span>);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    }</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    cmd += <span class="stringliteral">&quot; -W0 &quot;</span> + Global::config().get(<span class="stringliteral">&quot;include-dir&quot;</span>) + <span class="stringliteral">&quot; &quot;</span> + Global::config().get(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    FILE* in = popen(cmd.c_str(), <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">/* Time taking for parsing */</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="keyword">auto</span> parser_start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="comment">// ------- parse program -------------</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="comment">// parse file</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    SymbolTable symTab;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    ErrorReport errReport(Global::config().has(<span class="stringliteral">&quot;no-warn&quot;</span>));</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    DebugReport debugReport;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    std::unique_ptr&lt;AstTranslationUnit&gt; astTranslationUnit =</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            ParserDriver::parseTranslationUnit(<span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, in, symTab, errReport, debugReport);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="comment">// close input pipe</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordtype">int</span> preprocessor_status = pclose(in);</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">if</span> (preprocessor_status == -1) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        perror(<span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;failed to close pre-processor pipe&quot;</span>);</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">/* Report run-time of the parser if verbose flag is set */</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keyword">auto</span> parser_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Parse Time: &quot;</span> &lt;&lt; std::chrono::duration&lt;double&gt;(parser_end - parser_start).count()</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot;sec\n&quot;</span>;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">// ------- check for parse errors -------------</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">if</span> (astTranslationUnit-&gt;getErrorReport().getNumErrors() != 0) {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        std::cerr &lt;&lt; astTranslationUnit-&gt;getErrorReport();</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        std::cerr &lt;&lt; std::to_string(astTranslationUnit-&gt;getErrorReport().getNumErrors()) +</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                             <span class="stringliteral">&quot; errors generated, evaluation aborted&quot;</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                  &lt;&lt; std::endl;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        exit(1);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="comment">// ------- rewriting / optimizations -------------</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">/* set up additional global options based on pragma declaratives */</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    (std::make_unique&lt;AstPragmaChecker&gt;())-&gt;apply(*astTranslationUnit);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    std::vector&lt;std::unique_ptr&lt;AstTransformer&gt;&gt; astTransforms;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    astTransforms.push_back(std::make_unique&lt;AstComponentChecker&gt;());</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    astTransforms.push_back(std::make_unique&lt;ComponentInstantiationTransformer&gt;());</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    astTransforms.push_back(std::make_unique&lt;UniqueAggregationVariablesTransformer&gt;());</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    astTransforms.push_back(std::make_unique&lt;AstSemanticChecker&gt;());</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    astTransforms.push_back(std::make_unique&lt;InlineRelationsTransformer&gt;());</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    astTransforms.push_back(std::make_unique&lt;ReduceExistentialsTransformer&gt;());</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    astTransforms.push_back(std::make_unique&lt;ExtractDisconnectedLiteralsTransformer&gt;());</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;bddbddb&quot;</span>).empty()) {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        astTransforms.push_back(std::make_unique&lt;ResolveAliasesTransformer&gt;());</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    astTransforms.push_back(std::make_unique&lt;RemoveRelationCopiesTransformer&gt;());</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    astTransforms.push_back(std::make_unique&lt;MaterializeAggregationQueriesTransformer&gt;());</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    astTransforms.push_back(std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;());</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    astTransforms.push_back(std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;());</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;magic-transform&quot;</span>)) {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        astTransforms.push_back(std::make_unique&lt;NormaliseConstraintsTransformer&gt;());</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        astTransforms.push_back(std::make_unique&lt;MagicSetTransformer&gt;());</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;bddbddb&quot;</span>).empty()) {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            astTransforms.push_back(std::make_unique&lt;ResolveAliasesTransformer&gt;());</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        astTransforms.push_back(std::make_unique&lt;RemoveRelationCopiesTransformer&gt;());</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        astTransforms.push_back(std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;());</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        astTransforms.push_back(std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;());</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    astTransforms.push_back(std::make_unique&lt;AstExecutionPlanChecker&gt;());</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;auto-schedule&quot;</span>)) {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        astTransforms.push_back(std::make_unique&lt;AutoScheduleTransformer&gt;());</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    }</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="preprocessor">#ifdef USE_PROVENANCE</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="preprocessor"></span>    <span class="comment">// Add provenance information by transforming to records</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;provenance&quot;</span>)) {</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        astTransforms.push_back(std::make_unique&lt;ProvenanceTransformer&gt;());</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    }</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="comment">// Enable debug reports for the AST astTransforms</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">if</span> (!Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;debug-report&quot;</span>).empty()) {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keyword">auto</span> parser_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        std::string runtimeStr =</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                <span class="stringliteral">&quot;(&quot;</span> + std::to_string(std::chrono::duration&lt;double&gt;(parser_end - parser_start).count()) + <span class="stringliteral">&quot;s)&quot;</span>;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        DebugReporter::generateDebugReport(*astTranslationUnit, <span class="stringliteral">&quot;Parsing&quot;</span>, <span class="stringliteral">&quot;After Parsing &quot;</span> + runtimeStr);</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; astTransforms.size(); i++) {</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            astTransforms[i] =</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                    std::unique_ptr&lt;AstTransformer&gt;(<span class="keyword">new</span> DebugReporter(std::move(astTransforms[i])));</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; transform : astTransforms) {</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        transform-&gt;apply(*astTranslationUnit);</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="comment">/* Abort evaluation of the program if errors were encountered */</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">if</span> (astTranslationUnit-&gt;getErrorReport().getNumErrors() != 0) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            std::cerr &lt;&lt; astTranslationUnit-&gt;getErrorReport();</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            std::cerr &lt;&lt; std::to_string(astTranslationUnit-&gt;getErrorReport().getNumErrors()) +</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                                 <span class="stringliteral">&quot; errors generated, evaluation aborted&quot;</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                      &lt;&lt; std::endl;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            exit(1);</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        }</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="comment">// ------- (optional) conversions -------------</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="comment">// conduct the bddbddb file export</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">if</span> (!Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;bddbddb&quot;</span>).empty()) {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;bddbddb&quot;</span>) == <span class="stringliteral">&quot;-&quot;</span>) {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                <span class="comment">// use STD-OUT</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                <a class="code" href="namespacesouffle.html#aa5e347aaf113d69fceb9d2eb6f8b052e">toBddbddb</a>(std::cout, *astTranslationUnit);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                <span class="comment">// create an output file</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                std::ofstream out(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;bddbddb&quot;</span>).c_str());</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                <a class="code" href="namespacesouffle.html#aa5e347aaf113d69fceb9d2eb6f8b052e">toBddbddb</a>(out, *astTranslationUnit);</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            }</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> UnsupportedConstructException&amp; uce) {</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;failed to convert input specification into bddbddb syntax because &quot;</span> +</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                    std::string(uce.what()));</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        }</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="comment">// ------- execution -------------</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keyword">auto</span> ram_start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="comment">/* translate AST to RAM */</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    std::unique_ptr&lt;RamTranslationUnit&gt; ramTranslationUnit =</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            AstTranslator().translateUnit(*astTranslationUnit);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    std::vector&lt;std::unique_ptr&lt;RamTransformer&gt;&gt; ramTransforms;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    ramTransforms.push_back(std::unique_ptr&lt;RamTransformer&gt;(<span class="keyword">new</span> RamSemanticChecker()));</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; transform : ramTransforms) {</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        transform-&gt;apply(*ramTranslationUnit);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="comment">/* Abort evaluation of the program if errors were encountered */</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">if</span> (ramTranslationUnit-&gt;getErrorReport().getNumErrors() != 0) {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            std::cerr &lt;&lt; ramTranslationUnit-&gt;getErrorReport();</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            std::cerr &lt;&lt; std::to_string(ramTranslationUnit-&gt;getErrorReport().getNumErrors()) +</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                                 <span class="stringliteral">&quot; errors generated, evaluation aborted&quot;</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                      &lt;&lt; std::endl;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            exit(1);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        }</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    }</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">if</span> (ramTranslationUnit-&gt;getErrorReport().getNumIssues() != 0) {</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        std::cerr &lt;&lt; ramTranslationUnit-&gt;getErrorReport();</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    }</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keywordflow">if</span> (!Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;debug-report&quot;</span>).empty()) {</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <span class="keywordflow">if</span> (ramTranslationUnit-&gt;getProgram()) {</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            <span class="keyword">auto</span> ram_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            std::string runtimeStr =</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                    <span class="stringliteral">&quot;(&quot;</span> + std::to_string(std::chrono::duration&lt;double&gt;(ram_end - ram_start).count()) + <span class="stringliteral">&quot;s)&quot;</span>;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            std::stringstream ramProgStr;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            ramProgStr &lt;&lt; *ramTranslationUnit-&gt;getProgram();</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            astTranslationUnit-&gt;getDebugReport().addSection(DebugReporter::getCodeSection(</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                    <span class="stringliteral">&quot;ram-program&quot;</span>, <span class="stringliteral">&quot;RAM Program &quot;</span> + runtimeStr, ramProgStr.str()));</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        }</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <span class="keywordflow">if</span> (!ramTranslationUnit-&gt;getDebugReport().empty()) {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            std::ofstream debugReportStream(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;debug-report&quot;</span>));</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            debugReportStream &lt;&lt; ramTranslationUnit-&gt;getDebugReport();</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        }</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">if</span> (!ramTranslationUnit-&gt;getProgram()-&gt;getMain()) {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    };</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>) &amp;&amp;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            !Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>)) {</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="comment">// ------- interpreter -------------</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="comment">// configure interpreter</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        std::unique_ptr&lt;Interpreter&gt; interpreter = (Global::config().has(<span class="stringliteral">&quot;auto-schedule&quot;</span>))</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                                           ? std::make_unique&lt;Interpreter&gt;(<a class="code" href="namespacesouffle.html#ae807f7b8118a77f250c57d1c3a08905e">ScheduledExecution</a>)</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                                                           : std::make_unique&lt;Interpreter&gt;(<a class="code" href="namespacesouffle.html#ad9fcff3b64ca9bdaadbe6a038ee2e4a5">DirectExecution</a>);</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        std::unique_ptr&lt;InterpreterEnvironment&gt; env = interpreter-&gt;execute(*ramTranslationUnit);</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="preprocessor">#ifdef USE_PROVENANCE</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="preprocessor"></span>        <span class="comment">// only run explain interface if interpreted</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;provenance&quot;</span>) &amp;&amp; env != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            <span class="comment">// construct SouffleProgram from env</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            InterpreterProgInterface interface(*ramTranslationUnit, *interpreter, *env);</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;1&quot;</span>) {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                <a class="code" href="namespacesouffle.html#a783c22acbaa814d35b915fa6d09696d8">explain</a>(interface, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;2&quot;</span>) {</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                <a class="code" href="namespacesouffle.html#a783c22acbaa814d35b915fa6d09696d8">explain</a>(interface, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            }</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        }</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="comment">// ------- compiler -------------</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        std::string compileCmd = <a class="code" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">::findTool</a>(<span class="stringliteral">&quot;souffle-compile&quot;</span>, souffleExecutable, <span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="comment">/* Fail if a souffle-compile executable is not found */</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(compileCmd)) {</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            <a class="code" href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a>(<span class="stringliteral">&quot;failed to locate souffle-compile&quot;</span>);</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        }</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        compileCmd += <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        std::unique_ptr&lt;Synthesiser&gt; synthesiser = std::make_unique&lt;Synthesiser&gt;();</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="comment">// configure compiler</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            synthesiser-&gt;setReportTarget(std::cout);</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        }</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            <span class="comment">// Find the base filename for code generation and execution</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            std::string baseFilename;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                baseFilename = Global::config().get(<span class="stringliteral">&quot;dl-program&quot;</span>);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>)) {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                baseFilename = Global::config().get(<span class="stringliteral">&quot;generate&quot;</span>);</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                <span class="comment">// trim .cpp extension if it exists</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                <span class="keywordflow">if</span> (baseFilename.size() &gt;= 4 &amp;&amp; baseFilename.substr(baseFilename.size() - 4) == <span class="stringliteral">&quot;.cpp&quot;</span>) {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                    baseFilename = baseFilename.substr(0, baseFilename.size() - 4);</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                }</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                baseFilename = <a class="code" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a>();</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(baseFilename) == <span class="stringliteral">&quot;/&quot;</span> || <a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(baseFilename) == <span class="stringliteral">&quot;.&quot;</span>) {</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                baseFilename = <a class="code" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a>();</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            }</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            std::string baseIdentifier = <a class="code" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">identifier</a>(<a class="code" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">simpleName</a>(baseFilename));</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            std::string sourceFilename = baseFilename + <span class="stringliteral">&quot;.cpp&quot;</span>;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            std::ofstream os(sourceFilename);</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            synthesiser-&gt;generateCode(*ramTranslationUnit, os, baseIdentifier);</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            os.close();</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>)) {</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                <a class="code" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">compileToBinary</a>(compileCmd, sourceFilename);</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                <span class="comment">// run compiled C++ program if requested.</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                    <a class="code" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">executeBinary</a>(baseFilename);</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                }</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;            }</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        } <span class="keywordflow">catch</span> (std::exception&amp; e) {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    }</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <span class="comment">/* Report overall run-time in verbose mode */</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        <span class="keyword">auto</span> souffle_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Total Time: &quot;</span> &lt;&lt; std::chrono::duration&lt;double&gt;(souffle_end - souffle_start).count()</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot;sec\n&quot;</span>;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    }</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ad9fcff3b64ca9bdaadbe6a038ee2e4a5"><div class="ttname"><a href="namespacesouffle.html#ad9fcff3b64ca9bdaadbe6a038ee2e4a5">souffle::DirectExecution</a></div><div class="ttdeci">const QueryExecutionStrategy DirectExecution</div><div class="ttdoc">With this strategy queries will be processed as they are stated by the user. </div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_8cpp_source.html#l00987">Interpreter.cpp:987</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab31e06999eb72da2f6d9a85bdd3dda59"><div class="ttname"><a href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">souffle::simpleName</a></div><div class="ttdeci">std::string simpleName(const std::string &amp;path)</div><div class="ttdoc">File name, with extension removed. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01068">Util.h:1068</a></div></div>
<div class="ttc" id="_macro_8h_html_a02ce8a968600d004ba60858425c46307"><div class="ttname"><a href="_macro_8h.html#a02ce8a968600d004ba60858425c46307">ERROR</a></div><div class="ttdeci">#define ERROR(...)</div><div class="ttdef"><b>Definition:</b> <a href="_macro_8h_source.html#l00050">Macro.h:50</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1c65551944c7ecf6f44ec851b49bdbb0"><div class="ttname"><a href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a></div><div class="ttdeci">time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00911">Util.h:911</a></div></div>
<div class="ttc" id="namespacesouffle_html_a783c22acbaa814d35b915fa6d09696d8"><div class="ttname"><a href="namespacesouffle.html#a783c22acbaa814d35b915fa6d09696d8">souffle::explain</a></div><div class="ttdeci">void explain(SouffleProgram &amp;prog, bool sld=true, bool ncurses=false)</div><div class="ttdef"><b>Definition:</b> <a href="_explain_8h_source.html#l00269">Explain.h:269</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00958">Util.h:958</a></div></div>
<div class="ttc" id="namespacesouffle_html_ad0e8debde5608979e041dd30e044612a"><div class="ttname"><a href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">souffle::identifier</a></div><div class="ttdeci">std::string identifier(std::string id)</div><div class="ttdoc">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01138">Util.h:1138</a></div></div>
<div class="ttc" id="namespacesouffle_html_a79fa4170c4094bc943de6fa5acb5796e"><div class="ttname"><a href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">souffle::existDir</a></div><div class="ttdeci">bool existDir(const std::string &amp;name)</div><div class="ttdoc">Check whether a directory exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00945">Util.h:945</a></div></div>
<div class="ttc" id="namespacesouffle_html_af944f0c474df29e5c8e45e4b7df60be5"><div class="ttname"><a href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">souffle::findTool</a></div><div class="ttdeci">std::string findTool(const std::string &amp;tool, const std::string &amp;base, const std::string &amp;path)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01031">Util.h:1031</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6e9757564e85959db8b14a9be7d544e1"><div class="ttname"><a href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">souffle::which</a></div><div class="ttdeci">std::string which(const std::string &amp;name)</div><div class="ttdoc">Simple implementation of a which tool. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00965">Util.h:965</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1752bf432062837ed19ae6ac73ab177c"><div class="ttname"><a href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">souffle::executeBinary</a></div><div class="ttdeci">void executeBinary(const std::string &amp;binaryFilename)</div><div class="ttdoc">Executes a binary file. </div><div class="ttdef"><b>Definition:</b> <a href="main_8cpp_source.html#l00070">main.cpp:70</a></div></div>
<div class="ttc" id="namespacesouffle_html_a69107e934a60222580ee8ba6882dc3d3"><div class="ttname"><a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a></div><div class="ttdeci">bool existFile(const std::string &amp;name)</div><div class="ttdoc">Check whether a file exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00932">Util.h:932</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa5e347aaf113d69fceb9d2eb6f8b052e"><div class="ttname"><a href="namespacesouffle.html#aa5e347aaf113d69fceb9d2eb6f8b052e">souffle::toBddbddb</a></div><div class="ttdeci">void toBddbddb(std::ostream &amp;out, const AstTranslationUnit &amp;translationUnit)</div><div class="ttdoc">Converts the given souffle-datalog translation unit into bdddbddb input code and writes the result in...</div><div class="ttdef"><b>Definition:</b> <a href="_bddbddb_backend_8cpp_source.html#l00222">BddbddbBackend.cpp:222</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9fbc2262a6164b62766f6fcb67f12ae4"><div class="ttname"><a href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a></div><div class="ttdeci">std::string baseName(const std::string &amp;filename)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01048">Util.h:1048</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2122cfa5acdee4846ecda0855f0beee4"><div class="ttname"><a href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">souffle::tempFile</a></div><div class="ttdeci">std::string tempFile()</div><div class="ttdoc">Generate temporary file. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01098">Util.h:1098</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae807f7b8118a77f250c57d1c3a08905e"><div class="ttname"><a href="namespacesouffle.html#ae807f7b8118a77f250c57d1c3a08905e">souffle::ScheduledExecution</a></div><div class="ttdeci">const QueryExecutionStrategy ScheduledExecution</div><div class="ttdoc">With this strategy queries will be dynamically rescheduled before each execution. ...</div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_8cpp_source.html#l01002">Interpreter.cpp:1002</a></div></div>
<div class="ttc" id="namespacesouffle_html_a56909036ae0514924e306d0a1a180837"><div class="ttname"><a href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">souffle::isNumber</a></div><div class="ttdeci">bool isNumber(const char *str)</div><div class="ttdoc">Check whether a string is a sequence of numbers. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00088">Util.h:88</a></div></div>
<div class="ttc" id="namespacesouffle_html_a97d640155c037c468924198354aae2ea"><div class="ttname"><a href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">souffle::compileToBinary</a></div><div class="ttdeci">void compileToBinary(std::string compileCmd, const std::string &amp;sourceFilename)</div><div class="ttdoc">Compiles the given source file to a binary file. </div><div class="ttdef"><b>Definition:</b> <a href="main_8cpp_source.html#l00098">main.cpp:98</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph.png" border="0" usemap="#namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph" alt=""/></div>
<map name="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph" id="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4" title="souffle::baseName" alt="" coords="186,5,318,32"/><area shape="rect" id="node3" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea" title="Compiles the given source file to a binary file. " alt="" coords="406,208,573,235"/><area shape="rect" id="node4" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="644,208,793,235"/><area shape="rect" id="node5" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c" title="Executes a binary file. " alt="" coords="176,157,328,184"/><area shape="rect" id="node6" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14" title="Check whether a given file exists and it is an executable. " alt="" coords="417,107,561,133"/><area shape="rect" id="node7" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e" title="Check whether a directory exists in the file system. " alt="" coords="195,967,309,993"/><area shape="rect" id="node8" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3" title="Check whether a file exists in the file system. " alt="" coords="193,1017,311,1044"/><area shape="rect" id="node9" href="namespacesouffle.html#a783c22acbaa814d35b915fa6d09696d8" title="souffle::explain" alt="" coords="197,1068,307,1095"/><area shape="rect" id="node21" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5" title="souffle::findTool" alt="" coords="195,1119,309,1145"/><area shape="rect" id="node22" href="classsouffle_1_1_debug_reporter.html#ae9fa7c82c5d862b563f4dac70a1aa71b" title="Generate a debug report section for the current state of the given translation unit with the given id..." alt="" coords="173,799,331,841"/><area shape="rect" id="node26" href="classsouffle_1_1_debug_reporter.html#a0203b9b72ed2087b1b7604cdc75ecdbb" title="Generate a debug report section for code (preserving formatting), with the given id and title..." alt="" coords="411,1095,568,1137"/><area shape="rect" id="node32" href="classsouffle_1_1_main_config.html#a61242eeabf22508207d11582f9c9f3d4" title="souffle::MainConfig\l::help" alt="" coords="422,469,557,510"/><area shape="rect" id="node33" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a" title="Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned..." alt="" coords="193,1169,311,1196"/><area shape="rect" id="node34" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837" title="Check whether a string is a sequence of numbers. " alt="" coords="189,1220,315,1247"/><area shape="rect" id="node35" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0" title="souffle::now" alt="" coords="205,1271,299,1297"/><area shape="rect" id="node36" href="classsouffle_1_1_parser_driver.html#afb895907e23707a2d6a3fcdc1a82e222" title="souffle::ParserDriver\l::parseTranslationUnit" alt="" coords="177,1322,327,1363"/><area shape="rect" id="node38" href="classsouffle_1_1_main_config.html#a6cbd917fde0cbb44a6a40e72b9dcd1d0" title="souffle::MainConfig\l::processArgs" alt="" coords="185,397,319,438"/><area shape="rect" id="node41" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59" title="File name, with extension removed. " alt="" coords="181,1388,323,1415"/><area shape="rect" id="node42" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4" title="Generate temporary file. " alt="" coords="193,1439,311,1465"/><area shape="rect" id="node43" href="namespacesouffle.html#aa5e347aaf113d69fceb9d2eb6f8b052e" title="Converts the given souffle&#45;datalog translation unit into bdddbddb input code and writes the result in..." alt="" coords="187,916,317,943"/><area shape="rect" id="node45" href="classsouffle_1_1_ast_translator.html#a63ff2994b6f6611fc994880e2408126e" title="translates AST to translation unit " alt="" coords="179,665,325,706"/><area shape="rect" id="node49" href="classsouffle_1_1_unsupported_construct_exception.html#ab8c06d7cad124f31846e39dda56fa7dd" title="souffle::UnsupportedConstruct\lException::what" alt="" coords="152,1490,352,1531"/><area shape="rect" id="node50" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1" title="Simple implementation of a which tool. " alt="" coords="201,1556,303,1583"/><area shape="rect" id="node10" href="classsouffle_1_1_explain.html#aabd40f949d36ae7cd2782f62088e7c11" title="souffle::Explain::explain" alt="" coords="409,1281,570,1308"/><area shape="rect" id="node11" href="classsouffle_1_1_explain.html#ae3c25129416040424fa123f70566c8ae" title="souffle::Explain::initialise\lWindow" alt="" coords="635,1334,802,1375"/><area shape="rect" id="node12" href="namespacesouffle.html#a7f32090909fb88cd5af742382c7ddd2c" title="utility function to split a string " alt="" coords="672,1400,765,1427"/><area shape="rect" id="node13" href="classsouffle_1_1_explain.html#a0959bd00e5dac64e88158ddab67d45a9" title="souffle::Explain::printStr" alt="" coords="637,1451,800,1477"/><area shape="rect" id="node14" href="classsouffle_1_1_explain.html#a2b162a9221551183972e5eaa781a218b" title="souffle::Explain::parseTuple" alt="" coords="627,1501,811,1528"/><area shape="rect" id="node15" href="classsouffle_1_1_explain_provenance.html#a340ed47f995b5172ab9f346babc4bfd7" title="souffle::ExplainProvenance\l::explain" alt="" coords="628,1553,809,1594"/><area shape="rect" id="node16" href="classsouffle_1_1_explain.html#a04c6d4e51a17c6850f37036df137ccd7" title="souffle::Explain::printTree" alt="" coords="633,1035,804,1061"/><area shape="rect" id="node17" href="classsouffle_1_1_explain_provenance.html#a64e3165acb1b13e24e5f1974d8c29cf2" title="souffle::ExplainProvenance\l::explainSubproof" alt="" coords="628,1086,809,1127"/><area shape="rect" id="node18" href="classsouffle_1_1_explain_provenance.html#aadcec6224703d8b59f7743ce97bf7f03" title="souffle::ExplainProvenance\l::getRule" alt="" coords="628,1151,809,1193"/><area shape="rect" id="node19" href="classsouffle_1_1_explain_provenance.html#ad23118b17b9a9bc388cb313f996a94d5" title="souffle::ExplainProvenance\l::getRelationOutput" alt="" coords="628,1217,809,1258"/><area shape="rect" id="node20" href="classsouffle_1_1_explain.html#a0b102860f7c8ce0062f38e64f25ff1e9" title="souffle::Explain::scrollTree" alt="" coords="630,1283,807,1309"/><area shape="rect" id="node23" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="630,969,807,1010"/><area shape="rect" id="node24" href="classsouffle_1_1_ast_program.html#a41b95b3179fc737c70c7b957220146c4" title="Output the program to a given output stream. " alt="" coords="420,847,559,889"/><area shape="rect" id="node27" href="classsouffle_1_1_ast_translation_unit.html#a7a1598acb91192e90026763b3b968653" title="get analysis: analysis is generated on the fly if not present " alt="" coords="630,694,807,735"/><area shape="rect" id="node28" href="classsouffle_1_1_debug_reporter.html#a2363e9e1493efdbfc10c0746caf58e93" title="Generated a debug report section for a dot graph specification, with the given id and title..." alt="" coords="411,913,568,954"/><area shape="rect" id="node30" href="classsouffle_1_1_ast_translation_unit.html#a2c05c0d93e34800167034b1aa423c4a0" title="get debug report " alt="" coords="401,730,578,771"/><area shape="rect" id="node31" href="classsouffle_1_1_debug_report.html#a4e6fe0a6d9854ce570d008772daa9aba" title="souffle::DebugReport\l::addSection" alt="" coords="416,1030,563,1071"/><area shape="rect" id="node25" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="674,855,763,881"/><area shape="rect" id="node29" href="namespacesouffle.html#a9b5d35fc5fbcf6970adb86505b9263da" title="souffle::toBase64" alt="" coords="657,917,781,944"/><area shape="rect" id="node37" href="classsouffle_1_1_parser_driver.html#a8d45edc1d26e58a4d1df478fee0f2e7a" title="souffle::ParserDriver\l::parse" alt="" coords="418,1333,561,1374"/><area shape="rect" id="node39" href="classsouffle_1_1_base_table.html#ae1361527a4c730b167ea12804c406068" title="souffle::BaseTable\l\&lt; std::string, std::\lstring \&gt;::set" alt="" coords="424,389,555,445"/><area shape="rect" id="node40" href="classsouffle_1_1_base_table.html#a4cbc1eef129cb2e83060e7565c9d3d3f" title="souffle::BaseTable\l\&lt; std::string, std::\lstring \&gt;::has" alt="" coords="424,309,555,365"/><area shape="rect" id="node44" href="classsouffle_1_1detail_1_1_bddbddb_converter.html#a7c237bccb990b8c0adbab0889b54ce40" title="souffle::detail::Bddbddb\lConverter::convert" alt="" coords="410,1213,569,1254"/><area shape="rect" id="node46" href="classsouffle_1_1_ast_translator.html#aacac29895833f17d14c2ccab5d0e801f" title="Translate AST to RamProgram. " alt="" coords="416,599,563,641"/><area shape="rect" id="node47" href="classsouffle_1_1_ast_translation_unit.html#ad3c8a4225f4974ff9c8bad88f6690d9e" title="get symbol table " alt="" coords="401,534,578,575"/><area shape="rect" id="node48" href="classsouffle_1_1_ast_translation_unit.html#aec4a1cc2e03286db878a5d2f0377f894" title="get error report " alt="" coords="401,665,578,706"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acea8a37cc1681f657054f3b30af55003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1range.html">range</a>&lt;Iter&gt; souffle::make_range </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the construction of ranges without explicitly specifying the iterator type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>.. the iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>.. the lower boundary </td></tr>
    <tr><td class="paramname">b</td><td>.. the upper boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00267">267</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_compiled_ram_relation_8h_source.html#l01135">souffle::ram::detail::HashRelationGroup&lt; arity, First, Rest...&gt;::equal_range()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00625">souffle::ram::index_utils::DirectIndex&lt; Tuple, Index &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00733">souffle::ram::index_utils::IndirectIndex&lt; Tuple, Index &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_relation_8h_source.html#l00777">souffle::ram::detail::AutoRelation&lt; 0 &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00965">souffle::ram::index_utils::TrieIndex&lt; Index &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l01167">souffle::ram::index_utils::DisjointSetIndex&lt; Index &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l01449">souffle::ram::index_utils::Indices&lt; T, IndexFactory &gt;::equalRange()</a>, <a class="el" href="_compiled_ram_relation_8h_source.html#l00918">souffle::ram::detail::SingleIndexRelation&lt; arity, Index, IndexFactory &gt;::equalRangeInternal()</a>, <a class="el" href="_binary_relation_8h_source.html#l00676">souffle::BinaryRelation&lt; tuple_type &gt;::getBoundaries()</a>, <a class="el" href="_trie_8h_source.html#l02334">souffle::Trie&lt; Dim-1 &gt;::getBoundaries()</a>, <a class="el" href="_trie_8h_source.html#l02696">souffle::Trie&lt; 0u &gt;::getBoundaries()</a>, <a class="el" href="_trie_8h_source.html#l02989">souffle::Trie&lt; 1u &gt;::getBoundaries()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00774">souffle::ram::index_utils::IndirectIndex&lt; Tuple, Index &gt;::partition()</a>, <a class="el" href="_binary_relation_8h_source.html#l00779">souffle::BinaryRelation&lt; tuple_type &gt;::partition()</a>, <a class="el" href="_compiled_ram_relation_8h_source.html#l00810">souffle::ram::detail::AutoRelation&lt; 0 &gt;::partition()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l00951">souffle::ram::index_utils::TrieIndex&lt; Index &gt;::partition()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l01143">souffle::ram::index_utils::DisjointSetIndex&lt; Index &gt;::partition()</a>, <a class="el" href="_trie_8h_source.html#l02379">souffle::Trie&lt; Dim-1 &gt;::partition()</a>, <a class="el" href="_trie_8h_source.html#l02684">souffle::Trie&lt; 0u &gt;::partition()</a>, <a class="el" href="_trie_8h_source.html#l02942">souffle::Trie&lt; 1u &gt;::partition()</a>, <a class="el" href="_compiled_ram_relation_8h_source.html#l00771">souffle::ram::detail::AutoRelation&lt; 0 &gt;::scan()</a>, <a class="el" href="_compiled_ram_relation_8h_source.html#l00903">souffle::ram::detail::SingleIndexRelation&lt; arity, Index, IndexFactory &gt;::scan()</a>, <a class="el" href="_compiled_ram_index_utils_8h_source.html#l01332">souffle::ram::index_utils::Indices&lt; T, IndexFactory, First, Rest...&gt;::scan()</a>, and <a class="el" href="_compiled_ram_index_utils_8h_source.html#l01443">souffle::ram::index_utils::Indices&lt; T, IndexFactory &gt;::scan()</a>.</p>
<div class="fragment"><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                                                     {</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">return</span> range&lt;Iter&gt;(a, b);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a38b6018ec9bf0a9a3110c99b926b3044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>&gt; souffle::makeInfoRelation </td>
          <td>(</td>
          <td class="paramtype">AstClause &amp;&#160;</td>
          <td class="paramname"><em>originalClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstTranslationUnit &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00041">41</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00090">souffle::AstAtom::getAtom()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00068">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00364">souffle::AstClause::getClauseNum()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00075">souffle::AstAtom::getName()</a>, <a class="el" href="_ast_translation_unit_8h_source.html#l00083">souffle::AstTranslationUnit::getSymbolTable()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00024">identifierToString()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00030">makeRelationName()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00196">name</a>, and <a class="el" href="_ast_clause_8cpp_source.html#l00097">souffle::AstClause::print()</a>.</p>

<p>Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00151">souffle::ProvenanceTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                                        {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    AstRelationIdentifier <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a> =</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            <a class="code" href="namespacesouffle.html#aa15c74ca7366692d06582c9431f4cff2">makeRelationName</a>(originalClause.getHead()-&gt;getName(), <span class="stringliteral">&quot;@info&quot;</span>, originalClause.getClauseNum());</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="comment">// initialise info relation</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keyword">auto</span> infoRelation = <span class="keyword">new</span> AstRelation();</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    infoRelation-&gt;setName(name);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="comment">// create new clause containing a single fact</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keyword">auto</span> infoClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keyword">auto</span> infoClauseHead = <span class="keyword">new</span> AstAtom();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    infoClauseHead-&gt;setName(name);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    infoRelation-&gt;addAttribute(std::make_unique&lt;AstAttribute&gt;(<span class="stringliteral">&quot;clause_num&quot;</span>, AstTypeIdentifier(<span class="stringliteral">&quot;number&quot;</span>)));</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    infoClauseHead-&gt;addArgument(std::make_unique&lt;AstNumberConstant&gt;(originalClause.getClauseNum()));</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// visit all body literals and add to info clause head</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; originalClause.getBodyLiterals().size(); i++) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[i];</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keyword">const</span> AstAtom* atom = lit-&gt;getAtom();</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            std::string relName = <a class="code" href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d">identifierToString</a>(atom-&gt;getName());</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            infoRelation-&gt;addAttribute(std::unique_ptr&lt;AstAttribute&gt;(</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                    <span class="keyword">new</span> AstAttribute(std::string(<span class="stringliteral">&quot;rel_&quot;</span>) + std::to_string(i), AstTypeIdentifier(<span class="stringliteral">&quot;symbol&quot;</span>))));</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(lit)) {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                infoClauseHead-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                        <span class="keyword">new</span> AstStringConstant(translationUnit.getSymbolTable(), relName.c_str())));</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstNegation*&gt;(lit)) {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                infoClauseHead-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                        <span class="keyword">new</span> AstStringConstant(translationUnit.getSymbolTable(), (<span class="stringliteral">&quot;!&quot;</span> + relName).c_str())));</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// generate and add clause representation</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    originalClause.print(ss);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    infoRelation-&gt;addAttribute(std::make_unique&lt;AstAttribute&gt;(<span class="stringliteral">&quot;clause_repr&quot;</span>, AstTypeIdentifier(<span class="stringliteral">&quot;symbol&quot;</span>)));</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    infoClauseHead-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keyword">new</span> AstStringConstant(translationUnit.getSymbolTable(), ss.str().c_str())));</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// set clause head and add clause to info relation</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    infoClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(infoClauseHead));</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    infoRelation-&gt;addClause(std::unique_ptr&lt;AstClause&gt;(infoClause));</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">return</span> std::unique_ptr&lt;AstRelation&gt;(infoRelation);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aa15c74ca7366692d06582c9431f4cff2"><div class="ttname"><a href="namespacesouffle.html#aa15c74ca7366692d06582c9431f4cff2">souffle::makeRelationName</a></div><div class="ttdeci">AstRelationIdentifier makeRelationName(const AstRelationIdentifier &amp;orig, const std::string &amp;type, int num=-1)</div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00030">ProvenanceTransformer.cpp:30</a></div></div>
<div class="ttc" id="namespacesouffle_html_a05eb410bc1f341864368bc73608bae7d"><div class="ttname"><a href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d">souffle::identifierToString</a></div><div class="ttdeci">const std::string identifierToString(const AstRelationIdentifier &amp;name)</div><div class="ttdoc">Helper functions. </div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00024">ProvenanceTransformer.cpp:24</a></div></div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a38b6018ec9bf0a9a3110c99b926b3044_cgraph.png" border="0" usemap="#namespacesouffle_a38b6018ec9bf0a9a3110c99b926b3044_cgraph" alt=""/></div>
<map name="namespacesouffle_a38b6018ec9bf0a9a3110c99b926b3044_cgraph" id="namespacesouffle_a38b6018ec9bf0a9a3110c99b926b3044_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="227,5,405,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#a9918f4fb19dd6f152d784512853b447a" title="Obtains a copy of the internally maintained body literals. " alt="" coords="484,399,615,441"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a46a432b3284cd500a57eb181c31a3ccd" title="Gets the clause number. " alt="" coords="251,107,381,149"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="251,173,381,214"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="225,239,407,265"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_translation_unit.html#ad3c8a4225f4974ff9c8bad88f6690d9e" title="get symbol table " alt="" coords="227,290,405,331"/><area shape="rect" id="node8" href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d" title="Helper functions. " alt="" coords="466,169,633,196"/><area shape="rect" id="node9" href="namespacesouffle.html#aa15c74ca7366692d06582c9431f4cff2" title="souffle::makeRelationName" alt="" coords="224,356,408,383"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#a57ee5a2d88e7f2177448706a57ae8ad8" title="Print this clause to a given stream. " alt="" coords="251,487,381,529"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_relation_identifier.html#a40b918b195df8c3eb223c068db7536fe" title="souffle::AstRelationIdentifier\l::append" alt="" coords="456,334,643,375"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_clause.html#af474f0a79851dc870309c1eac1db4005" title="Return the number of elements in the body of the Clause. " alt="" coords="484,647,615,689"/><area shape="rect" id="node13" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="505,465,594,492"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="483,517,615,558"/><area shape="rect" id="node15" href="classsouffle_1_1_ast_execution_plan.html#afd1441312caa998c880e6150bf464848" title="Output to a given output stream. " alt="" coords="463,582,636,623"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a92d9fd18d29b2a9219b5a6f6a127d215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1_lambda_node_mapper.html">detail::LambdaNodeMapper</a>&lt;Lambda&gt; souffle::makeLambdaMapper </td>
          <td>(</td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a node mapper based on a corresponding lambda expression. </p>

<p>Definition at line <a class="el" href="_ast_node_8h_source.html#l00144">144</a> of file <a class="el" href="_ast_node_8h_source.html">AstNode.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l00548">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                                                                      {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">return</span> detail::LambdaNodeMapper&lt;Lambda&gt;(lambda);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4358a62bfb6a4b5d92306499af4d0684"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1_lambda_ram_node_mapper.html">detail::LambdaRamNodeMapper</a>&lt;Lambda&gt; souffle::makeLambdaMapper </td>
          <td>(</td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a node mapper based on a corresponding lambda expression. </p>

<p>Definition at line <a class="el" href="_ram_node_8h_source.html#l00181">181</a> of file <a class="el" href="_ram_node_8h_source.html">RamNode.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                                                                         {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">return</span> detail::LambdaRamNodeMapper&lt;Lambda&gt;(lambda);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa15c74ca7366692d06582c9431f4cff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> souffle::makeRelationName </td>
          <td>(</td>
          <td class="paramtype">const AstRelationIdentifier &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00030">30</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00057">souffle::AstRelationIdentifier::append()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00024">identifierToString()</a>.</p>

<p>Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00041">makeInfoRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                                                {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    AstRelationIdentifier newName(<a class="code" href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d">identifierToString</a>(orig));</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    newName.append(type);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">if</span> (num != -1) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        newName.append((<span class="keyword">const</span> std::string&amp;)std::to_string(num));</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">return</span> newName;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a05eb410bc1f341864368bc73608bae7d"><div class="ttname"><a href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d">souffle::identifierToString</a></div><div class="ttdeci">const std::string identifierToString(const AstRelationIdentifier &amp;name)</div><div class="ttdoc">Helper functions. </div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00024">ProvenanceTransformer.cpp:24</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa15c74ca7366692d06582c9431f4cff2_cgraph.png" border="0" usemap="#namespacesouffle_aa15c74ca7366692d06582c9431f4cff2_cgraph" alt=""/></div>
<map name="namespacesouffle_aa15c74ca7366692d06582c9431f4cff2_cgraph" id="namespacesouffle_aa15c74ca7366692d06582c9431f4cff2_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#a40b918b195df8c3eb223c068db7536fe" title="souffle::AstRelationIdentifier\l::append" alt="" coords="237,5,424,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a05eb410bc1f341864368bc73608bae7d" title="Helper functions. " alt="" coords="247,71,414,97"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a10b4d0d4c0df3b810331af0a4ec93d23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::maxRetries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function to set the maximum number of retries for a transaction if Intel RTM is enabled (default 15);. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01231">1231</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_b_tree_8h_source.html#l01277">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true &gt;::insert()</a>.</p>
<div class="fragment"><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                        {</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span>* retries = std::getenv(<span class="stringliteral">&quot;SOUFFLE_MAX_RETRIES&quot;</span>);</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    <span class="keywordflow">return</span> retries ? std::stoi(retries) : 15;</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7603fe80c7e2681fa81a67870058f60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1member__fun.html">member_fun</a>&lt;C, R, Args...&gt; souffle::mfun </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(Args...)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps an object and matching member function pointer into a callable object. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00853">853</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                                                         {</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="keywordflow">return</span> member_fun&lt;C, R, Args...&gt;({obj, f});</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac2f038770077ca498a606a43458b26e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::movePtrVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; X &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; Y &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function that moves a vector of unique pointers from a source to a destination. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00163">163</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_ram_statement_8h_source.html#l00509">souffle::RamSequence::moveSubprograms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">while</span> (!source.empty()) {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keyword">auto</span> it = source.begin();</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        destination.push_back(std::move(std::make_unique&lt;Y&gt;(std::move(*it))));</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        source.erase(it);</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbb53246ca22f17f324a309dc63f2e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::nameInlinedUnderscores </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all underscores in all atoms of inlined relations. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00081">81</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_program_8cpp_source.html#l00247">souffle::AstProgram::apply()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01028">replaceUnderscores()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00954">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                                 {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keyword">const</span> std::set&lt;AstRelationIdentifier&gt; inlinedRelations;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a>;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        M(std::set&lt;AstRelationIdentifier&gt; inlinedRelations, <span class="keywordtype">bool</span> <a class="code" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a>)</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                : inlinedRelations(inlinedRelations), replaceUnderscores(replaceUnderscores) {}</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> underscoreCount = 0;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a>) {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="comment">// Check if we should start replacing underscores for this node&#39;s subnodes</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                <span class="keywordflow">if</span> (AstAtom* atom = dynamic_cast&lt;AstAtom*&gt;(node.get())) {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                    <span class="keywordflow">if</span> (inlinedRelations.find(atom-&gt;getName()) != inlinedRelations.end()) {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                        <span class="comment">// Atom associated with an inlined relation, so replace the underscores</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                        <span class="comment">// in all of its subnodes with named variables.</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                        M replace(inlinedRelations, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                        node-&gt;apply(replace);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstUnnamedVariable*&gt;(node.get())) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                <span class="comment">// Give a unique name to the underscored variable</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="comment">// TODO (azreika): need a more consistent way of handling internally generated variables in</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                <span class="comment">// general</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                std::stringstream newVarName;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                newVarName &lt;&lt; <span class="stringliteral">&quot;&lt;underscore_&quot;</span> &lt;&lt; underscoreCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVarName.str());</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    };</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="comment">// Store the names of all relations to be inlined</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    std::set&lt;AstRelationIdentifier&gt; inlinedRelations;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;isInline()) {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            inlinedRelations.insert(rel-&gt;getName());</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">// Apply the renaming procedure to the entire program</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    M update(inlinedRelations, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    program.apply(update);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
<div class="ttc" id="namespacesouffle_html_a877abda5aeabc4122f3bce8d74247919"><div class="ttname"><a href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">souffle::replaceUnderscores</a></div><div class="ttdeci">void replaceUnderscores(AstProgram *program)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l01028">MagicSet.cpp:1028</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph.png" border="0" usemap="#namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph" alt=""/></div>
<map name="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph" id="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a0a658e411394dfc93da0ab36e06d0101" title="Mutates this node. " alt="" coords="291,5,429,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="501,63,640,105"/><area shape="rect" id="node4" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919" title="souffle::replaceUnderscores" alt="" coords="267,121,453,148"/><area shape="rect" id="node5" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="509,129,633,156"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2d520cf7b6c6ac6cf448e4be191efa06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> souffle::negatedConstraintOp </td>
          <td>(</td>
          <td class="paramtype">BinaryConstraintOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negated <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operator Each opeprator requires a negated operator which is necessary for the expansion of complex rule bodies with disjunction and negation. </p>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00049">49</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>.</p>

<p>Referenced by <a class="el" href="_ast_literal_8h_source.html#l00277">souffle::AstConstraint::negate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                                                                     {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NE;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::EQ;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::GE;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::GT;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::LT;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::LE;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NOT_MATCH;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::MATCH;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NOT_CONTAINS;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::CONTAINS;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> op;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72ca390c0235d50be215fdc25bb24e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>* souffle::negateLiteral </td>
          <td>(</td>
          <td class="paramtype">AstLiteral *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the negated version of a given literal. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00301">301</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00137">souffle::AstAtom::clone()</a>, <a class="el" href="_ast_literal_8h_source.html#l00299">souffle::AstConstraint::clone()</a>, <a class="el" href="_ast_literal_8h_source.html#l00090">souffle::AstAtom::getAtom()</a>, and <a class="el" href="_ast_literal_8h_source.html#l00277">souffle::AstConstraint::negate()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00321">combineNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                           {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">if</span> (AstAtom* atom = dynamic_cast&lt;AstAtom*&gt;(lit)) {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        AstNegation* neg = <span class="keyword">new</span> AstNegation(std::unique_ptr&lt;AstAtom&gt;(atom-&gt;clone()));</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keywordflow">return</span> neg;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AstNegation* neg = dynamic_cast&lt;AstNegation*&gt;(lit)) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        AstAtom* atom = neg-&gt;getAtom()-&gt;clone();</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keywordflow">return</span> atom;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AstConstraint* cons = dynamic_cast&lt;AstConstraint*&gt;(lit)) {</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        AstConstraint* newCons = cons-&gt;clone();</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        newCons-&gt;negate();</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keywordflow">return</span> newCons;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported literal type!&quot;</span>);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    }</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph.png" border="0" usemap="#namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph" alt=""/></div>
<map name="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph" id="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="207,56,366,83"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_constraint.html#a2d93e92e0a7f93439cde443086abc274" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="212,107,361,149"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#a6dd961f511124f842623aaeef7bc59da" title="Returns this class as the referenced atom. " alt="" coords="198,173,375,200"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_constraint.html#a8b0006e40991c9c9510173662207c55d" title="Negates the constraint. " alt="" coords="212,225,361,266"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a8b2cb04121834e1a3d0f460b579198f9" title="souffle::AstAtom::AstAtom" alt="" coords="431,5,609,32"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="427,56,613,83"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_constraint.html#a2e499963c8068e55317ef8e1ff51ff18" title="souffle::AstConstraint\l::AstConstraint" alt="" coords="445,107,595,149"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="427,173,613,200"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_constraint.html#a3e334d602bab20a5ff52bc325598bb27" title="Update the binary operator. " alt="" coords="445,225,595,266"/><area shape="rect" id="node11" href="namespacesouffle.html#a2d520cf7b6c6ac6cf448e4be191efa06" title="Negated Constraint Operator Each opeprator requires a negated operator which is necessary for the exp..." alt="" coords="424,291,616,317"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a816a525106d63dbdd220ee8ecc238f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a> souffle::nextSrcLoc </td>
          <td>(</td>
          <td class="paramtype">AstSrcLocation&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00184">184</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_src_location_8h_source.html#l00033">souffle::AstSrcLocation::Point::column</a>, <a class="el" href="_ast_src_location_8h_source.html#l00062">souffle::AstSrcLocation::end</a>, <a class="el" href="_ast_src_location_8h_source.html#l00056">souffle::AstSrcLocation::filename</a>, <a class="el" href="_ast_src_location_8h_source.html#l00030">souffle::AstSrcLocation::Point::line</a>, and <a class="el" href="_ast_src_location_8h_source.html#l00059">souffle::AstSrcLocation::start</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00226">createNewRelation()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00914">separateDBs()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                               {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> pos = 0;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    pos += 1;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    AstSrcLocation newLoc;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    newLoc.filename = orig.filename + <span class="stringliteral">&quot; [MAGIC_FILE]&quot;</span>;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    newLoc.start.line = pos;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    newLoc.end.line = pos;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    newLoc.start.column = 0;</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    newLoc.end.column = 1;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">return</span> newLoc;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af4ec690ba482fd3a9692b5e31f6ad347"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::none_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether all elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if for all elements x in c the predicate p(x) is true, false otherwise; for empty containers the result is always true </dd></dl>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00899">899</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                                                   {</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">std::none_of</a>(c.begin(), c.end(), <a class="code" href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a>);</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a3d1584b0c6ef4ae58954e92d7f321116"><div class="ttname"><a href="_synthesiser_8cpp.html#a3d1584b0c6ef4ae58954e92d7f321116">p</a></div><div class="ttdeci">Printer &amp; p</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00267">Synthesiser.cpp:267</a></div></div>
<div class="ttc" id="namespacesouffle_html_af4ec690ba482fd3a9692b5e31f6ad347"><div class="ttname"><a href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">souffle::none_of</a></div><div class="ttdeci">bool none_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00899">Util.h:899</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc8556c87eabd8a087d1e0fb9f8b89b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::normaliseInlinedHeads </td>
          <td>(</td>
          <td class="paramtype">AstProgram &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace constants in the head of inlined clauses with (constrained) variables. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00031">31</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_ast_program_8cpp_source.html#l00101">souffle::AstProgram::removeClause()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00954">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> newVarCount = 0;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="comment">// Go through the clauses of all inlined relations</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordflow">if</span> (!rel-&gt;isInline()) {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : rel-&gt;getClauses()) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="comment">// Set up the new clause with an empty body and no arguments in the head</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            <span class="keyword">auto</span> newClause = std::make_unique&lt;AstClause&gt;();</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            newClause-&gt;setSrcLoc(clause-&gt;getSrcLoc());</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            <span class="keyword">auto</span> clauseHead = std::make_unique&lt;AstAtom&gt;(clause-&gt;getHead()-&gt;getName());</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            <span class="comment">// Add in everything in the original body</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : clause-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                newClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="comment">// Set up the head arguments in the new clause</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">for</span> (AstArgument* arg : clause-&gt;getHead()-&gt;getArguments()) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                <span class="keywordflow">if</span> (AstConstant* constant = dynamic_cast&lt;AstConstant*&gt;(arg)) {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                    <span class="comment">// Found a constant in the head, so replace it with a variable</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                    std::stringstream newVar;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                    newVar &lt;&lt; <span class="stringliteral">&quot;&lt;new_var_&quot;</span> &lt;&lt; newVarCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                    clauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(newVar.str()));</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                    <span class="comment">// Add a body constraint to set the variable&#39;s value to be the original constant</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                    newClause-&gt;addToBody(std::make_unique&lt;AstConstraint&gt;(BinaryConstraintOp::EQ,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                            std::make_unique&lt;AstVariable&gt;(newVar.str()),</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(constant-&gt;clone())));</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                    <span class="comment">// Already a variable</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                    clauseHead-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            newClause-&gt;setHead(std::move(clauseHead));</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            <span class="comment">// Replace the old clause with this one</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            rel-&gt;addClause(std::move(newClause));</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            program.removeClause(clause);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph.png" border="0" usemap="#namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph" alt=""/></div>
<map name="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph" id="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="216,5,355,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#ac0733345760aab5b6939cd20b228c223" title="Removes a clause from this program. " alt="" coords="216,70,355,111"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="428,41,559,82"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#adfaa949dc3e89fa2dc25981963ea5752" title="Return the name of this atom. " alt="" coords="403,107,584,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1c65551944c7ecf6f44ec851b49bdbb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a5ede47ca253693a0980e580612116d6a">time_point</a> souffle::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00911">911</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_logger_8h_source.html#l00058">souffle::Logger::Logger()</a>, <a class="el" href="main_8cpp_source.html#l00119">main()</a>, <a class="el" href="_debug_report_8cpp_source.html#l00195">souffle::DebugReporter::transform()</a>, and <a class="el" href="_logger_8h_source.html#l00062">souffle::Logger::~Logger()</a>.</p>
<div class="fragment"><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                        {</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a1c65551944c7ecf6f44ec851b49bdbb0"><div class="ttname"><a href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a></div><div class="ttdeci">time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00911">Util.h:911</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa064251e4aba0690c02ca0150af4a177"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation_identifier.html">AstRelationIdentifier</a> souffle::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelationIdentifier &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A overloaded operator to add a new prefix to a given relation identifier. </p>

<p>Definition at line <a class="el" href="_ast_relation_identifier_8h_source.html#l00099">99</a> of file <a class="el" href="_ast_relation_identifier_8h_source.html">AstRelationIdentifier.h</a>.</p>

<p>References <a class="el" href="_ast_relation_identifier_8h_source.html#l00061">souffle::AstRelationIdentifier::prepend()</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                                                                                               {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    AstRelationIdentifier res = id;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    res.prepend(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa064251e4aba0690c02ca0150af4a177_cgraph.png" border="0" usemap="#namespacesouffle_aa064251e4aba0690c02ca0150af4a177_cgraph" alt=""/></div>
<map name="namespacesouffle_aa064251e4aba0690c02ca0150af4a177_cgraph" id="namespacesouffle_aa064251e4aba0690c02ca0150af4a177_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation_identifier.html#a86dad2e947329795719dd31016d87c08" title="souffle::AstRelationIdentifier\l::prepend" alt="" coords="179,5,365,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3c3861fdaa4641b5bb820a8b4d3b447b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_type_identifier.html">AstTypeIdentifier</a> souffle::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstTypeIdentifier &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A overloaded operator to add a new prefix to a given relation identifier. </p>

<p>Definition at line <a class="el" href="_ast_type_8h_source.html#l00106">106</a> of file <a class="el" href="_ast_type_8h_source.html">AstType.h</a>.</p>

<p>References <a class="el" href="_ast_type_8h_source.html#l00064">souffle::AstTypeIdentifier::prepend()</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    AstTypeIdentifier res = id;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    res.prepend(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3c3861fdaa4641b5bb820a8b4d3b447b_cgraph.png" border="0" usemap="#namespacesouffle_a3c3861fdaa4641b5bb820a8b4d3b447b_cgraph" alt=""/></div>
<map name="namespacesouffle_a3c3861fdaa4641b5bb820a8b4d3b447b_cgraph" id="namespacesouffle_a3c3861fdaa4641b5bb820a8b4d3b447b_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_type_identifier.html#a6050a7e727df9e3d67a246e8e09c32b1" title="souffle::AstTypeIdentifier\l::prepend" alt="" coords="179,5,347,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad8cf2396e4d4fb479990191006785299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RuleBody &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_parser_utils_8cpp_source.html#l00135">135</a> of file <a class="el" href="_ast_parser_utils_8cpp_source.html">AstParserUtils.cpp</a>.</p>

<p>References <a class="el" href="_ast_parser_utils_8h_source.html#l00034">souffle::RuleBody::literal::atom</a>, <a class="el" href="_ast_parser_utils_8h_source.html#l00042">souffle::RuleBody::dnf</a>, <a class="el" href="_util_8h_source.html#l00581">join()</a>, and <a class="el" href="_ast_parser_utils_8h_source.html#l00031">souffle::RuleBody::literal::negated</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                                                              {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">return</span> out &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(body.dnf, <span class="stringliteral">&quot;;&quot;</span>, [](std::ostream&amp; out, <span class="keyword">const</span> RuleBody::clause&amp; cur) {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        out &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(cur, <span class="stringliteral">&quot;,&quot;</span>, [](std::ostream&amp; out, <span class="keyword">const</span> RuleBody::literal&amp; l) {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="keywordflow">if</span> (l.negated) {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                out &lt;&lt; <span class="stringliteral">&quot;!&quot;</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            out &lt;&lt; *l.atom;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        });</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    });</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00581">Util.h:581</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph.png" border="0" usemap="#namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph" alt=""/></div>
<map name="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph" id="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="187,5,277,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3194e440e935d0d6089f8fa6bf405086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> souffle::pack </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function packing a tuple of the given arity into a reference. </p>

<p>Definition at line <a class="el" href="_compiled_ram_record_8h_source.html#l00164">164</a> of file <a class="el" href="_compiled_ram_record_8h_source.html">CompiledRamRecord.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00247">getConstTerms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                   {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordflow">return</span> detail::getRecordMap&lt;Tuple&gt;().<a class="code" href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">pack</a>(tuple);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a3194e440e935d0d6089f8fa6bf405086"><div class="ttname"><a href="namespacesouffle.html#a3194e440e935d0d6089f8fa6bf405086">souffle::pack</a></div><div class="ttdeci">RamDomain pack(const Tuple &amp;tuple)</div><div class="ttdoc">A function packing a tuple of the given arity into a reference. </div><div class="ttdef"><b>Definition:</b> <a href="_compiled_ram_record_8h_source.html#l00164">CompiledRamRecord.h:164</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad5da1088ffaa55d44c032cedaac4d9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> souffle::pack </td>
          <td>(</td>
          <td class="paramtype">RamDomain *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function packing a tuple of the given arity into a reference. </p>

<p>Definition at line <a class="el" href="_interpreter_records_8cpp_source.html#l00110">110</a> of file <a class="el" href="_interpreter_records_8cpp_source.html">InterpreterRecords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                            {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="comment">// conduct the packing</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">return</span> getForArity(<a class="code" href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a>).pack(tuple);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div>
<div class="ttc" id="_interpreter_records_8cpp_html_a2e1dc7313b72e22a19179823661deb69"><div class="ttname"><a href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a></div><div class="ttdeci">int arity</div><div class="ttdoc">The arity of the stored tuples. </div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_records_8cpp_source.html#l00036">InterpreterRecords.cpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a168e2fae5a34ddc5215c94d27893a7ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::pathJoin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join two paths together; note that this does not resolve overlaps or relative paths. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01018">1018</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;                                                                           {</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    <span class="keywordtype">unsigned</span> firstPos = first.size() - 1;</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    <span class="keywordflow">while</span> (first.at(firstPos) == <span class="charliteral">&#39;/&#39;</span>) firstPos--;</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keywordtype">unsigned</span> secondPos = 0;</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    <span class="keywordflow">while</span> (second.at(secondPos) == <span class="charliteral">&#39;/&#39;</span>) secondPos++;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    <span class="keywordflow">return</span> first.substr(0, firstPos + 1) + <span class="charliteral">&#39;/&#39;</span> + second.substr(secondPos);</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9976cdaf1f15164ab4f40e8337e23fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::printSizeStore </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; RamStatement &gt; &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstRelation *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeEnvironment &amp;&#160;</td>
          <td class="paramname"><em>typeEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>storeOutputOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_translator_8cpp_source.html#l01171">1171</a> of file <a class="el" href="_ast_translator_8cpp_source.html">AstTranslator.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00346">souffle::AstRelation::addIODirectives()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00821">appendStmt()</a>, <a class="el" href="_global_8h_source.html#l00130">souffle::Global::config()</a>, <a class="el" href="_ast_relation_8h_source.html#l00119">souffle::AstRelation::getArity()</a>, <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::getName()</a>, <a class="el" href="_ast_relation_8h_source.html#l00144">souffle::AstRelation::isOutput()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00179">souffle::AstRelation::isPrintSize()</a>.</p>

<p>Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l01240">souffle::AstTranslator::translateProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;                                                                    {</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> dir = Global::config().get(<span class="stringliteral">&quot;output-dir&quot;</span>);</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> ext = (!rel-&gt;isOutput()) ? <span class="stringliteral">&quot;.facts&quot;</span> : <span class="stringliteral">&quot;.csv&quot;</span>;</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;    AstRelation* mrel = <span class="keyword">const_cast&lt;</span>AstRelation*<span class="keyword">&gt;</span>(rel)-&gt;clone();</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <span class="keywordflow">if</span> (!rel-&gt;isOutput() &amp;&amp; !storeOutputOnly) {</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;        std::unique_ptr&lt;AstIODirective&gt; directive = std::make_unique&lt;AstIODirective&gt;();</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;        directive-&gt;setAsOutput();</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;        mrel-&gt;addIODirectives(std::move(directive));</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    }</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    std::unique_ptr&lt;RamRelation&gt; rrel = getRamRelation(</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;            mrel, &amp;typeEnv, getRelationName(mrel-&gt;getName()), mrel-&gt;getArity(), <span class="keyword">false</span>, dir, ext);</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="keywordflow">if</span> (rel-&gt;isPrintSize()) {</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;        <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamPrintSize&gt;(std::unique_ptr&lt;RamRelation&gt;(rrel-&gt;clone())));</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    }</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    <span class="keywordflow">if</span> (rel-&gt;isOutput() || !storeOutputOnly) {</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;        <a class="code" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">appendStmt</a>(current, std::make_unique&lt;RamStore&gt;(std::unique_ptr&lt;RamRelation&gt;(rrel-&gt;clone()),</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;                                    getOutputIODirectives(mrel, &amp;typeEnv, dir, ext)));</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    }</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;    <span class="keyword">delete</span> mrel;</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a532e17c4416fc5873367482f2e0623d9"><div class="ttname"><a href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9">souffle::appendStmt</a></div><div class="ttdeci">static void appendStmt(std::unique_ptr&lt; RamStatement &gt; &amp;stmtList, std::unique_ptr&lt; RamStatement &gt; stmt)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00821">AstTranslator.cpp:821</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a9976cdaf1f15164ab4f40e8337e23fa2_cgraph.png" border="0" usemap="#namespacesouffle_a9976cdaf1f15164ab4f40e8337e23fa2_cgraph" alt=""/></div>
<map name="namespacesouffle_a9976cdaf1f15164ab4f40e8337e23fa2_cgraph" id="namespacesouffle_a9976cdaf1f15164ab4f40e8337e23fa2_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#a6ab4f4409da3c84af64b4a08d26ccd21" title="souffle::AstRelation\l::addIODirectives" alt="" coords="211,5,349,46"/><area shape="rect" id="node3" href="namespacesouffle.html#a532e17c4416fc5873367482f2e0623d9" title="souffle::appendStmt" alt="" coords="211,71,349,97"/><area shape="rect" id="node5" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="205,121,355,148"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#a855b01ad5e4a0871ef6c6f6bb1e95d13" title="Return the arity of this relation. " alt="" coords="211,173,349,214"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#a6ae505289ecfc8e40c9f4e47689f5ee8" title="Return the name of the relation. " alt="" coords="211,238,349,279"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_relation.html#ae8a38221aa94f0df83f602fd1d1d0eb8" title="Check whether relation is an output relation. " alt="" coords="211,303,349,345"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_relation.html#a5de0a60f392fd55905d648894f62f4ab" title="Check whether relation is an input relation. " alt="" coords="211,369,349,410"/><area shape="rect" id="node4" href="classsouffle_1_1_ram_sequence.html#a0b409325b6311a7e7a19b1d84dae990f" title="Add new statement to the end of ordered list. " alt="" coords="403,71,587,97"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a08f3e2bc00f4340336a0f9a9dc4e9955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::reduceSubstitution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; AstArgument *, AstArgument * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces a vector of substitutions. </p>
<p>Returns false only if matched argument pairs are found to be incompatible. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00150">150</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_transforms_8cpp_source.html#l00169">lhs</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00170">rhs</a>, and <a class="el" href="_constraints_8h_source.html#l00223">sub()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00212">unifyAtoms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                                                                             {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">// Type-Checking functions</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keyword">auto</span> isConstant = [&amp;](AstArgument* arg) { <span class="keywordflow">return</span> (dynamic_cast&lt;AstConstant*&gt;(arg)); };</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keyword">auto</span> isRecord = [&amp;](AstArgument* arg) { <span class="keywordflow">return</span> (dynamic_cast&lt;AstRecordInit*&gt;(arg)); };</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="comment">// Keep trying to reduce the substitutions until we reach a fixed point.</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="comment">// Note that at this point no underscores (&#39;_&#39;) or counters (&#39;$&#39;) should appear.</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">while</span> (!done) {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        done = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="comment">// Try reducing each pair by one step</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.size(); i++) {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keyword">auto</span> currPair = <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>[i];</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            AstArgument* <a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = currPair.first;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            AstArgument* <a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = currPair.second;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="comment">// Start trying to reduce the substitution</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="comment">// Note: Can probably go further with this substitution reduction</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keywordflow">if</span> (*lhs == *rhs) {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                <span class="comment">// Get rid of redundant `x = x`</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.erase(<a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.begin() + i);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                done = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isConstant(lhs) &amp;&amp; isConstant(rhs)) {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                <span class="comment">// Both are constants but not equal (prev case =&gt; !=)</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <span class="comment">// Failed to unify!</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRecord(lhs) &amp;&amp; isRecord(rhs)) {</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                <span class="comment">// Note: we will not deal with the case where only one side is</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <span class="comment">// a record and the other is a variable, as variables can be records</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                <span class="comment">// on a deeper level.</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                std::vector&lt;AstArgument*&gt; lhsArgs = <span class="keyword">static_cast&lt;</span>AstRecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>)-&gt;getArguments();</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                std::vector&lt;AstArgument*&gt; rhsArgs = <span class="keyword">static_cast&lt;</span>AstRecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>)-&gt;getArguments();</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                <span class="keywordflow">if</span> (lhsArgs.size() != rhsArgs.size()) {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                    <span class="comment">// Records of unequal size can&#39;t be equated</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                <span class="comment">// Equate all corresponding arguments</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; lhsArgs.size(); i++) {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                    <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.push_back(std::make_pair(lhsArgs[i], rhsArgs[i]));</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                }</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                <span class="comment">// Get rid of the record equality</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.erase(<a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.begin() + i);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                done = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((isRecord(lhs) &amp;&amp; isConstant(rhs)) || (isConstant(lhs) &amp;&amp; isRecord(rhs))) {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                <span class="comment">// A record =/= a constant</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    }</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00223">Constraints.h:223</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_ast_transforms_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdoc">The two terms to be equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00169">AstTransforms.cpp:169</a></div></div>
<div class="ttc" id="_ast_transforms_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_ast_transforms_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_ast_transforms_8cpp_source.html#l00170">AstTransforms.cpp:170</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a08f3e2bc00f4340336a0f9a9dc4e9955_cgraph.png" border="0" usemap="#namespacesouffle_a08f3e2bc00f4340336a0f9a9dc4e9955_cgraph" alt=""/></div>
<map name="namespacesouffle_a08f3e2bc00f4340336a0f9a9dc4e9955_cgraph" id="namespacesouffle_a08f3e2bc00f4340336a0f9a9dc4e9955_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="232,5,323,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af790a6a39a388c256d64af7140f3a961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::renameVariables </td>
          <td>(</td>
          <td class="paramtype">AstArgument *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames all variables in a given argument uniquely. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00426">426</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa">souffle::AstNode::apply()</a>, and <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00452">combineAggregators()</a>.</p>
<div class="fragment"><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                                       {</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> varCount = 0;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    varCount++;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordtype">int</span> varnum;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        M(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keywordflow">if</span> (AstVariable* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="keyword">auto</span> newVar = std::unique_ptr&lt;AstVariable&gt;(var-&gt;clone());</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                std::stringstream newName;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                newName &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;-v&quot;</span> &lt;&lt; varnum;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                newVar-&gt;setName(newName.str());</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <span class="keywordflow">return</span> std::move(newVar);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            }</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        }</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    };</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    M update(varCount);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    arg-&gt;apply(update);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;}</div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph.png" border="0" usemap="#namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph" alt=""/></div>
<map name="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph" id="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#ae24d4eb85688112f38f7901bebeb4bfa" title="Apply the mapper to all child nodes. " alt="" coords="222,5,381,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6903b947a2473735a22a16f70664b91b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; souffle::reorderAdornment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>adornment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00447">447</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                                                                       {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="comment">// order[i] denotes where labels[i] should move</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// [a, b, c] with order [1, 2, 0] -&gt; [c, a, b]</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    std::vector&lt;std::string&gt; result(adornment.size());</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; adornment.size(); i++) {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        result[order[i]] = adornment[i];</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6e8e6aa7bd85198221efb412ec7b898c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; souffle::reorderOrdering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00426">426</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                                                                       {</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// when the adornment is computed, the atoms are numbered based on</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// which was chosen by the SIPS first - this is the &#39;order&#39; vector.</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="comment">// want to reorder clause atoms so that the atom labelled 0 is first, and so on.</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="comment">// i.e. order[i] denotes where labels[i] should move</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="comment">// e.g.: [a, b, c] with label [1, 2, 0] should become [c, a, b]</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="comment">// the atom reordering function for clauses, however, moves it as follows:</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">// [a, b, c] with label [1, 2, 0] becomes [b, c, a]</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="comment">// i.e. labels[i] goes to the position of i in the order vector</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="comment">// this function reorders the ordering scheme to match the second type</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    std::vector&lt;unsigned int&gt; neworder(order.size());</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; order.size(); i++) {</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="comment">// this took embarrassingly long to figure out</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        neworder[order[i]] = i;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keywordflow">return</span> neworder;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a877abda5aeabc4122f3bce8d74247919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::replaceUnderscores </td>
          <td>(</td>
          <td class="paramtype">AstProgram *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l01028">1028</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00064">hasPrefix()</a>, and <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00081">nameInlinedUnderscores()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;                                             {</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;            <span class="keywordflow">if</span> (AstVariable* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">hasPrefix</a>(var-&gt;getName(), <span class="stringliteral">&quot;+underscore&quot;</span>)) {</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                    <span class="keywordflow">return</span> std::make_unique&lt;AstUnnamedVariable&gt;();</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                }</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;            }</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;        }</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;    };</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    M update;</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : rel-&gt;getClauses()) {</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            clause-&gt;apply(update);</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        }</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    }</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aacfe9bc62b1157c810a572b6c1b310aa"><div class="ttname"><a href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(std::string str, std::string prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00064">MagicSet.cpp:64</a></div></div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph.png" border="0" usemap="#namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph" alt=""/></div>
<map name="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph" id="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="240,5,379,46"/><area shape="rect" id="node3" href="namespacesouffle.html#aacfe9bc62b1157c810a572b6c1b310aa" title="souffle::hasPrefix" alt="" coords="247,71,371,97"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f9046441f0187dc187df0765a55b175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::separateDBs </td>
          <td>(</td>
          <td class="paramtype">AstProgram *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00914">914</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00095">souffle::AstAtom::addArgument()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00038">souffle::AstClause::addToBody()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00092">souffle::AstProgram::appendClause()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00077">souffle::AstProgram::appendRelation()</a>, <a class="el" href="_ast_clause_8h_source.html#l00377">souffle::AstClause::clone()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00226">createNewRelation()</a>, <a class="el" href="_ast_clause_8h_source.html#l00287">souffle::AstClause::getHead()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00199">getNextEdbName()</a>, <a class="el" href="_ast_program_8cpp_source.html#l00141">souffle::AstProgram::getRelations()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00184">nextSrcLoc()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00051">souffle::AstClause::setHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00085">souffle::AstAtom::setName()</a>, and <a class="el" href="_ast_node_8h_source.html#l00052">souffle::AstNode::setSrcLoc()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                                      {</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">for</span> (AstRelation* relation : program-&gt;getRelations()) {</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        AstRelationIdentifier relName = relation-&gt;getName();</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="comment">// determine whether the relation fits into the EDB, IDB, or both</span></div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        <span class="keywordtype">bool</span> is_edb = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;        <span class="keywordtype">bool</span> is_idb = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : relation-&gt;getClauses()) {</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            <span class="keywordflow">if</span> (clause-&gt;isFact()) {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                is_edb = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                is_idb = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;            <span class="keywordflow">if</span> (is_edb &amp;&amp; is_idb) {</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            }</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;        }</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;        <span class="keywordflow">if</span> (is_edb &amp;&amp; is_idb) {</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            <span class="comment">// relation is part of EDB and IDB</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="comment">// move all the relation&#39;s facts to a new relation with a unique name</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            std::string newEdbName = <a class="code" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">getNextEdbName</a>(program);</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            AstRelation* newEdbRel = <a class="code" href="namespacesouffle.html#a395ec79864680ea50d418a241b05b4a0">createNewRelation</a>(relation, newEdbName);</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            program-&gt;appendRelation(std::unique_ptr&lt;AstRelation&gt;(newEdbRel));</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            <span class="comment">// find all facts for the relation</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            <span class="keywordflow">for</span> (AstClause* clause : relation-&gt;getClauses()) {</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;                <span class="keywordflow">if</span> (clause-&gt;isFact()) {</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                    <span class="comment">// clause is fact - add it to the new EDB relation</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                    AstClause* newEdbClause = clause-&gt;clone();</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                    newEdbClause-&gt;getHead()-&gt;setName(newEdbName);</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                    program-&gt;appendClause(std::unique_ptr&lt;AstClause&gt;(newEdbClause));</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                }</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            }</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            <span class="comment">// add a rule to the old relation that relates it to the new relation</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            AstClause* newIdbClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            newIdbClause-&gt;setSrcLoc(<a class="code" href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50">nextSrcLoc</a>(relation-&gt;getSrcLoc()));</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            <span class="comment">// oldname(arg1...argn) :- newname(arg1...argn)</span></div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            AstAtom* headAtom = <span class="keyword">new</span> AstAtom(relName);</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            AstAtom* bodyAtom = <span class="keyword">new</span> AstAtom(newEdbName);</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <span class="keywordtype">size_t</span> numargs = relation-&gt;getArity();</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numargs; j++) {</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                std::stringstream argName;</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                argName.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                argName &lt;&lt; <span class="stringliteral">&quot;arg&quot;</span> &lt;&lt; j;</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                headAtom-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(argName.str()));</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                bodyAtom-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(argName.str()));</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;            }</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;            newIdbClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(headAtom));</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;            newIdbClause-&gt;addToBody(std::unique_ptr&lt;AstAtom&gt;(bodyAtom));</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;            program-&gt;appendClause(std::unique_ptr&lt;AstClause&gt;(newIdbClause));</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;        }</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    }</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aeb526d569fc848583a59613102f660d3"><div class="ttname"><a href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">souffle::getNextEdbName</a></div><div class="ttdeci">std::string getNextEdbName(AstProgram *program)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00199">MagicSet.cpp:199</a></div></div>
<div class="ttc" id="namespacesouffle_html_a816a525106d63dbdd220ee8ecc238f50"><div class="ttname"><a href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50">souffle::nextSrcLoc</a></div><div class="ttdeci">AstSrcLocation nextSrcLoc(AstSrcLocation orig)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00184">MagicSet.cpp:184</a></div></div>
<div class="ttc" id="namespacesouffle_html_a395ec79864680ea50d418a241b05b4a0"><div class="ttname"><a href="namespacesouffle.html#a395ec79864680ea50d418a241b05b4a0">souffle::createNewRelation</a></div><div class="ttdeci">AstRelation * createNewRelation(AstRelation *original, AstRelationIdentifier newName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00226">MagicSet.cpp:226</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph.png" border="0" usemap="#namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph" alt=""/></div>
<map name="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph" id="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a0c2e151bc853490e6210c33c8fd127be" title="Add argument to the atom. " alt="" coords="200,5,405,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aa9da90d931189d440bbe7b256e554f8d" title="Add a Literal to the body of the clause. " alt="" coords="237,57,368,98"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#a29a37490ca76595a9a8403d3acac8db8" title="append a new clause to this program  after parsing " alt="" coords="233,122,372,163"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#aa49e46a4c01a178b28dde2079f1881b8" title="appends a new relation to this program  after parsing " alt="" coords="233,187,372,229"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Creates a clone if this AST sub&#45;structure. " alt="" coords="237,253,368,294"/><area shape="rect" id="node10" href="namespacesouffle.html#a395ec79864680ea50d418a241b05b4a0" title="souffle::createNewRelation" alt="" coords="213,319,393,345"/><area shape="rect" id="node14" href="namespacesouffle.html#a816a525106d63dbdd220ee8ecc238f50" title="souffle::nextSrcLoc" alt="" coords="479,443,614,469"/><area shape="rect" id="node16" href="classsouffle_1_1_ast_node.html#a87a7a3fa2ee37482923d81e072b29bee" title="Set source location for the AstNode. " alt="" coords="453,493,640,520"/><area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="237,471,368,513"/><area shape="rect" id="node22" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3" title="souffle::getNextEdbName" alt="" coords="216,537,389,564"/><area shape="rect" id="node24" href="classsouffle_1_1_ast_program.html#a60fcb7d3a21a06be7b48f5849917a22b" title="Get all relations in the program. " alt="" coords="233,589,372,630"/><area shape="rect" id="node25" href="classsouffle_1_1_ast_clause.html#a07290e1b7b9e4ce73c3a5f0482ce88d3" title="Set the head of clause to h. " alt="" coords="237,654,368,695"/><area shape="rect" id="node26" href="classsouffle_1_1_ast_atom.html#a92eeca331e34825aa9e7bcaabb812e56" title="Set atom name. " alt="" coords="212,720,393,747"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a253d3796df50375b98447daff50200f9" title="Construct an empty clause with empty list of literals and its head set to NULL. " alt="" coords="481,11,612,53"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a2ad833e42f55e6c61bdd12d6c5c2d482" title="Return source location of the AstNode. " alt="" coords="453,143,640,169"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_clause.html#af03a18e982fbce1bb3866c18c5da192e" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="481,77,613,118"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_relation.html#abc452f3678fbd70929638ae5c779cca6" title="Add a new used type to this relation. " alt="" coords="478,311,615,353"/><area shape="rect" id="node12" href="classsouffle_1_1_ast_relation.html#adf9ccc5b4924918ea95bd64898196b66" title="Obtains a list of the contained attributes. " alt="" coords="478,377,615,418"/><area shape="rect" id="node15" href="classsouffle_1_1_ast_relation.html#ac2902ef3d54670976da8bcaf4a9f4b45" title="Set name for this relation. " alt="" coords="478,194,615,235"/><area shape="rect" id="node17" href="namespacesouffle.html#aee69f1913bc5a4f49deeca2b10c8323b" title="souffle::updateQualifier" alt="" coords="469,260,625,287"/><area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="690,384,825,411"/><area shape="rect" id="node18" href="classsouffle_1_1_ast_relation.html#a15a48bcd5bcf6eebbc4bb4ef16e52685" title="Return qualifier associated with this relation. " alt="" coords="689,318,826,359"/><area shape="rect" id="node19" href="classsouffle_1_1_ast_relation.html#a96ff8bd588002b8182393d95258c9d66" title="Check whether relation is a equivalence relation. " alt="" coords="689,187,826,229"/><area shape="rect" id="node20" href="classsouffle_1_1_ast_relation.html#a9527d30091d612f497c769ca3e87548f" title="Set qualifier associated with this relation. " alt="" coords="689,253,826,294"/><area shape="rect" id="node23" href="classsouffle_1_1_ast_program.html#ae4e787ea4d338524ea6b346d5dedc290" title="Find and return the relation in the program given its name. " alt="" coords="477,545,616,586"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab31e06999eb72da2f6d9a85bdd3dda59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::simpleName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File name, with extension removed. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01068">1068</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>, and <a class="el" href="_precedence_graph_8cpp_source.html#l00279">souffle::SCCGraph::printJson()</a>.</p>
<div class="fragment"><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;                                                   {</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    std::string <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a> = path;</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastDot = name.find_last_of(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;    <span class="comment">// file has no extension</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;    <span class="keywordflow">if</span> (lastDot == std::string::npos) <span class="keywordflow">return</span> <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>;</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastSlash = name.find_last_of(<span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    <span class="comment">// last slash occurs after last dot, so no extension</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="keywordflow">if</span> (lastSlash != std::string::npos &amp;&amp; lastSlash &gt; lastDot) <span class="keywordflow">return</span> <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>;</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    <span class="comment">// last dot after last slash, or no slash</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    <span class="keywordflow">return</span> name.substr(0, lastDot);</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7f32090909fb88cd5af742382c7ddd2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; souffle::split </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function to split a string </p>

<p>Definition at line <a class="el" href="_explain_provenance_8h_source.html#l00031">31</a> of file <a class="el" href="_explain_provenance_8h_source.html">ExplainProvenance.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00748">times()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00386">addIgnoredRelations()</a>, and <a class="el" href="_explain_8h_source.html#l00156">souffle::Explain::explain()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                                           {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    std::vector&lt;std::string&gt; v;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    std::stringstream ss(s);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    std::string item;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">while</span> ((<a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> &gt; 0 || <a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> &lt;= -1) &amp;&amp; std::getline(ss, item, delim)) {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        v.push_back(item);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a>--;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">if</span> (ss.peek() != EOF) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        std::string remainder;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        std::getline(ss, remainder);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        v.push_back(remainder);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a0fff2be077dd5d1105f3a6e718339f2f"><div class="ttname"><a href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">souffle::times</a></div><div class="ttdeci">detail::multiplying_printer&lt; T &gt; times(const T &amp;value, unsigned num)</div><div class="ttdoc">A utility printing a given value multiple times. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00748">Util.h:748</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7f32090909fb88cd5af742382c7ddd2c_cgraph.png" border="0" usemap="#namespacesouffle_a7f32090909fb88cd5af742382c7ddd2c_cgraph" alt=""/></div>
<map name="namespacesouffle_a7f32090909fb88cd5af742382c7ddd2c_cgraph" id="namespacesouffle_a7f32090909fb88cd5af742382c7ddd2c_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f" title="A utility printing a given value multiple times. " alt="" coords="147,5,248,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="adbd8bc2c34ae58f7434a556eeafdfedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; souffle::split </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00048">48</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                                                       {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    std::set&lt;std::string&gt; res;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordtype">int</span> begin = 0;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; str.size(); i++) {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">if</span> (str[i] == delimiter) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            std::string token = str.substr(begin, (i - begin));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            res.insert(token);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            begin = i + 1;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    res.insert(str.substr(begin));  <span class="comment">// add in the last remaining token</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    res.erase(<span class="stringliteral">&quot;&quot;</span>);                  <span class="comment">// remove empty tokens</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a06f428910159c119c1dcdcab76ab7dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::stringify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stringify a string using escapes for newline, tab, double-quotes and semicolons. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01107">1107</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_ram_statement_8h_source.html#l00771">souffle::RamLogTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00834">souffle::RamDebugInfo::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00886">souffle::RamLogSize::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00928">souffle::RamPrintSize::print()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00837">souffle::AstTranslator::translateNonRecursiveRelation()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00942">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;                                                   {</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    std::string str(input);</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    <span class="comment">// replace semicolons returns by escape sequence</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;    <span class="keywordtype">size_t</span> start_pos = 0;</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    <span class="keywordflow">while</span> ((start_pos = str.find(<span class="charliteral">&#39;;&#39;</span>, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;        str.replace(start_pos, 1, <span class="stringliteral">&quot;\\;&quot;</span>);</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;        start_pos += 2;</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;    }</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    <span class="comment">// replace double-quotes returns by escape sequence</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    start_pos = 0;</div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    <span class="keywordflow">while</span> ((start_pos = str.find(<span class="charliteral">&#39;&quot;&#39;</span>, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;        str.replace(start_pos, 1, <span class="stringliteral">&quot;\\\&quot;&quot;</span>);</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;        start_pos += 2;</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    }</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    <span class="comment">// replace newline returns by escape sequence</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    start_pos = 0;</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="keywordflow">while</span> ((start_pos = str.find(<span class="charliteral">&#39;\n&#39;</span>, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        str.replace(start_pos, 1, <span class="stringliteral">&quot;\\n&quot;</span>);</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;        start_pos += 2;</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    }</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    <span class="comment">// replace tab returns by escape sequence</span></div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    start_pos = 0;</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;    <span class="keywordflow">while</span> ((start_pos = str.find(<span class="charliteral">&#39;\t&#39;</span>, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        str.replace(start_pos, 1, <span class="stringliteral">&quot;\\t&quot;</span>);</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;        start_pos += 2;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    }</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7f93cdf21f1a24b593da6691dc892828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt;<a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a>&gt; &gt; souffle::sub </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<p>a  b</p>
<p>where a and b are variables and  is the order relation induced by their associated property space. </p>

<p>Definition at line <a class="el" href="_constraints_8h_source.html#l00223">223</a> of file <a class="el" href="_constraints_8h_source.html">Constraints.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00639">souffle::AstSemanticChecker::checkUnionType()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01249">souffle::Synthesiser::generateCode()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00150">reduceSubstitution()</a>.</p>
<div class="fragment"><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keyword">struct </span>Sub : <span class="keyword">public</span> Constraint&lt;Var&gt; {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <a class="code" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> a, b;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        std::string symbol;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        Sub(<span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a>&amp; a, <span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a>&amp; b, <span class="keyword">const</span> std::string&amp; symbol) : a(a), b(b), symbol(symbol) {}</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;Var&gt;&amp; ass)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[b], ass[a]);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; b;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    };</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, b, symbol);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_1_1scheduler_html_a810733b014c004044203e764e2880a64"><div class="ttname"><a href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">souffle::scheduler::Var</a></div><div class="ttdeci">int Var</div><div class="ttdoc">The type utilized to reference variables. </div><div class="ttdef"><b>Definition:</b> <a href="_rule_scheduler_8h_source.html#l00036">RuleScheduler.h:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a688bb15c1b54c1fb493463f09857778b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt;<a class="el" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a>&gt; &gt; souffle::sub </td>
          <td>(</td>
          <td class="paramtype">const Val &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<p>a  b</p>
<p>where b is a variables, a is a value of b's property space, and  is the order relation induced by b's property space. </p>

<p>Definition at line <a class="el" href="_constraints_8h_source.html#l00252">252</a> of file <a class="el" href="_constraints_8h_source.html">Constraints.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="keyword">struct </span>Sub : <span class="keyword">public</span> Constraint&lt;Var&gt; {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        Val a;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <a class="code" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a> b;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        std::string symbol;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        Sub(<span class="keyword">const</span> Val&amp; a, <span class="keyword">const</span> <a class="code" href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">Var</a>&amp; b, <span class="keyword">const</span> std::string&amp; symbol) : a(a), b(b), symbol(symbol) {}</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="keyword">virtual</span> <span class="keywordtype">bool</span> update(Assignment&lt;Var&gt;&amp; ass)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[b], a);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="keyword">virtual</span> <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; b;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    };</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, b, symbol);</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_1_1scheduler_html_a810733b014c004044203e764e2880a64"><div class="ttname"><a href="namespacesouffle_1_1scheduler.html#a810733b014c004044203e764e2880a64">souffle::scheduler::Var</a></div><div class="ttdeci">int Var</div><div class="ttdoc">The type utilized to reference variables. </div><div class="ttdef"><b>Definition:</b> <a href="_rule_scheduler_8h_source.html#l00036">RuleScheduler.h:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2122cfa5acdee4846ecda0855f0beee4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::tempFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate temporary file. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l01098">1098</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;                            {</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;    <span class="keywordtype">char</span> templ[40] = <span class="stringliteral">&quot;./souffleXXXXXX&quot;</span>;</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    close(mkstemp(templ));</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    <span class="keywordflow">return</span> std::string(templ);</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a529b2e542971d474c9d97b1546001dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ternaryOpAcceptsNumbers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TernaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an argument has a number value. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00079">79</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a5b421b00c7c5768cfaba47f3885e1c44a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00484">souffle::AstTernaryFunctor::acceptsNumbers()</a>, and <a class="el" href="_ternary_functor_ops_8h_source.html#l00094">ternaryOpAcceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                                                 {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    assert(arg &gt;= 0 &amp;&amp; arg &lt; 3 &amp;&amp; <span class="stringliteral">&quot;argument out of range&quot;</span>);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">case</span> TernaryOp::SUBSTR:</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keywordflow">return</span> arg == 1 || arg == 2;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7778845f2059dbeb6e09b524cf45fca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ternaryOpAcceptsSymbols </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TernaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an argument has a symbolic value. </p>

<p>Definition at line <a class="el" href="_ternary_functor_ops_8h_source.html#l00094">94</a> of file <a class="el" href="_ternary_functor_ops_8h_source.html">TernaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_ternary_functor_ops_8h_source.html#l00079">ternaryOpAcceptsNumbers()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00489">souffle::AstTernaryFunctor::acceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                                                                 {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#a529b2e542971d474c9d97b1546001dcf">ternaryOpAcceptsNumbers</a>(arg, op);</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a529b2e542971d474c9d97b1546001dcf"><div class="ttname"><a href="namespacesouffle.html#a529b2e542971d474c9d97b1546001dcf">souffle::ternaryOpAcceptsNumbers</a></div><div class="ttdeci">bool ternaryOpAcceptsNumbers(int arg, const TernaryOp op)</div><div class="ttdoc">Determines whether an argument has a number value. </div><div class="ttdef"><b>Definition:</b> <a href="_ternary_functor_ops_8h_source.html#l00079">TernaryFunctorOps.h:79</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7778845f2059dbeb6e09b524cf45fca1_cgraph.png" border="0" usemap="#namespacesouffle_a7778845f2059dbeb6e09b524cf45fca1_cgraph" alt=""/></div>
<map name="namespacesouffle_a7778845f2059dbeb6e09b524cf45fca1_cgraph" id="namespacesouffle_a7778845f2059dbeb6e09b524cf45fca1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a529b2e542971d474c9d97b1546001dcf" title="Determines whether an argument has a number value. " alt="" coords="230,5,405,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0fff2be077dd5d1105f3a6e718339f2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">detail::multiplying_printer</a>&lt;T&gt; souffle::times </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility printing a given value multiple times. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00748">748</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_trie_8h_source.html#l01148">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::dump()</a>, <a class="el" href="_ram_operation_8cpp_source.html#l00103">souffle::RamScan::print()</a>, <a class="el" href="_ram_operation_8cpp_source.html#l00162">souffle::RamLookup::print()</a>, <a class="el" href="_ram_operation_8cpp_source.html#l00213">souffle::RamAggregate::print()</a>, and <a class="el" href="_explain_provenance_8h_source.html#l00031">split()</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                                                                 {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="keywordflow">return</span> detail::multiplying_printer&lt;T&gt;(value, num);</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b5d35fc5fbcf6970adb86505b9263da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string souffle::toBase64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_debug_report_8cpp_source.html#l00027">27</a> of file <a class="el" href="_debug_report_8cpp_source.html">DebugReport.cpp</a>.</p>

<p>References <a class="el" href="_ast_tuner_8cpp_source.html#l00044">data</a>.</p>

<p>Referenced by <a class="el" href="_debug_report_8cpp_source.html#l00164">souffle::DebugReporter::getDotGraphSection()</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                          {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;char&gt; table = {<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;G&#39;</span>, <span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;I&#39;</span>, <span class="charliteral">&#39;J&#39;</span>, <span class="charliteral">&#39;K&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;M&#39;</span>,</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;O&#39;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="charliteral">&#39;Q&#39;</span>, <span class="charliteral">&#39;R&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;V&#39;</span>, <span class="charliteral">&#39;W&#39;</span>, <span class="charliteral">&#39;X&#39;</span>, <span class="charliteral">&#39;Y&#39;</span>, <span class="charliteral">&#39;Z&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;f&#39;</span>,</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>,</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            <span class="charliteral">&#39;z&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;+&#39;</span>, <span class="charliteral">&#39;/&#39;</span>};</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    std::string result;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    std::string tmp = <a class="code" href="_ast_tuner_8cpp.html#ad05509a64790e25cfb28a937bc68114d">data</a>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> padding = 0;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="_ast_tuner_8cpp.html#ad05509a64790e25cfb28a937bc68114d">data</a>.size() % 3 == 2) {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        padding = 1;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="_ast_tuner_8cpp.html#ad05509a64790e25cfb28a937bc68114d">data</a>.size() % 3 == 1) {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        padding = 2;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; padding; i++) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        tmp.push_back(0);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tmp.size(); i += 3) {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(tmp[i]);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(tmp[i + 1]);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c3 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(tmp[i + 2]);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> index1 = c1 &gt;&gt; 2;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> index2 = ((c1 &amp; 0x03) &lt;&lt; 4) | (c2 &gt;&gt; 4);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> index3 = ((c2 &amp; 0x0F) &lt;&lt; 2) | (c3 &gt;&gt; 6);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> index4 = c3 &amp; 0x3F;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        result.push_back(table[index1]);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        result.push_back(table[index2]);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        result.push_back(table[index3]);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        result.push_back(table[index4]);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">if</span> (padding == 1) {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        result[result.size() - 1] = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (padding == 2) {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        result[result.size() - 1] = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        result[result.size() - 2] = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div>
<div class="ttc" id="_ast_tuner_8cpp_html_ad05509a64790e25cfb28a937bc68114d"><div class="ttname"><a href="_ast_tuner_8cpp.html#ad05509a64790e25cfb28a937bc68114d">data</a></div><div class="ttdeci">Data &amp; data</div><div class="ttdoc">The recorded data. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_tuner_8cpp_source.html#l00044">AstTuner.cpp:44</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa5e347aaf113d69fceb9d2eb6f8b052e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::toBddbddb </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AstTranslationUnit &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given souffle-datalog translation unit into bdddbddb input code and writes the result into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write the result to </td></tr>
    <tr><td class="paramname">translationUnit</td><td>the translation unit to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsouffle_1_1_unsupported_construct_exception.html" title="The kind of exception to be raised if an error in the conversion to a bddbddb input program has been ...">UnsupportedConstructException</a></td><td>if constructs that can not be expressed within bddbddb have been encountered </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_bddbddb_backend_8cpp_source.html#l00222">222</a> of file <a class="el" href="_bddbddb_backend_8cpp_source.html">BddbddbBackend.cpp</a>.</p>

<p>References <a class="el" href="_bddbddb_backend_8cpp_source.html#l00040">souffle::detail::BddbddbConverter::convert()</a>, and <a class="el" href="_ast_translation_unit_8h_source.html#l00073">souffle::AstTranslationUnit::getProgram()</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                                                           {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">// simply run the converter</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    detail::BddbddbConverter().convert(out, *translationUnit.getProgram());</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;}</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa5e347aaf113d69fceb9d2eb6f8b052e_cgraph.png" border="0" usemap="#namespacesouffle_aa5e347aaf113d69fceb9d2eb6f8b052e_cgraph" alt=""/></div>
<map name="namespacesouffle_aa5e347aaf113d69fceb9d2eb6f8b052e_cgraph" id="namespacesouffle_aa5e347aaf113d69fceb9d2eb6f8b052e_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1detail_1_1_bddbddb_converter.html#a7c237bccb990b8c0adbab0889b54ce40" title="souffle::detail::Bddbddb\lConverter::convert" alt="" coords="194,13,353,54"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="185,78,362,119"/><area shape="rect" id="node3" href="structsouffle_1_1_ast_visitor.html#ac26669114316a4b0ef0db9427b23bcac" title="The main entry for a visit process conducting the dispatching of a visit to the various sub&#45;types of ..." alt="" coords="411,5,549,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a399105b8de1698758c5b18bc9efca9fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> souffle::toBinaryConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts symbolic representation of an operator to the operator. </p>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00113">113</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a8635afa1dc3f77400843ddfb2efa0065">__UNDEFINED__</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                                                                        {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::EQ;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;!=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NE;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&lt;&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::LT;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&lt;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::LE;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&gt;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::GE;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&gt;&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::GT;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;match&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::MATCH;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;contains&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::CONTAINS;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;not_match&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NOT_MATCH;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;not_contains&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NOT_CONTAINS;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognised operator: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">return</span> BinaryConstraintOp::__UNDEFINED__;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abad7410af2a4ba80aecfefede16c6a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::toBinaryConstraintSymbol </td>
          <td>(</td>
          <td class="paramtype">BinaryConstraintOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts operator to its symbolic representation. </p>

<p>Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00081">81</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>.</p>

<p>Referenced by <a class="el" href="_ram_condition_8h_source.html#l00135">souffle::RamBinaryRelation::print()</a>, <a class="el" href="_ast_literal_8h_source.html#l00292">souffle::AstConstraint::print()</a>, and <a class="el" href="_bddbddb_backend_8cpp_source.html#l00159">souffle::detail::BddbddbConverter::visitConstraint()</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                                                 {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;=&quot;</span>;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;!=&quot;</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;&quot;</span>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;=&quot;</span>;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&gt;=&quot;</span>;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;match&quot;</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;contains&quot;</span>;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;not_match&quot;</span>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;not_contains&quot;</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;?&quot;</span>;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a157284692de2638d283c06b62135fe54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T*&gt; souffle::toPtrSet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a set of pointers. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00195">195</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                                                       {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    std::set&lt;T*&gt; res;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : v) {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        res.insert(e.get());</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    }</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9996cd50fb4bb795892186890469013b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T*&gt; souffle::toPtrSet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a set of pointers. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00207">207</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                                                       {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    std::set&lt;T*&gt; res;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : v) {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        res.insert(e.get());</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad62d4e824a9d74c7462da546a21780fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt; souffle::toPtrVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector of pointers. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00139">139</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ram_value_8h_source.html#l00490">souffle::RamPack::getArguments()</a>, <a class="el" href="_ast_argument_8h_source.html#l00556">souffle::AstRecordInit::getArguments()</a>, <a class="el" href="_ast_clause_8h_source.html#l00306">souffle::AstClause::getAtoms()</a>, <a class="el" href="_ast_relation_8h_source.html#l00129">souffle::AstRelation::getAttributes()</a>, <a class="el" href="_ast_argument_8h_source.html#l00696">souffle::AstAggregator::getBodyLiterals()</a>, <a class="el" href="_ast_component_8h_source.html#l00268">souffle::AstComponent::getClauses()</a>, <a class="el" href="_ast_relation_8h_source.html#l00302">souffle::AstRelation::getClauses()</a>, <a class="el" href="_ast_program_8h_source.html#l00174">souffle::AstProgram::getComponentInstantiations()</a>, <a class="el" href="_ast_program_8h_source.html#l00169">souffle::AstProgram::getComponents()</a>, <a class="el" href="_ast_component_8h_source.html#l00292">souffle::AstComponent::getComponents()</a>, <a class="el" href="_ast_clause_8h_source.html#l00316">souffle::AstClause::getConstraints()</a>, <a class="el" href="_ast_component_8h_source.html#l00300">souffle::AstComponent::getInstantiations()</a>, <a class="el" href="_ast_component_8h_source.html#l00284">souffle::AstComponent::getIODirectives()</a>, <a class="el" href="_ast_relation_8h_source.html#l00362">souffle::AstRelation::getIODirectives()</a>, <a class="el" href="_ast_clause_8h_source.html#l00311">souffle::AstClause::getNegations()</a>, <a class="el" href="_ast_program_8h_source.html#l00150">souffle::AstProgram::getOrphanClauses()</a>, <a class="el" href="_ram_operation_8h_source.html#l00372">souffle::RamAggregate::getPattern()</a>, <a class="el" href="_ram_operation_8h_source.html#l00202">souffle::RamScan::getRangePattern()</a>, <a class="el" href="_ast_component_8h_source.html#l00260">souffle::AstComponent::getRelations()</a>, <a class="el" href="_ram_statement_8h_source.html#l00503">souffle::RamSequence::getStatements()</a>, <a class="el" href="_ram_statement_8h_source.html#l00578">souffle::RamParallel::getStatements()</a>, <a class="el" href="_ast_component_8h_source.html#l00252">souffle::AstComponent::getTypes()</a>, <a class="el" href="_ram_condition_8h_source.html#l00226">souffle::RamNotExists::getValues()</a>, <a class="el" href="_ram_statement_8h_source.html#l00360">souffle::RamFact::getValues()</a>, <a class="el" href="_ram_operation_8h_source.html#l00470">souffle::RamProject::getValues()</a>, <a class="el" href="_ram_value_8h_source.html#l00487">souffle::RamPack::getValues()</a>, and <a class="el" href="_ram_operation_8h_source.html#l00547">souffle::RamReturn::getValues()</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                                                                {</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    std::vector&lt;T*&gt; res;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : v) {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        res.push_back(e.get());</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    }</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe1e036ca35b6dceb0200ccbebc3dbf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt; souffle::toPtrVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector of pointers. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00151">151</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                                                {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    std::vector&lt;T*&gt; res;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : v) {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        res.push_back(e.get());</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    }</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aafad5f52d5175fff02862fa747763645"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; souffle::toSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a set with a fixed set of elements within a single expression. </p>
<p>This is the base case covering empty sets. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00177">177</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                  {</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="keywordflow">return</span> std::set&lt;T&gt;();</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3e7ecbc7d7a65ac2de10c9f21543f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; souffle::toSet </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a set with a fixed set of elements within a single expression. </p>
<p>This is the step case covering sets of arbitrary length. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00187">187</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                                                  {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">return</span> {first, rest...};</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aecc08c83ad9634fc515b7aa094702949"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generic function converting strings into strings (trivial case). </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00673">673</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_parser_driver_8cpp_source.html#l00124">souffle::ParserDriver::addIODirective()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00092">souffle::ParserDriver::addRelation()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00145">souffle::ParserDriver::addType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00303">souffle::AstSemanticChecker::checkAtom()</a>, <a class="el" href="_ast_component_checker_8cpp_source.html#l00184">souffle::AstComponentChecker::checkComponentNamespaces()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00936">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00692">souffle::AstSemanticChecker::checkIODirectives()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01145">souffle::AstSemanticChecker::checkNamespaces()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00651">souffle::AstSemanticChecker::checkRecordType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00596">souffle::AstSemanticChecker::checkRelation()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00550">souffle::AstSemanticChecker::checkRelationDeclaration()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00639">souffle::AstSemanticChecker::checkUnionType()</a>, <a class="el" href="_component_model_8cpp_source.html#l00038">souffle::ComponentLookup::getComponent()</a>, <a class="el" href="_type_system_8cpp_source.html#l00256">getTypeQualifier()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00548">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00344">souffle::ResolveAliasesTransformer::removeComplexTermsInAtoms()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00515">souffle::UniqueAggregationVariablesTransformer::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00837">souffle::AstTranslator::translateNonRecursiveRelation()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00942">souffle::AstTranslator::translateRecursiveRelation()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00112">souffle::detail::BddbddbConverter::visitClause()</a>, <a class="el" href="_bddbddb_backend_8cpp_source.html#l00178">souffle::detail::BddbddbConverter::visitFunctor()</a>, and <a class="el" href="_bddbddb_backend_8cpp_source.html#l00215">souffle::detail::BddbddbConverter::visitNode()</a>.</p>
<div class="fragment"><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                                                       {</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aac0f01b6b803d03b90d7f33df9351ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt;T&gt;::value, std::string&gt;::type souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic function converting arbitrary objects to strings by utilizing their print capability. </p>
<p>This function is mainly intended for implementing test cases and debugging operations. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00704">704</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    <span class="comment">// write value into stream and return result</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    ss &lt;&lt; value;</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ae87378d37c861ccf867805d6b6ed4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt;T&gt;::value, std::string&gt;::type souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fallback for the to-string function in case an unprintable object is supposed to be printed. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00716">716</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    std::stringstream ss;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot;(print for type &quot;</span>;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    ss &lt;&lt; <span class="keyword">typeid</span>(T).<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>();</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot; not supported)&quot;</span>;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;}</div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab2822ded4e7fd1466479b3fd6a1345a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; souffle::toVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector with a fixed set of elements within a single expression. </p>
<p>This is the base case covering empty vectors. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00121">121</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_compiled_ram_relation_8h_source.html#l00810">souffle::ram::detail::AutoRelation&lt; 0 &gt;::partition()</a>, and <a class="el" href="_trie_8h_source.html#l02684">souffle::Trie&lt; 0u &gt;::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                        {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">return</span> std::vector&lt;T&gt;();</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa8b505a63ac23af9d89fdcbbbba3ea8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; souffle::toVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector with a fixed set of elements within a single expression. </p>
<p>This is the step case covering vectors of arbitrary length. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00131">131</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                                        {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">return</span> {first, rest...};</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a42d3f12f76a6b9df4ef6c65fdc18e39c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::transformEqrelRelation </td>
          <td>(</td>
          <td class="paramtype">AstRelation &amp;&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform eqrel relations to explicitly define equivalence relations. </p>

<p>Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00094">94</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00095">souffle::AstAtom::addArgument()</a>, <a class="el" href="_ast_relation_8h_source.html#l00307">souffle::AstRelation::addClause()</a>, <a class="el" href="_ast_relation_8h_source.html#l00061">EQREL_RELATION</a>, <a class="el" href="_ast_relation_8h_source.html#l00119">souffle::AstRelation::getArity()</a>, <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::getName()</a>, <a class="el" href="_ast_relation_8h_source.html#l00134">souffle::AstRelation::getQualifier()</a>, <a class="el" href="_ast_relation_8h_source.html#l00169">souffle::AstRelation::isEqRel()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00139">souffle::AstRelation::setQualifier()</a>.</p>

<p>Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00151">souffle::ProvenanceTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                                              {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    assert(rel.isEqRel() &amp;&amp; <span class="stringliteral">&quot;attempting to transform non-eqrel relation&quot;</span>);</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    assert(rel.getArity() == 2 &amp;&amp; <span class="stringliteral">&quot;eqrel relation not binary&quot;</span>);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    rel.setQualifier(rel.getQualifier() - <a class="code" href="_ast_relation_8h.html#a28e5dbf81ef11732fde9d3d5f6b79f2e">EQREL_RELATION</a>);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="comment">// transitivity</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="comment">// transitive clause: A(x, z) :- A(x, y), A(y, z).</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keyword">auto</span> transitiveClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keyword">auto</span> transitiveClauseHead = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    transitiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    transitiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    transitiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    transitiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody2 = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    transitiveClauseBody2-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    transitiveClauseBody2-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    transitiveClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(transitiveClauseHead));</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    transitiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(transitiveClauseBody));</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    transitiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(transitiveClauseBody2));</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    rel.addClause(std::unique_ptr&lt;AstClause&gt;(transitiveClause));</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">// symmetric</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">// symmetric clause: A(x, y) :- A(y, x).</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keyword">auto</span> symClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keyword">auto</span> symClauseHead = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    symClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    symClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keyword">auto</span> symClauseBody = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    symClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    symClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    symClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(symClauseHead));</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    symClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(symClauseBody));</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    rel.addClause(std::unique_ptr&lt;AstClause&gt;(symClause));</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="comment">// reflexivity</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">// reflexive clause: A(x, x) :- A(x, _).</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keyword">auto</span> reflexiveClause = <span class="keyword">new</span> AstClause();</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keyword">auto</span> reflexiveClauseHead = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    reflexiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    reflexiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keyword">auto</span> reflexiveClauseBody = <span class="keyword">new</span> AstAtom(rel.getName());</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    reflexiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    reflexiveClauseBody-&gt;addArgument(std::make_unique&lt;AstUnnamedVariable&gt;());</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    reflexiveClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(reflexiveClauseHead));</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    reflexiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(reflexiveClauseBody));</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    rel.addClause(std::unique_ptr&lt;AstClause&gt;(reflexiveClause));</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;}</div>
<div class="ttc" id="_ast_relation_8h_html_a28e5dbf81ef11732fde9d3d5f6b79f2e"><div class="ttname"><a href="_ast_relation_8h.html#a28e5dbf81ef11732fde9d3d5f6b79f2e">EQREL_RELATION</a></div><div class="ttdeci">#define EQREL_RELATION</div><div class="ttdef"><b>Definition:</b> <a href="_ast_relation_8h_source.html#l00061">AstRelation.h:61</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a42d3f12f76a6b9df4ef6c65fdc18e39c_cgraph.png" border="0" usemap="#namespacesouffle_a42d3f12f76a6b9df4ef6c65fdc18e39c_cgraph" alt=""/></div>
<map name="namespacesouffle_a42d3f12f76a6b9df4ef6c65fdc18e39c_cgraph" id="namespacesouffle_a42d3f12f76a6b9df4ef6c65fdc18e39c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a0c2e151bc853490e6210c33c8fd127be" title="Add argument to the atom. " alt="" coords="256,5,461,32"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation.html#ac1c9cc395384b02288abcd189d2e6631" title="Add a clause to the relation. " alt="" coords="290,57,427,98"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_relation.html#a855b01ad5e4a0871ef6c6f6bb1e95d13" title="Return the arity of this relation. " alt="" coords="290,122,427,163"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_relation.html#a6ae505289ecfc8e40c9f4e47689f5ee8" title="Return the name of the relation. " alt="" coords="290,187,427,229"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#a15a48bcd5bcf6eebbc4bb4ef16e52685" title="Return qualifier associated with this relation. " alt="" coords="290,253,427,294"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#a96ff8bd588002b8182393d95258c9d66" title="Check whether relation is a equivalence relation. " alt="" coords="290,318,427,359"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_relation.html#a9527d30091d612f497c769ca3e87548f" title="Set qualifier associated with this relation. " alt="" coords="290,383,427,425"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac9af2eda2dd88cc60de32a89c4dc891c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::unaryOpAcceptsNumbers </td>
          <td>(</td>
          <td class="paramtype">const UnaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given operator takes a numeric argument. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00168">168</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a2655b658707a1e9bc2d9ece8e81434fd">ACOS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5430ac1a562ce2c1803bba1b9e26ada7">ACOSH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a8db07d2e99c2a6161d6dc93c2fe4efff">ASIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a17f260603139b1211836fc9fe6af32d2">ASINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac48a365c0a15f8c01a4006d6a17da5be">ATAN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a7b5d2847ff4dd6eacaa0c32e26603e21">ATANH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4aef23ef1d426ae1a73a7eed399cef707d">COS</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac8766c03013c3464d6bfd8e3c11b867d">COSH</a>, <a class="el" href="namespacesouffle.html#ab85d062f6daca1d15c9ce9def0a2dffaa8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a4b5ffcdaf38ce4d463171f5c977c5ab3">LOG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a5b001d63db54e7383587771eeb2018a1">SIN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4ab387e847a769f9ef3794a3f559afcf69">SINH</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a71211c96ad35b40178446956e22be10e">TAN</a>, and <a class="el" href="namespacesouffle.html#a717c9e8fd9648e0022b397a57191e4f4a143c8c6f51b9bb893ce71e38702e3cc1">TANH</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00307">souffle::AstUnaryFunctor::acceptsNumbers()</a>, and <a class="el" href="_unary_functor_ops_8h_source.html#l00201">unaryOpAcceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                                                    {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">switch</span> (op) {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keywordflow">case</span> UnaryOp::NEG:</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">case</span> UnaryOp::BNOT:</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LNOT:</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SIN:</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COS:</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TAN:</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASIN:</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOS:</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATAN:</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordflow">case</span> UnaryOp::SINH:</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">case</span> UnaryOp::COSH:</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="keywordflow">case</span> UnaryOp::TANH:</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ASINH:</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ACOSH:</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ATANH:</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">case</span> UnaryOp::LOG:</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">case</span> UnaryOp::EXP:</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">case</span> UnaryOp::ORD:</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="keywordflow">case</span> UnaryOp::STRLEN:</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    }</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported operator encountered!&quot;</span>);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3523c0cffbdbed0fabf4ad2f298f9c51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::unaryOpAcceptsSymbols </td>
          <td>(</td>
          <td class="paramtype">const UnaryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given operator takes a symbolic argument. </p>

<p>Definition at line <a class="el" href="_unary_functor_ops_8h_source.html#l00201">201</a> of file <a class="el" href="_unary_functor_ops_8h_source.html">UnaryFunctorOps.h</a>.</p>

<p>References <a class="el" href="_unary_functor_ops_8h_source.html#l00168">unaryOpAcceptsNumbers()</a>.</p>

<p>Referenced by <a class="el" href="_ast_argument_8h_source.html#l00312">souffle::AstUnaryFunctor::acceptsSymbols()</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                                    {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordflow">return</span> !<a class="code" href="namespacesouffle.html#ac9af2eda2dd88cc60de32a89c4dc891c">unaryOpAcceptsNumbers</a>(op);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ac9af2eda2dd88cc60de32a89c4dc891c"><div class="ttname"><a href="namespacesouffle.html#ac9af2eda2dd88cc60de32a89c4dc891c">souffle::unaryOpAcceptsNumbers</a></div><div class="ttdeci">bool unaryOpAcceptsNumbers(const UnaryOp op)</div><div class="ttdoc">Returns whether the given operator takes a numeric argument. </div><div class="ttdef"><b>Definition:</b> <a href="_unary_functor_ops_8h_source.html#l00168">UnaryFunctorOps.h:168</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3523c0cffbdbed0fabf4ad2f298f9c51_cgraph.png" border="0" usemap="#namespacesouffle_a3523c0cffbdbed0fabf4ad2f298f9c51_cgraph" alt=""/></div>
<map name="namespacesouffle_a3523c0cffbdbed0fabf4ad2f298f9c51_cgraph" id="namespacesouffle_a3523c0cffbdbed0fabf4ad2f298f9c51_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ac9af2eda2dd88cc60de32a89c4dc891c" title="Returns whether the given operator takes a numeric argument. " alt="" coords="272,5,491,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab66c00257a9f4ce44653d82cee9c563d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;std::pair&lt;<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*&gt; &gt; souffle::unifyAtoms </td>
          <td>(</td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstAtom *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nullable vector of substitutions needed to unify the two given atoms. </p>
<p>If unification is not successful, the returned vector is marked as invalid. Assumes that the atoms are both of the same relation. </p>

<p>Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00212">212</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p>References <a class="el" href="_ast_literal_8h_source.html#l00110">souffle::AstAtom::getArguments()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00150">reduceSubstitution()</a>.</p>

<p>Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00238">inlineBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    std::vector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt; substitution;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    std::vector&lt;AstArgument*&gt; firstArgs = first-&gt;getArguments();</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    std::vector&lt;AstArgument*&gt; secondArgs = second-&gt;getArguments();</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="comment">// Create the initial unification equalities</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; firstArgs.size(); i++) {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        substitution.push_back(std::make_pair(firstArgs[i], secondArgs[i]));</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">// Reduce the substitutions</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordtype">bool</span> success = <a class="code" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955">reduceSubstitution</a>(substitution);</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keywordflow">if</span> (success) {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt;(substitution);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="comment">// Failed to unify the two atoms</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt;();</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a08f3e2bc00f4340336a0f9a9dc4e9955"><div class="ttname"><a href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955">souffle::reduceSubstitution</a></div><div class="ttdeci">bool reduceSubstitution(std::vector&lt; std::pair&lt; AstArgument *, AstArgument * &gt;&gt; &amp;sub)</div><div class="ttdoc">Reduces a vector of substitutions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00150">InlineRelationsTransformer.cpp:150</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph.png" border="0" usemap="#namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph" alt=""/></div>
<map name="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph" id="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="190,5,399,32"/><area shape="rect" id="node4" href="namespacesouffle.html#a08f3e2bc00f4340336a0f9a9dc4e9955" title="Reduces a vector of substitutions. " alt="" coords="206,56,383,83"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="449,5,583,32"/><area shape="rect" id="node5" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="471,56,561,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aedb9e5cd2a72ce6acebd8d3eb233a05d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Tuple &amp; souffle::unpack </td>
          <td>(</td>
          <td class="paramtype">RamDomain&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function obtaining a pointer to the tuple addressed by the given reference. </p>

<p>Definition at line <a class="el" href="_compiled_ram_record_8h_source.html#l00169">169</a> of file <a class="el" href="_compiled_ram_record_8h_source.html">CompiledRamRecord.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                   {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">return</span> detail::getRecordMap&lt;Tuple&gt;().<a class="code" href="namespacesouffle.html#aedb9e5cd2a72ce6acebd8d3eb233a05d">unpack</a>(ref);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_aedb9e5cd2a72ce6acebd8d3eb233a05d"><div class="ttname"><a href="namespacesouffle.html#aedb9e5cd2a72ce6acebd8d3eb233a05d">souffle::unpack</a></div><div class="ttdeci">const Tuple &amp; unpack(RamDomain ref)</div><div class="ttdoc">A function obtaining a pointer to the tuple addressed by the given reference. </div><div class="ttdef"><b>Definition:</b> <a href="_compiled_ram_record_8h_source.html#l00169">CompiledRamRecord.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeb71fcacdd48ed600f623c3c3b135538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa54e5c2cf102680c9fec848f5ac6460c">RamDomain</a> * souffle::unpack </td>
          <td>(</td>
          <td class="paramtype">RamDomain&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function obtaining a pointer to the tuple addressed by the given reference. </p>

<p>Definition at line <a class="el" href="_interpreter_records_8cpp_source.html#l00115">115</a> of file <a class="el" href="_interpreter_records_8cpp_source.html">InterpreterRecords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                                            {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">// conduct the unpacking</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">return</span> getForArity(<a class="code" href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a>).unpack(ref);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div>
<div class="ttc" id="_interpreter_records_8cpp_html_a2e1dc7313b72e22a19179823661deb69"><div class="ttname"><a href="_interpreter_records_8cpp.html#a2e1dc7313b72e22a19179823661deb69">arity</a></div><div class="ttdeci">int arity</div><div class="ttdoc">The arity of the stored tuples. </div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_records_8cpp_source.html#l00036">InterpreterRecords.cpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aee69f1913bc5a4f49deeca2b10c8323b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::updateQualifier </td>
          <td>(</td>
          <td class="paramtype">AstRelation *&#160;</td>
          <td class="paramname"><em>originalRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstRelation *&#160;</td>
          <td class="paramname"><em>newRelation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00215">215</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p>References <a class="el" href="_ast_relation_8h_source.html#l00061">EQREL_RELATION</a>, <a class="el" href="_ast_relation_8h_source.html#l00134">souffle::AstRelation::getQualifier()</a>, <a class="el" href="_ast_relation_8h_source.html#l00169">souffle::AstRelation::isEqRel()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00139">souffle::AstRelation::setQualifier()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00226">createNewRelation()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                                                              {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordtype">int</span> currentQualifier = newRelation-&gt;getQualifier();</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">if</span> (originalRelation-&gt;isEqRel()) {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        currentQualifier |= <a class="code" href="_ast_relation_8h.html#a28e5dbf81ef11732fde9d3d5f6b79f2e">EQREL_RELATION</a>;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    newRelation-&gt;setQualifier(currentQualifier);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div>
<div class="ttc" id="_ast_relation_8h_html_a28e5dbf81ef11732fde9d3d5f6b79f2e"><div class="ttname"><a href="_ast_relation_8h.html#a28e5dbf81ef11732fde9d3d5f6b79f2e">EQREL_RELATION</a></div><div class="ttdeci">#define EQREL_RELATION</div><div class="ttdef"><b>Definition:</b> <a href="_ast_relation_8h_source.html#l00061">AstRelation.h:61</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aee69f1913bc5a4f49deeca2b10c8323b_cgraph.png" border="0" usemap="#namespacesouffle_aee69f1913bc5a4f49deeca2b10c8323b_cgraph" alt=""/></div>
<map name="namespacesouffle_aee69f1913bc5a4f49deeca2b10c8323b_cgraph" id="namespacesouffle_aee69f1913bc5a4f49deeca2b10c8323b_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#a15a48bcd5bcf6eebbc4bb4ef16e52685" title="Return qualifier associated with this relation. " alt="" coords="211,5,349,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_relation.html#a96ff8bd588002b8182393d95258c9d66" title="Check whether relation is a equivalence relation. " alt="" coords="211,70,349,111"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_relation.html#a9527d30091d612f497c769ca3e87548f" title="Set qualifier associated with this relation. " alt="" coords="211,135,349,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a82791915ce06d393ddbb1865ae58b8b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt;<a class="el" href="classsouffle_1_1_ast_src_location.html">AstSrcLocation</a>&gt; souffle::usesInvalidWitness </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; AstLiteral * &gt; &amp;&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::unique_ptr&lt; AstArgument &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>groundedArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00701">701</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p>References <a class="el" href="_ast_argument_8h_source.html#l00696">souffle::AstAggregator::getBodyLiterals()</a>, <a class="el" href="_ast_type_analysis_8cpp_source.html#l00321">getGroundedTerms()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00268">node</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>

<p>Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00826">souffle::AstSemanticChecker::checkWitnessProblem()</a>.</p>
<div class="fragment"><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;                                                                     {</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    <span class="comment">// Node-mapper that replaces aggregators with new (unique) variables</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        <span class="comment">// Variables introduced to replace aggregators</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        <span class="keyword">mutable</span> std::set&lt;std::string&gt; aggregatorVariables;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; getAggregatorVariables() {</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            <span class="keywordflow">return</span> aggregatorVariables;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        }</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> numReplaced = 0;</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            <span class="keywordflow">if</span> (AstAggregator* aggr = dynamic_cast&lt;AstAggregator*&gt;(node.get())) {</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                <span class="comment">// Replace the aggregator with a variable</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                std::stringstream newVariableName;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+aggr_var_&quot;</span> &lt;&lt; numReplaced++;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                <span class="comment">// Keep track of which variables are bound to aggregators</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                aggregatorVariables.insert(newVariableName.str());</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            }</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a>;</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        }</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    };</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    std::vector&lt;AstSrcLocation&gt; result;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="comment">// Create two versions of the original clause</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    <span class="comment">// Clause 1 - will remain equivalent to the original clause in terms of variable groundedness</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    <span class="keyword">auto</span> originalClause = std::make_unique&lt;AstClause&gt;();</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    originalClause-&gt;setHead(std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    <span class="comment">// Clause 2 - will have aggregators replaced with intrinsically grounded variables</span></div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="keyword">auto</span> aggregatorlessClause = std::make_unique&lt;AstClause&gt;();</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    aggregatorlessClause-&gt;setHead(std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="comment">// Construct both clauses in the same manner to match the original clause</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="comment">// Must keep track of the subnode in Clause 1 that each subnode in Clause 2 matches to</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    std::map&lt;const AstArgument*, const AstArgument*&gt; identicalSubnodeMap;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstLiteral* lit : literals) {</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        <span class="keyword">auto</span> firstClone = std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone());</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        <span class="keyword">auto</span> secondClone = std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone());</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        <span class="comment">// Construct the mapping between equivalent literal subnodes</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        std::vector&lt;const AstArgument*&gt; firstCloneArguments;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*firstClone, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { firstCloneArguments.push_back(&amp;arg); });</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        std::vector&lt;const AstArgument*&gt; secondCloneArguments;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*secondClone, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { secondCloneArguments.push_back(&amp;arg); });</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; firstCloneArguments.size(); i++) {</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            identicalSubnodeMap[secondCloneArguments[i]] = firstCloneArguments[i];</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        <span class="comment">// Actually add the literal clones to each clause</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        originalClause-&gt;addToBody(std::move(firstClone));</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        aggregatorlessClause-&gt;addToBody(std::move(secondClone));</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    }</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="comment">// Replace the aggregators in Clause 2 with variables</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    M update;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    aggregatorlessClause-&gt;apply(update);</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="comment">// Create a dummy atom to force certain arguments to be grounded in the aggregatorlessClause</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    <span class="keyword">auto</span> groundingAtomAggregatorless = std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    <span class="keyword">auto</span> groundingAtomOriginal = std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="comment">// Force the new aggregator variables to be grounded in the aggregatorless clause</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; aggregatorVariables = update.getAggregatorVariables();</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; str : aggregatorVariables) {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(str));</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <span class="comment">// Force the given grounded arguments to be grounded in both clauses</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;AstArgument&gt;&amp; arg : groundedArguments) {</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        groundingAtomOriginal-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    }</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    aggregatorlessClause-&gt;addToBody(std::move(groundingAtomAggregatorless));</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    originalClause-&gt;addToBody(std::move(groundingAtomOriginal));</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    <span class="comment">// Compare the grounded analysis of both generated clauses</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="comment">// All added arguments in Clause 2 were forced to be grounded, so if an ungrounded argument</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    <span class="comment">// appears in Clause 2, it must also appear in Clause 1. Consequently, have two cases:</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;    <span class="comment">//   - The argument is also ungrounded in Clause 1 - handled by another check</span></div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;    <span class="comment">//   - The argument is grounded in Clause 1 =&gt; the argument was grounded in the</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="comment">//     first clause somewhere along the line by an aggregator-body - not allowed!</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;    std::set&lt;std::unique_ptr&lt;AstArgument&gt;&gt; newlyGroundedArguments;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    std::map&lt;const AstArgument*, bool&gt; originalGrounded = <a class="code" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a>(*originalClause);</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    std::map&lt;const AstArgument*, bool&gt; aggregatorlessGrounded = <a class="code" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a>(*aggregatorlessClause);</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> pair : aggregatorlessGrounded) {</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        <span class="keywordflow">if</span> (!pair.second &amp;&amp; originalGrounded[identicalSubnodeMap[pair.first]]) {</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            result.push_back(pair.first-&gt;getSrcLoc());</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;        }</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;        <span class="comment">// Otherwise, it can now be considered grounded</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;        newlyGroundedArguments.insert(std::unique_ptr&lt;AstArgument&gt;(pair.first-&gt;clone()));</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    }</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    <span class="comment">// All previously grounded are still grounded</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;AstArgument&gt;&amp; arg : groundedArguments) {</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        newlyGroundedArguments.insert(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    }</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    <span class="comment">// Everything on this level is fine, check subaggregators of each literal</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstLiteral* lit : literals) {</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        <a class="code" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">visitDepthFirst</a>(*lit, [&amp;](<span class="keyword">const</span> AstAggregator&amp; aggr) {</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;            <span class="comment">// Check recursively if an invalid witness is used</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;            std::vector&lt;AstLiteral*&gt; aggrBodyLiterals = aggr.getBodyLiterals();</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            std::vector&lt;AstSrcLocation&gt; subresult =</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;                    <a class="code" href="namespacesouffle.html#a82791915ce06d393ddbb1865ae58b8b6">usesInvalidWitness</a>(aggrBodyLiterals, newlyGroundedArguments);</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            <span class="keywordflow">for</span> (AstSrcLocation argloc : subresult) {</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                result.push_back(argloc);</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;            }</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        });</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    }</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a247fd46943465169ffe79f25628e5dad"><div class="ttname"><a href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">souffle::getGroundedTerms</a></div><div class="ttdeci">std::map&lt; const AstArgument *, bool &gt; getGroundedTerms(const AstClause &amp;clause)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument whether it is a grounded value or n...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_type_analysis_8cpp_source.html#l00321">AstTypeAnalysis.cpp:321</a></div></div>
<div class="ttc" id="_synthesiser_8cpp_html_a67a32e5d40efd8e6086e8036d82970da"><div class="ttname"><a href="_synthesiser_8cpp.html#a67a32e5d40efd8e6086e8036d82970da">node</a></div><div class="ttdeci">const RamNode &amp; node</div><div class="ttdef"><b>Definition:</b> <a href="_synthesiser_8cpp_source.html#l00268">Synthesiser.cpp:268</a></div></div>
<div class="ttc" id="namespacesouffle_html_a82791915ce06d393ddbb1865ae58b8b6"><div class="ttname"><a href="namespacesouffle.html#a82791915ce06d393ddbb1865ae58b8b6">souffle::usesInvalidWitness</a></div><div class="ttdeci">static const std::vector&lt; AstSrcLocation &gt; usesInvalidWitness(const std::vector&lt; AstLiteral * &gt; &amp;literals, const std::set&lt; std::unique_ptr&lt; AstArgument &gt;&gt; &amp;groundedArguments)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00701">AstSemanticChecker.cpp:701</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e134334ce89f6ebc4075e1089b1f80d"><div class="ttname"><a href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00215">AstVisitor.h:215</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a82791915ce06d393ddbb1865ae58b8b6_cgraph.png" border="0" usemap="#namespacesouffle_a82791915ce06d393ddbb1865ae58b8b6_cgraph" alt=""/></div>
<map name="namespacesouffle_a82791915ce06d393ddbb1865ae58b8b6_cgraph" id="namespacesouffle_a82791915ce06d393ddbb1865ae58b8b6_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_aggregator.html#a4deb6a8ea2b7d2ef7cd42c9ca668f8a1" title="souffle::AstAggregator\l::getBodyLiterals" alt="" coords="252,61,404,102"/><area shape="rect" id="node4" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad" title="Analyse the given clause and computes for each contained argument whether it is a grounded value or n..." alt="" coords="238,218,418,244"/><area shape="rect" id="node12" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="251,374,405,400"/><area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="746,28,881,55"/><area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a11ba399d723b5f1135a35e47e51e1bad" title="Provides access to the list of arguments of this atom. " alt="" coords="467,28,677,55"/><area shape="rect" id="node6" href="classsouffle_1_1_ast_record_init.html#ae516fe38512e96c666014acce207b983" title="souffle::AstRecordInit\l::getArguments" alt="" coords="497,80,647,121"/><area shape="rect" id="node7" href="classsouffle_1_1_ast_negation.html#a0737c379dac1c350accecb1e2301698c" title="Returns the nested atom as the referenced atom. " alt="" coords="501,145,643,186"/><area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#ae9a1e5dd0a7c9781e23a7d9ececd6ae5" title="Return the atom that represents the head of the clause. " alt="" coords="507,210,637,252"/><area shape="rect" id="node9" href="classsouffle_1_1_ast_constraint.html#ae25c3601f3786f8ab4eec9837ce02b3a" title="Return LHS argument. " alt="" coords="497,276,647,317"/><area shape="rect" id="node10" href="classsouffle_1_1_ast_constraint.html#ae6843e561217d3c041b5ab58588a6465" title="Return binary operator. " alt="" coords="497,341,647,382"/><area shape="rect" id="node11" href="classsouffle_1_1_ast_constraint.html#af8d3f1b1bca4fcbbb3d15febe5b52041" title="Return RHS argument. " alt="" coords="497,406,647,448"/><area shape="rect" id="node13" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="495,472,649,513"/><area shape="rect" id="node14" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="725,472,901,513"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4e134334ce89f6ebc4075e1089b1f80d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00215">215</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00177">visitDepthFirstPreOrder()</a>.</p>

<p>Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00300">addAggregators()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00313">addBackwardDependencies()</a>, <a class="el" href="_magic_set_8h_source.html#l00138">souffle::BindingStore::addBinding()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00353">addForwardDependencies()</a>, <a class="el" href="_ast_tuner_8cpp_source.html#l00080">souffle::AutoScheduleTransformer::autotune()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00489">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00936">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00048">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00826">souffle::AstSemanticChecker::checkWitnessProblem()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00172">containsAggregators()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00133">containsInlinedAtom()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01249">souffle::Synthesiser::generateCode()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00044">getBodyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00025">getVariables()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00070">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_interpreter_interface_8h_source.html#l00210">souffle::InterpreterProgInterface::InterpreterProgInterface()</a>, <a class="el" href="_ast_clause_8cpp_source.html#l00082">souffle::AstClause::isFact()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00548">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00668">souffle::MaterializeAggregationQueriesTransformer::needsMaterializedRelation()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00696">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00723">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelationUses()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00413">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00025">souffle::ResolveAliasesTransformer::resolveAliases()</a>, <a class="el" href="_component_model_8cpp_source.html#l00023">souffle::ComponentLookup::run()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00116">souffle::RecursiveClauses::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00709">souffle::Adornment::run()</a>, <a class="el" href="_ast_pragma_8cpp_source.html#l00023">souffle::AstPragmaChecker::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00515">souffle::UniqueAggregationVariablesTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00800">souffle::ExtractDisconnectedLiteralsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00958">souffle::ReduceExistentialsTransformer::transform()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01061">souffle::MagicSetTransformer::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01240">souffle::AstTranslator::translateProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00701">usesInvalidWitness()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00285">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                                                                        {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <a class="code" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">visitDepthFirstPreOrder</a>(root, visitor, args...);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ae3213abfc9e18e34bb08056ec91f7b86"><div class="ttname"><a href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00177">AstVisitor.h:177</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4e134334ce89f6ebc4075e1089b1f80d_cgraph.png" border="0" usemap="#namespacesouffle_a4e134334ce89f6ebc4075e1089b1f80d_cgraph" alt=""/></div>
<map name="namespacesouffle_a4e134334ce89f6ebc4075e1089b1f80d_cgraph" id="namespacesouffle_a4e134334ce89f6ebc4075e1089b1f80d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,5,363,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="411,5,587,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a56bfbc8a1f26432a267d67a7b37ab305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const RamNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RamVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragments rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragments to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00263">263</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00177">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                                                                                        {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <a class="code" href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">visitDepthFirstPreOrder</a>(root, visitor, args...);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_afe3257231469cb9f1759b0a615c579dc"><div class="ttname"><a href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const RamNode &amp;root, RamVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00225">RamVisitor.h:225</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a56bfbc8a1f26432a267d67a7b37ab305_cgraph.png" border="0" usemap="#namespacesouffle_a56bfbc8a1f26432a267d67a7b37ab305_cgraph" alt=""/></div>
<map name="namespacesouffle_a56bfbc8a1f26432a267d67a7b37ab305_cgraph" id="namespacesouffle_a56bfbc8a1f26432a267d67a7b37ab305_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,5,363,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="411,5,587,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aed08a0a4f3dee722039516cd22f4ae0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00269">269</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00240">souffle::detail::makeLambdaAstVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                                                               {</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">detail::makeLambdaAstVisitor</a>(fun);</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    visitDepthFirst&lt;void&gt;(root, visitor);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_1_1detail_html_a618834ca4e4f896b9b2a1988c9bedfe4"><div class="ttname"><a href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">souffle::detail::makeLambdaAstVisitor</a></div><div class="ttdeci">LambdaAstVisitor&lt; R, N &gt; makeLambdaAstVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaAstVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00240">AstVisitor.h:240</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph.png" border="0" usemap="#namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph" alt=""/></div>
<map name="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph" id="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4" title="A factory function for creating LambdaAstVisitor instances. " alt="" coords="208,5,395,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a761efe11ed6dcdff18dce42b36bc9662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00285">285</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                                {</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00316">AstVisitor.h:316</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph.png" border="0" usemap="#namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph" alt=""/></div>
<map name="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph" id="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,12,363,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="411,5,565,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="613,5,789,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afefd41fae2027ed1ab90fa721dc8ca6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list of roots of the ASTs to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00300">300</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                                                                   {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : list) {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(*cur, fun);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00316">AstVisitor.h:316</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_afefd41fae2027ed1ab90fa721dc8ca6f_cgraph.png" border="0" usemap="#namespacesouffle_afefd41fae2027ed1ab90fa721dc8ca6f_cgraph" alt=""/></div>
<map name="namespacesouffle_afefd41fae2027ed1ab90fa721dc8ca6f_cgraph" id="namespacesouffle_afefd41fae2027ed1ab90fa721dc8ca6f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,12,363,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="411,5,565,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="613,5,789,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8e6b482457e03d290adeaf963dabd078"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list of roots of the ASTs to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00316">316</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                                                                                 {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : list) {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(*cur, fun);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    }</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00316">AstVisitor.h:316</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph.png" border="0" usemap="#namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph" alt=""/></div>
<map name="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph" id="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,12,363,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="411,5,565,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="613,5,789,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3f56d579f447fc1976686014c8b6fed4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const RamNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00317">317</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p>References <a class="el" href="_ram_visitor_8h_source.html#l00288">souffle::detail::makeLambdaRamVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                                                                               {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0">detail::makeLambdaRamVisitor</a>(fun);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    visitDepthFirst&lt;void&gt;(root, visitor);</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_1_1detail_html_ac9160683411c6e5e09dd6a56645429e0"><div class="ttname"><a href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0">souffle::detail::makeLambdaRamVisitor</a></div><div class="ttdeci">LambdaRamVisitor&lt; R, N &gt; makeLambdaRamVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaRamVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00288">RamVisitor.h:288</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph.png" border="0" usemap="#namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph" alt=""/></div>
<map name="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph" id="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0" title="A factory function for creating LambdaRamVisitor instances. " alt="" coords="208,5,395,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5f75835c6570547ab2d0c50376202dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ram__visitor.html">detail::is_ram_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const RamNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00333">333</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                                                {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <a class="code" href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">visitDepthFirst</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a5f75835c6570547ab2d0c50376202dc7"><div class="ttname"><a href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">souffle::visitDepthFirst</a></div><div class="ttdeci">std::enable_if&lt;!detail::is_ram_visitor&lt; Lambda &gt;::value, void &gt;::type visitDepthFirst(const RamNode &amp;root, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00333">RamVisitor.h:333</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph.png" border="0" usemap="#namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph" alt=""/></div>
<map name="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph" id="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4e134334ce89f6ebc4075e1089b1f80d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,12,363,39"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="411,5,565,46"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="613,5,789,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad9bb9099f19c9e5dcf89e3822728496c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00196">196</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2">souffle::AstNode::getChildNodes()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00177">visitDepthFirstPreOrder()</a>.</p>

<p>Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l00548">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00515">souffle::UniqueAggregationVariablesTransformer::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00431">souffle::AstTranslator::translateClause()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00348">visitDepthFirstPostOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstNode* cur : root.getChildNodes()) {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> (cur) {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <a class="code" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    visitor(root, args...);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ae3213abfc9e18e34bb08056ec91f7b86"><div class="ttname"><a href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00177">AstVisitor.h:177</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad9bb9099f19c9e5dcf89e3822728496c_cgraph.png" border="0" usemap="#namespacesouffle_ad9bb9099f19c9e5dcf89e3822728496c_cgraph" alt=""/></div>
<map name="namespacesouffle_ad9bb9099f19c9e5dcf89e3822728496c_cgraph" id="namespacesouffle_ad9bb9099f19c9e5dcf89e3822728496c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="411,5,587,46"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,34,363,75"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6c4935ab0f9f60f27e711e30ced44ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const RamNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RamVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00244">244</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ram_node.html#a61daa5ca81aac62e49b68fe5b205b460">souffle::RamNode::getChildNodes()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00177">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> RamNode* cur : root.getChildNodes()) {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">if</span> (cur) {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <a class="code" href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        }</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    visitor(root, args...);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_afe3257231469cb9f1759b0a615c579dc"><div class="ttname"><a href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const RamNode &amp;root, RamVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00225">RamVisitor.h:225</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a6c4935ab0f9f60f27e711e30ced44ed9_cgraph.png" border="0" usemap="#namespacesouffle_a6c4935ab0f9f60f27e711e30ced44ed9_cgraph" alt=""/></div>
<map name="namespacesouffle_a6c4935ab0f9f60f27e711e30ced44ed9_cgraph" id="namespacesouffle_a6c4935ab0f9f60f27e711e30ced44ed9_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ram_node.html#a61daa5ca81aac62e49b68fe5b205b460" title="Obtain list of all embedded child nodes. " alt="" coords="208,5,392,46"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="223,70,377,111"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="440,70,616,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8c81a4bc3ebe951bd58b9b323b451e3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00332">332</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00240">souffle::detail::makeLambdaAstVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                                                                                        {</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">detail::makeLambdaAstVisitor</a>(fun);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    visitDepthFirstPostOrder&lt;void&gt;(root, visitor);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_1_1detail_html_a618834ca4e4f896b9b2a1988c9bedfe4"><div class="ttname"><a href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">souffle::detail::makeLambdaAstVisitor</a></div><div class="ttdeci">LambdaAstVisitor&lt; R, N &gt; makeLambdaAstVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaAstVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00240">AstVisitor.h:240</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph.png" border="0" usemap="#namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph" alt=""/></div>
<map name="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph" id="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4" title="A factory function for creating LambdaAstVisitor instances. " alt="" coords="208,5,395,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1033c68a525f042c980bc63e96363062"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00348">348</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="_ast_visitor_8h_source.html#l00196">visitDepthFirstPostOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                                                {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <a class="code" href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">visitDepthFirstPostOrder</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a1033c68a525f042c980bc63e96363062"><div class="ttname"><a href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">souffle::visitDepthFirstPostOrder</a></div><div class="ttdeci">std::enable_if&lt;!detail::is_ast_visitor&lt; Lambda &gt;::value, void &gt;::type visitDepthFirstPostOrder(const AstNode &amp;root, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00348">AstVisitor.h:348</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph.png" border="0" usemap="#namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph" alt=""/></div>
<map name="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph" id="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ad9bb9099f19c9e5dcf89e3822728496c" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,5,363,46"/><area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="613,5,789,46"/><area shape="rect" id="node4" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="411,34,565,75"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae3213abfc9e18e34bb08056ec91f7b86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPreOrder </td>
          <td>(</td>
          <td class="paramtype">const AstNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00177">177</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2">souffle::AstNode::getChildNodes()</a>.</p>

<p>Referenced by <a class="el" href="_ast_visitor_8h_source.html#l00215">visitDepthFirst()</a>, <a class="el" href="_ast_visitor_8h_source.html#l00196">visitDepthFirstPostOrder()</a>, and <a class="el" href="_ram_visitor_8h_source.html#l00225">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    visitor(root, args...);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstNode* cur : root.getChildNodes()) {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">if</span> (cur) {</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <a class="code" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_ae3213abfc9e18e34bb08056ec91f7b86"><div class="ttname"><a href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const AstNode &amp;root, AstVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00177">AstVisitor.h:177</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae3213abfc9e18e34bb08056ec91f7b86_cgraph.png" border="0" usemap="#namespacesouffle_ae3213abfc9e18e34bb08056ec91f7b86_cgraph" alt=""/></div>
<map name="namespacesouffle_ae3213abfc9e18e34bb08056ec91f7b86_cgraph" id="namespacesouffle_ae3213abfc9e18e34bb08056ec91f7b86_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="208,5,384,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afe3257231469cb9f1759b0a615c579dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPreOrder </td>
          <td>(</td>
          <td class="paramtype">const RamNode &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RamVisitor&lt; R, Ps...&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00225">225</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p>References <a class="el" href="classsouffle_1_1_ram_node.html#a61daa5ca81aac62e49b68fe5b205b460">souffle::RamNode::getChildNodes()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00177">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                                                                                {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    visitor(root, args...);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> RamNode* cur : root.getChildNodes()) {</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">if</span> (cur) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <a class="code" href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_afe3257231469cb9f1759b0a615c579dc"><div class="ttname"><a href="namespacesouffle.html#afe3257231469cb9f1759b0a615c579dc">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const RamNode &amp;root, RamVisitor&lt; R, Ps...&gt; &amp;visitor, Args &amp;...args)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00225">RamVisitor.h:225</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_afe3257231469cb9f1759b0a615c579dc_cgraph.png" border="0" usemap="#namespacesouffle_afe3257231469cb9f1759b0a615c579dc_cgraph" alt=""/></div>
<map name="namespacesouffle_afe3257231469cb9f1759b0a615c579dc_cgraph" id="namespacesouffle_afe3257231469cb9f1759b0a615c579dc_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ram_node.html#a61daa5ca81aac62e49b68fe5b205b460" title="Obtain list of all embedded child nodes. " alt="" coords="208,5,392,46"/><area shape="rect" id="node3" href="namespacesouffle.html#ae3213abfc9e18e34bb08056ec91f7b86" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="223,70,377,111"/><area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a3726392849b2a07142ba13bbd5fb16d2" title="Obtain a list of all embedded AST child nodes. " alt="" coords="440,70,616,111"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6e9757564e85959db8b14a9be7d544e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::which </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple implementation of a which tool. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00965">965</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                                              {</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    <span class="keywordtype">char</span> buf[PATH_MAX];</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    <span class="keywordflow">if</span> (::realpath(<a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>.c_str(), buf) &amp;&amp; <a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(buf)) {</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;        <span class="keywordflow">return</span> std::string(buf);</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    }</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    std::string syspath = ::getenv(<span class="stringliteral">&quot;PATH&quot;</span>);</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    std::stringstream sstr(syspath);</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    std::string <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>;</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    <span class="keywordflow">while</span> (std::getline(sstr, sub, <span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;        std::string path = sub + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>;</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(path) &amp;&amp; realpath(path.c_str(), buf)) {</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;            <span class="keywordflow">return</span> std::string(buf);</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;        }</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    }</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;}</div>
<div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00223">Constraints.h:223</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00958">Util.h:958</a></div></div>
<div class="ttc" id="_ast_translator_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="_ast_translator_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition:</b> <a href="_ast_translator_8cpp_source.html#l00196">AstTranslator.cpp:196</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ad8eee90b91127c302f9bdc1a2778101c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t souffle::BLOCKBITS = 10u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_block_list_8h_source.html#l00218">218</a> of file <a class="el" href="_block_list_8h_source.html">BlockList.h</a>.</p>

<p>Referenced by <a class="el" href="_block_list_8h_source.html#l00280">souffle::BlockList&lt; parent_t &gt;::add()</a>, <a class="el" href="_block_list_8h_source.html#l00436">souffle::BlockList&lt; T &gt;::add()</a>, <a class="el" href="_block_list_8h_source.html#l00300">souffle::BlockList&lt; parent_t &gt;::get()</a>, <a class="el" href="_block_list_8h_source.html#l00353">souffle::BlockList&lt; parent_t &gt;::niptuck()</a>, and <a class="el" href="_block_list_8h_source.html#l00325">souffle::BlockList&lt; parent_t &gt;::pop()</a>.</p>

</div>
</div>
<a class="anchor" id="a33b448fc0efb23fa5e14bc09cccba6a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t souffle::BLOCKSIZE = (1u &lt;&lt; BLOCKBITS)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_block_list_8h_source.html#l00219">219</a> of file <a class="el" href="_block_list_8h_source.html">BlockList.h</a>.</p>

<p>Referenced by <a class="el" href="_block_list_8h_source.html#l00280">souffle::BlockList&lt; parent_t &gt;::add()</a>, <a class="el" href="_block_list_8h_source.html#l00436">souffle::BlockList&lt; T &gt;::add()</a>, <a class="el" href="_block_list_8h_source.html#l00240">souffle::BlockList&lt; parent_t &gt;::BlockList()</a>, <a class="el" href="_block_list_8h_source.html#l00300">souffle::BlockList&lt; parent_t &gt;::get()</a>, <a class="el" href="_block_list_8h_source.html#l00353">souffle::BlockList&lt; parent_t &gt;::niptuck()</a>, and <a class="el" href="_block_list_8h_source.html#l00325">souffle::BlockList&lt; parent_t &gt;::pop()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9fcff3b64ca9bdaadbe6a038ee2e4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">QueryExecutionStrategy</a> souffle::DirectExecution</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](</div>
<div class="line">        <span class="keyword">const</span> RamInsert&amp; insert, InterpreterEnvironment&amp; env, std::ostream*) -&gt; ExecutionSummary {</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">now</a>();</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">    apply(insert.getOperation(), env);</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">now</a>();</div>
<div class="line">    <span class="keywordflow">return</span> ExecutionSummary(</div>
<div class="line">            {Order::getIdentity(insert.getOrigin().getAtoms().size()), <a class="code" href="namespacesouffle.html#a5a93424fa42c59893383c23ecf475766">duration_in_ms</a>(start, end)});</div>
<div class="line">}</div>
<div class="ttc" id="namespacesouffle_html_a1c65551944c7ecf6f44ec851b49bdbb0"><div class="ttname"><a href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a></div><div class="ttdeci">time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00911">Util.h:911</a></div></div>
<div class="ttc" id="namespacesouffle_html_a5a93424fa42c59893383c23ecf475766"><div class="ttname"><a href="namespacesouffle.html#a5a93424fa42c59893383c23ecf475766">souffle::duration_in_ms</a></div><div class="ttdeci">long duration_in_ms(const time_point &amp;start, const time_point &amp;end)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00916">Util.h:916</a></div></div>
</div><!-- fragment -->
<p>With this strategy queries will be processed as they are stated by the user. </p>
<p>With this strategy queries will be processed without profiling. </p>

<p>Definition at line <a class="el" href="_interpreter_8cpp_source.html#l00987">987</a> of file <a class="el" href="_interpreter_8cpp_source.html">Interpreter.cpp</a>.</p>

<p>Referenced by <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a10ebbb9279d847e1780c7423a4adf030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#ac0f91401943febd1544ad82fd99bcb04">block_t</a> souffle::rank_mask = (1ul &lt;&lt; split_size) - 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_union_find_8h_source.html#l00061">61</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

<p>Referenced by <a class="el" href="_union_find_8h_source.html#l00459">souffle::DisjointSet::b2r()</a>.</p>

</div>
</div>
<a class="anchor" id="ae807f7b8118a77f250c57d1c3a08905e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesouffle.html#ad9b2899eb6927d9ee92a3628e0c5f4fc">QueryExecutionStrategy</a> souffle::ScheduledExecution</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With this strategy queries will be dynamically rescheduled before each execution. </p>
<p>With this strategy queries will be dynamically with profiling. </p>

<p>Definition at line <a class="el" href="_interpreter_8cpp_source.html#l01002">1002</a> of file <a class="el" href="_interpreter_8cpp_source.html">Interpreter.cpp</a>.</p>

<p>Referenced by <a class="el" href="_ast_tuner_8cpp_source.html#l00080">souffle::AutoScheduleTransformer::autotune()</a>, and <a class="el" href="main_8cpp_source.html#l00119">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6cae1829154de74317f872045c811c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t souffle::split_size = 32u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_union_find_8h_source.html#l00060">60</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

<p>Referenced by <a class="el" href="_union_find_8h_source.html#l00450">souffle::DisjointSet::b2p()</a>, and <a class="el" href="_union_find_8h_source.html#l00469">souffle::DisjointSet::pr2b()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 14 2018 11:37:58 for souffle by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
